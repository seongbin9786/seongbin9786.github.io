<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>카테고리: Linux - JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">카테고리</a></li><li class="is-active"><a href="#" aria-current="page">Linux</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-11T14:55:00.000Z" title="2021-04-11T14:55:00.000Z">21-04-11</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-04-11T14:58:37.700Z" title="2021-04-11T14:58:37.700Z">21-04-11</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">8분안에 읽기 (약 1220 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-user-and-sudo/">Linux와 Docker의 기술적 관계 (1/3)</a></h1><div class="content"><p>이 글은 리눅스의 Namespace 기능의 일부를 다룬다. 도커의 내용도 포함되겠으나 리눅스 자체의 기능에 주안점을 둔다. 우선 PID, UTS를 다루고, chroot에 대해서도 소개한다.</p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64) (Docker Desktop)</p>
<p>일부 기능은 Native Docker에서만 정상 작동하여 아래 환경도 활용하였다.<br>Ubuntu 20.04.1 LTS (GCP Compute Engine) (Native Docker)</p>
</blockquote>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.44bits.io/ko/keyword/linux-container">리눅스 컨테이너</a>는 리눅스 <strong>네임스페이스</strong>와 루트 파일 시스템 격리 등의 기능을 사용해 격리시킨 프로세스를 의미한다.</p>
</blockquote>
<h3 id="namespace라는-기술에-대해"><a href="#namespace라는-기술에-대해" class="headerlink" title="namespace라는 기술에 대해"></a><strong>namespace라는 기술에 대해</strong></h3><p><a target="_blank" rel="noopener" href="https://www.44bits.io/ko/keyword/linux-namespace">리눅스 네임스페이스(Linux Namespace)란?</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_namespaces">Namespace</a>는 한 개의 특정 프로세스에 대해 시스템 리소스를 논리적으로 격리하는 기능이다. 아래와 같이 여러 가지의 Namespace가 존재한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 cgroup -&gt; <span class="string">&#x27;cgroup:[4026531835]&#x27;</span> <span class="comment"># cgroup = control group = CPU,RAM,NET 할당</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 ipc -&gt; <span class="string">&#x27;ipc:[4026532188]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 06:41 mnt -&gt; <span class="string">&#x27;mnt:[4026532186]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 net -&gt; <span class="string">&#x27;net:[4026531992]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 pid -&gt; <span class="string">&#x27;pid:[4026532189]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 08:35 pid_for_children -&gt; <span class="string">&#x27;pid:[4026532189]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 user -&gt; <span class="string">&#x27;user:[4026531837]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 uts -&gt; <span class="string">&#x27;uts:[4026532187]&#x27;</span> <span class="comment"># uts=Unix Time-Sharing / Host, Domain name 할당</span></span><br></pre></td></tr></table></figure>
<p>Docker에서 사용하는 Namespace의 목록은 아래와 같다.</p>
<ul>
<li><code>ipc, mnt, net, pid, pid_for_children, uts</code></li>
</ul>
<h4 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a><strong>PID Namespace</strong></h4><ol>
<li><p>분리된 새로운 네임스페이스에서는 PID=1부터 시작하나, 기존 네임스페이스에서도 (다른 PID로) 해당 프로세스를 볼 수 있으며, 이는 PID=1부터 시작하지 않는다.</p>
</li>
<li><p><code>ls -alh /proc/&#123;PID&#125;/ns</code> - PID에 대응되는 프로세스가 속한 네임스페이스를 출력한다. (sym link 형태의 구성)</p>
</li>
</ol>
<ul>
<li><p>위의 결과는 같은 1번 프로세스에서 생성된 경우 모두 같은 값을 갖는다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ diff &lt;(ls -Al /proc/1/ns | awk <span class="string">&#x27;&#123; print $11 &#125;&#x27;</span>) \ </span><br><span class="line">&lt;(ls -Al /proc/&#123;임의의_프로세스ID&#125;/ns | awk <span class="string">&#x27;&#123; print $11 &#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>User namespace는 UID 0을 줘서 root  <strong>같아 보이는</strong> - 어느 정도 제한된 - 권한을 제공할 수 있다. User namespace는 initial이 있고, 매 생성마다 Parent-Child 구조를 갖는다.</p>
</li>
<li><p>PID namespace 격리를 위해선 격리된 디렉토리에서의 모든 의존성이 준비 돼야 한다. - 의존성? docker Image가 하는 일이 바로 그것이니, docker Image를 활용해 mount한 폴더를 활용할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ~</span><br><span class="line">$ docker <span class="built_in">export</span> ~ &gt; ~.tar</span><br><span class="line">$ tar xf ~</span><br><span class="line">$ sudo unshare -p -f --mount-proc chroot . ./image_extracted_dir /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo $$</span></span><br><span class="line">&gt; 1</span><br></pre></td></tr></table></figure></li>
<li><p><code>unshare</code> 명령어를 써서 PID를 격리해 1번 프로세스가 되는 예시:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ unshare -p -f --mount-proc chroot . /bin/sh</span><br><span class="line">&gt; <span class="built_in">echo</span> $$ : 1</span><br><span class="line"></span><br><span class="line">$ unshare -p /bin/sh</span><br><span class="line">&gt; <span class="built_in">echo</span> $$: 3481</span><br></pre></td></tr></table></figure></li>
<li><p>각종 옵션들 정리</p>
<ol>
<li><code>p</code>: <em>PID 네임스페이스는 분리가 되었을텐데</em> 로 짐작해보건데 PID 네임스페이스를 의미하는 듯하다.</li>
<li><code>f</code>: <code>--fork</code>의 의미로, <code>unshare</code>의 child process로 실행한다고 한다.</li>
<li><code>--mount-proc</code>: <code>/proc</code> 이 기본값이어서, 기존 proc과 격리될 수 없다. 위 명령어에선 현재 폴더(.)를 넘겼다. </li>
</ol>
<ul>
<li>man page에선 <em>The new proc filesystem is explicitly as private</em>라고 하는데, 여기서 <em>private</em>이 무슨 뜻인지 모르겠다. 그리고, <em>mount proc filesystem</em>한다는 표현도 무슨 뜻인지 잘 모르겠다.</li>
<li>shell이 지원하는 명령어가 아니라 바이너리를 실행하려고 하면 <code>2: Cannot fork</code>라고 뜬다. Why?</li>
</ul>
<ol start="4">
<li>Host Shell에서 <code>ps -ef</code>하면 unshare도 하나의 프로세스로 뜨고, <code>sudo kill -9 3481</code> 하면 unshare도 종료된다.</li>
<li>프로세스 3481 == 프로세스 1 (unshare도 단지 하나의 프로세스)</li>
<li><code>/proc</code> 이 기본 PID namepsace이고, <code>init</code> 프로세스(pid 1)에 의해 pid namespace가 다 동일하다.</li>
<li><code>unshare</code>로 다른 디렉토리에 PID namespace를 mount하면 그 때부터 pid namepsace 값이 다른 값으로 할당됨</li>
</ol>
</li>
</ol>
<h4 id="UTS-Namepsace"><a href="#UTS-Namepsace" class="headerlink" title="UTS Namepsace"></a><strong>UTS Namepsace</strong></h4><p>출처: <a target="_blank" rel="noopener" href="https://www.44bits.io/ko/post/container-network-1-uts-namespace">UTS 네임스페이스를 사용한 호스트네임 격리 - 컨테이너 네트워크 기초 1편</a></p>
<p>UTS Namespace는 호스트 네임을 분리한다. 딱 이것만 한다. 별로 기능은 없다.</p>
<p>docker는 컨테이너마다 컨테이너ID로 호스트네임을 부여한다. 이 기능을 구현하는 방법은 무엇일까? <code>nsenter</code>로 가능하다. <code>nsenter</code>는 unshare로 지정한 네임스페이스 정보를 기반으로 프로세스를 실행하는 프로그램이다.</p>
<ol>
<li><code>unshare --uts=/tmp/utsns1 hostname utsns1</code> 명령으로 utsns1로 새로운 namespace를 정의하고 실행할 수 있다.</li>
<li><code>/tmp/utsns1</code> 파일에 unshare 설정을 저장한 후, </li>
<li><code>nsenter --uts=/tmp/utsns1 hostname</code> 수행 시 utsns1를 출력할 수 있다.</li>
</ol>
<h4 id="Network-Namepsace"><a href="#Network-Namepsace" class="headerlink" title="Network Namepsace"></a><strong>Network Namepsace</strong></h4><p>Network Namespace는 프로세스의 네트워크 환경을 분리한다. 실제로 docker 컨테이너마다 네트워크 인터페이스와 IP가 부여된다.</p>
<ul>
<li>(2편에서 확인할 예정)</li>
</ul>
<hr>
<p>TODO:</p>
<ul>
<li>네트워크 부분 더 공부하기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-04T12:35:00.000Z" title="2021-04-04T12:35:00.000Z">21-04-04</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-04-11T14:34:55.179Z" title="2021-04-11T14:34:55.179Z">21-04-11</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">8분안에 읽기 (약 1135 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-namespaces-1/">리눅스에서의 sudo와 권한 관리 (1)</a></h1><div class="content"><p>이 글은 리눅스에서 sudo를 소개하고, 권한 관리에 대해 생각해본다. 예시 중에서 사용자를 생성하는 방법 또한 다룬다.</p>
<p>참고 자료</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/Sudo">sudo | Wikipedia (KR)</a></li>
</ul>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64)</p>
</blockquote>
<hr>
<blockquote>
<p>su와 sudo는 약자이다. su는 “substitute user”, sudo는 “substitute user do”이다.</p>
</blockquote>
<h3 id="리눅스에서의-su-사용법과-사용자-생성"><a href="#리눅스에서의-su-사용법과-사용자-생성" class="headerlink" title="리눅스에서의 su 사용법과 사용자 생성"></a><strong>리눅스에서의 su 사용법과 사용자 생성</strong></h3><p>su는 현재 로그인된 사용자에서 다른 사용자로 로그인하는 것이다.</p>
<p>사용자 목록은 <code>cat /etc/passwd</code>로 볼 수 있다. (이름과 다르게 비밀번호가 나오진 않는다.) </p>
<p>각 사용자의 암호화된 비밀번호를 확인하려면 <code>cat /etc/shadow</code>를 확인하라.</p>
<p>어떤 암호화가 쓰였는지는 <code>cat /etc/pam.d/common-password</code>로 확인할 수 있다 - 기준 환경에서는 <code>sha-512</code>를 사용한다. (출처: <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/8229/what-methods-are-used-to-encrypt-passwords-in-etc-passwd-and-etc-shadow">What methods are used to encrypt passwords in /etc/passwd and /etc/shadow?</a>)</p>
<hr>
<p>재밌는 점은, 사용자가 직접 만든 계정이 아닌 경우 로그인할 수 없게 되있다는 점이다. (출처: <a target="_blank" rel="noopener" href="https://askubuntu.com/questions/426990/what-are-the-default-passwords-of-these-users-nobody-daemon-uucp-etc">What are the default passwords of these users: nobody, daemon, uucp, etc.?</a>)</p>
<p><img src="/images/linux-sudo/sudoer2.png" alt="모든 그룹의 이름만 출력한 경우"></p>
<p>만약 ‘사람이 사용하는 용도의’ 사용자 목록을 확인하려면, <code>cat /bin/bash /etc/passwd</code>로 확인할 수 있다.</p>
<p><img src="/images/linux-sudo/sudoer3.png" alt="시스템 계정 제외하고 출력"></p>
<hr>
<p>사용자를 추가해서, 해당 사용자로 로그인해보자.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd tmp <span class="comment"># tmp는 유저명이다. 나머지는 자동으로 생성해준다. (단, 비밀번호가 없는 상태이다.)</span></span><br><span class="line">sudo passwd tmp <span class="comment"># 로그인을 하려면 비밀번호를 설정해야 한다. passwd 명령어로 비밀번호를 지정할 수 있다.</span></span><br><span class="line">su tmp</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> <span class="comment"># bash가 사라져서, 현재 셸을 출력해봤다. 기본 셸은 dash인걸로 아는데, /bin/sh를 사용하고 있다.</span></span><br><span class="line">bash <span class="comment"># bash shell로 전환한다.</span></span><br></pre></td></tr></table></figure>
<p>이렇게 로그인하면 bash가 사라지고, sh가 셸로 사용된다. (<code>chsh</code>로 바꿀 수 있다.)</p>
<hr>
<h3 id="사용자가-sudo를-사용할-수-있게-만들기-sudo의-권한에-대하여"><a href="#사용자가-sudo를-사용할-수-있게-만들기-sudo의-권한에-대하여" class="headerlink" title="사용자가 sudo를 사용할 수 있게 만들기, sudo의 권한에 대하여"></a><strong>사용자가 sudo를 사용할 수 있게 만들기, sudo의 권한에 대하여</strong></h3><p>sudo는 특정 작업을 root 권한으로 수행할 수 있게 하는 명령어이다. 특정 사용자를 sudo 그룹에 추가하기만 하면 된다: <code>sudo usermod -aG sudo &#123;사용자명&#125;</code>. 이후 사용자는 sudo 명령어를 사용할 수 있게 된다.</p>
<hr>
<p><img src="/images/linux-sudo/sudoer1.png" alt="sudo 파일의 내용"></p>
<p>각 유저에 대한 권한은 <code>/etc/sudoers</code>에 있는데, 권한의 포멧이 있다: <code>%sudo ALL=(ALL:ALL) ALL</code> 이것인데, (출처: <a target="_blank" rel="noopener" href="https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file">How To Edit the Sudoers File</a>) </p>
<table>
<thead>
<tr>
<th>%sudo</th>
<th>ALL=</th>
<th>(ALL:</th>
<th>ALL)</th>
<th>ALL</th>
</tr>
</thead>
<tbody><tr>
<td>username 규칙</td>
<td>hostname 규칙</td>
<td>sudo로 로그인할 수 있는 사용자 목록</td>
<td>sudo로 로그인할 수 있는 그룹 목록</td>
<td>root 권한으로 사용할 수 있는 명령어</td>
</tr>
</tbody></table>
<p>지금 알고 있는 지식으로는 sudo 파일의 Best Practice를 소개는 어렵기 때문에 추후로 미루지만, 권한 제어를 폭 넓게 할 수 있도록 필드가 5개나 된다는 점은 확인할 수 있었다. (아직 한 번도 sudoer 설정을 만져본 적이 없다는 점은 좀 부끄럽기도 하다.)</p>
<hr>
<h3 id="sudo의-장점"><a href="#sudo의-장점" class="headerlink" title="sudo의 장점"></a><strong>sudo의 장점</strong></h3><p>출처: <a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/135352/best-practices-for-hardening-sudo">Best practices for hardening sudo?</a></p>
<ol>
<li><p>sudo는 Root Password 공유를 막는다.</p>
</li>
<li><p><code>syslog</code> 등의 명령을 통해, sudo를 사용하는 경우 원격 서버로 로그를 전송하게 해서 더 빠르게 침입을 알아낼 수 있다.</p>
</li>
<li><p>제대로 권한 설정만 한다면 Root 권한보다 많이 축소되므로 침입자가 모든 기록을 말소하지 못하게 할 수 있다. (온전한 root 권한을 탈취 당한 경우 아무 소용이 없게 된다.)</p>
</li>
</ol>
<blockquote>
<p>위 출처의 아래 답변에서 얻은 사실인데, <code>ssh_user</code> 그룹을 만들어 remote login만 가능하게 하면 공격자가 ssh credential을 탈취하더라도 sudo 명령을 활용할 수 없기 때문에 보안 상 더 안전하다고 한다. (굉장히 유용한 방법인 듯하다.)</p>
</blockquote>
<hr>
<p>TODO:</p>
<ul>
<li>프로덕션 배포용 서버에 적절한 sudoer 설정에 대해 찾아보기</li>
<li>sudo 등의 예시 외에도 리눅스 상에서 보안 관련한 기능과 설정들을 찾아보기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-28T14:58:00.000Z" title="2021-03-28T14:58:00.000Z">21-03-28</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-28T14:56:25.740Z" title="2021-03-28T14:56:25.740Z">21-03-28</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">9분안에 읽기 (약 1334 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-how-to-find-files/">리눅스에서 파일을 찾는 방법</a></h1><div class="content"><p>이 글은 리눅스 환경에서 파일을 찾는 방법을 정리한 글이다. <a target="_blank" rel="noopener" href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=131835745">리눅스 핵심 레퍼런스</a>를 참고하여 작성하였다.</p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64)</p>
</blockquote>
<hr>
<h3 id="파일을-찾는-명령의-종류"><a href="#파일을-찾는-명령의-종류" class="headerlink" title="파일을 찾는 명령의 종류"></a><strong>파일을 찾는 명령의 종류</strong></h3><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>find</td>
<td>파일, 디렉토리 검색 중 가장 많은 옵션을 제공한다. 상대적으로 느리다.</td>
</tr>
<tr>
<td>locate (mlocate)</td>
<td>파일, 디렉토리 Index를 만들고, 해당 Index 로 검색을 수행한다.</td>
</tr>
<tr>
<td>which</td>
<td>셸의 탐색 경로 내에서 <strong>명령어</strong>의 위치를 찾는다.</td>
</tr>
<tr>
<td>type</td>
<td>Bash 셸 내장 프로그램으로 which와 같은 기능이지만 더 빠르다.</td>
</tr>
<tr>
<td>whereis</td>
<td>매개변수로 주어진 디렉토리 목록에 대해 탐색한다.</td>
</tr>
</tbody></table>
<hr>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a><strong>find</strong></h3><p>find의 경우 Man Page가 굉장히 어려워 <a target="_blank" rel="noopener" href="https://www.tecmint.com/35-practical-examples-of-linux-find-command/">35 Practical Examples of Linux Find Command</a>를 참고했다. 해당 페이지 제목에서도 알 수 있듯, 한 명령어 설명에 35개의 예제가 들어간다는 것부터 범상치 않음을 짐작할 수 있다. find는 정말 그 기능이 너무나 많다. 정말 강력하다고 할 수 있으나 인덱싱이 지원되지 않아 탐색 대상이 늘어나면 꽤 느려져서 전체 디렉토리 대상으로 수행할 거라면 Interactive한 일회성 작업에 적절할 것 같다.</p>
<p>아래의 모든 옵션은 직접 테스트 후 작성하였다.</p>
<hr>
<p><strong>1. 공통 기능</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>옵션 앞에 <code>!</code>를 붙이면 NOT 조건이 된다.</td>
<td><code>find ! -name &quot;*.txt&quot;</code></td>
<td>“*.txt”에 매칭되지 않는 파일, 디렉토리만 출력</td>
</tr>
</tbody></table>
<hr>
<p><strong>2. 이름 기반 검색</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Ouput</th>
</tr>
</thead>
<tbody><tr>
<td>(x)</td>
<td><code>find</code></td>
<td>하위 디렉토리 <strong>전부</strong> 재귀적으로 출력 (grep 하려면 전체 방문을 기다려야 함)</td>
</tr>
<tr>
<td>-name</td>
<td><code>find -name input.txt</code></td>
<td>하위 디렉토리에서 <code>input.txt</code>를 찾아 출력</td>
</tr>
<tr>
<td>-name “패턴”</td>
<td><code>find -name &quot;*.txt&quot;</code></td>
<td>*.txt에 매칭되는 파일/디렉토리 검색 (<code>*</code>만 사용 가능한지 모르겠음)</td>
</tr>
<tr>
<td>(폴더 명시)</td>
<td><code>find /bin (options...)</code></td>
<td><code>/bin</code> 아래에서 검색을 수행</td>
</tr>
<tr>
<td>-type</td>
<td>`find -type (f</td>
<td>d)`</td>
</tr>
</tbody></table>
<hr>
<p><strong>3. 권한 기반 검색</strong></p>
<blockquote>
<p>권한 비트 앞에 0, 1, 2 등 한 바이트가 더 표현할 수 있는데 SGID, Sticky Bit 등의 내용에 대해 잘 이해하고 있지 못해서 생략했다. 추후 보강하겠다.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Options</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-perm 권한</td>
<td><code>find -perm 777</code></td>
<td>권한이 777인 파일, 디렉토리를 출력</td>
</tr>
<tr>
<td>-perm /권한</td>
<td><code>find -perm /u=r</code></td>
<td><strong>(이 부분은 스펙과 출력이 달라서 추후 갱신할 예정입니다.)</strong> user 권한이 r인 파일(Read-only), 디렉토리를 출력 (대신 첫 글자만 해석함. rw 등 안 됨)</td>
</tr>
</tbody></table>
<hr>
<p><strong>4. 출력에 대해 다른 명령어 수행</strong></p>
<p><code>-exec</code> 옵션이 있는데, <code>-exec COMMAND &#123;&#125; \;</code>와 같이 표시하는 형태이다. <code>&#123;&#125;</code> 가 각 라인이 들어갈 placeholder인 듯하다. 다만 이는 Pipelining으로도 충분히 가능해보여서 (-exec은 스트리밍을 지원하는건가?) 설명은 생략한다.</p>
<hr>
<p><strong>5. 소유자 기반 검색</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-user 소유자명</td>
<td><code>find -user root</code></td>
<td>root 소유의 파일, 디렉토리 출력</td>
</tr>
<tr>
<td>-group 그룹명</td>
<td><code>find -group sb</code></td>
<td>sb 소유의 파일, 디렉토리 출력 (sb는 제 유저명입니다)</td>
</tr>
</tbody></table>
<blockquote>
<p>참고로 그룹의 목록은 /etc/group 파일에 텍스트로 저장돼있다 :)</p>
</blockquote>
<hr>
<p><strong>6. 시간 속성 기반 검색</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-mtime N</td>
<td><code>find ~ -mtime 1</code></td>
<td>1일 내에 <strong>변경된</strong> <code>~</code> 내의 파일 출력</td>
</tr>
<tr>
<td>-atime</td>
<td></td>
<td>접근 시각 기준</td>
</tr>
<tr>
<td>-mtime +N -mtime -M</td>
<td><code>find ~ -mtime +50 -mtime -100</code></td>
<td>N일보다 더 지나고 N일 보다 덜 지난 날짜 사이에서 변경된 <code>~</code> 내의 파일 출력</td>
</tr>
<tr>
<td>-cmin/mmin N</td>
<td><code>find -cmin/mmin 60</code></td>
<td>현재 디렉토리 아래에 변경된 지 60분 이내의 파일 출력</td>
</tr>
<tr>
<td>-amin N</td>
<td><code>find -amin 60</code></td>
<td>현재 디렉토리 아래에 접근한 지 60분 이내의 파일 출력</td>
</tr>
</tbody></table>
<p><strong>7. 파일 크기 기반 검색</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-size N</td>
<td><code>find -size 50M</code></td>
<td>50M인 파일 출력</td>
</tr>
<tr>
<td>-size +N -M</td>
<td><code>find -size +50M -100M</code></td>
<td>50M ~ 100M인 파일 출력 (초과, 미만)</td>
</tr>
</tbody></table>
<hr>
<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a><strong>locate</strong></h3><p>파일, 디렉토리 Index를 만들고, 해당 Index 로 검색을 수행한다. </p>
<p>기본 Index 파일이 생성되는 경로는 <code>/var/lib/mlocate/mlocate.db</code> 이다.</p>
<p>Index에서 검색하므로 가장 빠르다.</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-b \NAME (–basename)</td>
<td><code>locate \input.txt</code></td>
<td>input.txt와 일치하는 이름을 가진 모든 파일/디렉토리를 출력</td>
</tr>
</tbody></table>
<hr>
<h3 id="which-type"><a href="#which-type" class="headerlink" title="which, type"></a><strong>which, type</strong></h3><p>셸의 탐색 경로 내에서 명령어의 위치를 찾는다.</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>명령어에 대한 모든 일치하는 바이너리 위치를 출력</td>
</tr>
</tbody></table>
<hr>
<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a><strong>whereis</strong></h3><p>매개변수로 주어진 디렉토리 목록에 대해 탐색한다.</p>
<p><code>whereis -bm ls tr -m gcc</code> : ls, tr 검색어에 대해 Binary, ManPage 검색 + gcc 검색어에 대해 ManPage 검색</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>Description</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-b (binary)</td>
<td>검색어에 대응되는 바이너리 검색을 한다</td>
<td></td>
</tr>
<tr>
<td>-B,M,S [directories…]</td>
<td>-b/m/s 옵션으로 검색 시 탐색할 디렉토리</td>
<td></td>
</tr>
<tr>
<td>-m (manual)</td>
<td>검색어에 대응되는 매뉴얼 검색을 한다 (Man Page)</td>
<td></td>
</tr>
<tr>
<td>-s (sources)</td>
<td>검색에어 대응되는 소스파일 검색을 한다</td>
<td></td>
</tr>
<tr>
<td>-f</td>
<td>-B, -M, -S 옵션 사용시 반드시 사용해야 함. 찾을 검색어와 옵션의 구분자 역할을 한다</td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>TODO:</p>
<ul>
<li>find 이외에는 문서가 자세하고 정확한 경우는 잘 없어서 조사가 더 필요할 것 같다.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-21T13:00:00.000Z" title="2021-03-21T13:00:00.000Z">21-03-21</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-21T13:03:26.540Z" title="2021-03-21T13:03:26.540Z">21-03-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">15분안에 읽기 (약 2215 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-shell-1/">리눅스 셸(bash) 기본 기능 소개</a></h1><div class="content"><p>이 글에서 소개할 내용은 굉장히 유용한 기능이라고 생각하며, 셸의 역할인 코드 실행 시의 입/출력에 대한 Proxy, Middleware 역할을 잘 활용하는 기능들이라고 생각한다. 이 글은 리눅스 핵심 레퍼런스의 일부를 참고해 작성하였다. </p>
<hr>
<blockquote>
<p>셸은 단순한 호출보다 훨씬 많은 것을 할 수 있다.</p>
</blockquote>
<hr>
<h3 id="1-wildcard-정규표현식과-유사한-검색을-수행한-결과를-명령의-입력으로-사용"><a href="#1-wildcard-정규표현식과-유사한-검색을-수행한-결과를-명령의-입력으로-사용" class="headerlink" title="1. wildcard: 정규표현식과 유사한 검색을 수행한 결과를 명령의 입력으로 사용"></a><strong>1. wildcard: 정규표현식과 유사한 검색을 수행한 결과를 명령의 입력으로 사용</strong></h3><hr>
<h4 id="1-가장-기본이-되는-예제"><a href="#1-가장-기본이-되는-예제" class="headerlink" title="1. 가장 기본이 되는 예제"></a>1. 가장 기본이 되는 예제</h4><p>이름에 wildcard 검색을 수행해 결과를 명령의 입력으로 사용할 수 있다. 이름 일치 기준은 디렉토리이다. 즉 <code>a*</code>를 셸 명령어에 입력하게 되면, <code>./a</code>로 시작하는 파일/디렉토리를 반환한다. 특정 상위 폴더나 하위 폴더를 대상으로 검색하고 싶은 경우 그에 맞는 상대 경로를 입력하면 된다.  </p>
<hr>
<p>(ex 1) <code>ls a*</code> == <code>ls aardvark adamantium apple</code>  </p>
<p>(ex 2) <code>ls githubblog/.*</code> == <code>ls githubblog/.git githubblog/.deploy_git, ...</code></p>
<p><img src="/images/linux-shell/a1.png" alt="기준 디렉토리 목록"></p>
<p>위 사진은 기준 디렉토리이다. 여기서 <code>g*</code> 인 파일/디렉토리를 <code>ls -alF</code>의 매개변수로 주려고 한다. </p>
<p><img src="/images/linux-shell/a2.png" alt="g*에 해당하는 목록을 wildcard를 통해 입력으로 사용"></p>
<p>위 사진은 명령의 결과물로, 실제로 잘 수행됨을 확인할 수 있다.</p>
<hr>
<h4 id="2-추가-옵션"><a href="#2-추가-옵션" class="headerlink" title="2.추가 옵션"></a>2.추가 옵션</h4><p><code>[문자들...]</code> : 문자들 중 하나와 일치하는 경우. </p>
<ul>
<li><code>[aieou]</code> : 모음 중 하나. 단 이렇게 찾으려면 파일/디렉토리 이름이 a, i, e, o, u 중 하나여야 한다. (즉 한 글자)</li>
</ul>
<hr>
<p><code>[^문자들...]</code>, <code>[!문자들...]</code> : 명시된 문자 이외의 any 문자</p>
<ul>
<li><code>[^aieou]</code> : 자음 중 하나. 단 이렇게 찾으려면 파일/디렉토리 이름이 b, c, d, f, g, … 중 하나여야 한다. (즉 한 글자)</li>
</ul>
<hr>
<p><code>?</code> : 임의의 한 문자. character 하나의 placeholder라고 생각하면 편리하다.</p>
<ul>
<li><code>[githubblo?]</code> : <code>githubblog</code>가 있다면 일치한다.</li>
</ul>
<hr>
<p><code>*</code> : asterisk의 일반적인 의미처럼 아무거나. <u>empty를 포함한</u> 모든 string을 의미. 보통 조합할 때 필수적으로 사용된다.</p>
<ul>
<li><code>*[aioeu]</code> : 모음으로 끝나는 경우</li>
<li><code>*[aioeu]*</code> : 모음이 포함된 경우</li>
<li><code>[aioeu]*</code> : 모음으로 시작하는 경우</li>
</ul>
<hr>
<h3 id="2-중괄호-확장-단순히-가능한-모든-경우의-수를-입력으로-사용"><a href="#2-중괄호-확장-단순히-가능한-모든-경우의-수를-입력으로-사용" class="headerlink" title="2. 중괄호 확장: 단순히 가능한 모든 경우의 수를 입력으로 사용"></a><strong>2. 중괄호 확장: 단순히 가능한 모든 경우의 수를 입력으로 사용</strong></h3><p>문자열 중간에서 사용되며 가능한 모든 경우의 수로 치환된 후 입력으로 사용된다.</p>
<p><img src="/images/linux-shell/b1.png" alt="echo a{b,c,d}e{f,g,h} 결과"></p>
<p>(ex) <code>echo a&#123;b,c,d&#125;e&#123;f,g,h&#125;</code> == <code>echo abef abeg abeh acef aceg aceh adef adeg adeh</code></p>
<hr>
<h3 id="3-변수-String-타입의-환경-변수"><a href="#3-변수-String-타입의-환경-변수" class="headerlink" title="3. 변수: String 타입의 환경 변수"></a><strong>3. 변수: String 타입의 환경 변수</strong></h3><blockquote>
<p>bash 프로파일 관리에 대해선 좀 더 나중에 다루려고 한다.</p>
</blockquote>
<p>Windows의 환경 변수와 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/ko-kr/windows-server/administration/windows-commands/set_1">cmd 환경 변수</a>와 같은 2가지 변수가 있다. 모두 환경 변수이지만 그 범위가 다른데, <u>cmd 환경 변수에 대응</u>되는 Linux에서의 개념이 셸 변수이다. 단 아래의 방법으로 하면 해당 세션(셸)에서만 사용할 수 있으므로 일회성 변수로 생각하면 좋다.</p>
<p><strong>쓰기</strong> : <code>MYVAR=string_value</code></p>
<p><strong>읽기</strong> : <code>$MYVAR</code></p>
<p>만약 환경 변수로 저장하고 싶다면, <code>export MYVAR=string_value</code>와 같이 사용하면 된다. 환경 변수는 <code>printenv</code> 혹은 <code>env</code> 명령으로 확인할 수 있다.</p>
<hr>
<h4 id="기본으로-제공되는-환경-변수"><a href="#기본으로-제공되는-환경-변수" class="headerlink" title="기본으로 제공되는 환경 변수"></a><strong>기본으로 제공되는 환경 변수</strong></h4><p><code>PATH</code> : 바이너리 검색 경로의 목록. 콜론으로 구분.</p>
<p><code>PWD</code> :  현재 디렉토리 ( <code>OLDPWD</code> : 마지막으로 방문한 디렉토리 )</p>
<p><code>HOME</code> : 홈 디렉토리 ( ex : <code>/home/sb</code> )</p>
<p><code>USER</code> : 로그인명 ( <code>sb</code> )</p>
<hr>
<h3 id="4-alias"><a href="#4-alias" class="headerlink" title="4. alias"></a><strong>4. alias</strong></h3><p>단순한 String 치환이다.</p>
<p><strong>지정</strong> :  <code>alias ll = &quot;ls -lG&quot;</code>를 입력하면, 이후 셸에서 <code>ll</code>을 입력하면 <code>ls -lG</code>가 입력된다.</p>
<p><strong>목록 확인</strong> : <code>alias</code>만 입력하면 된다.</p>
<p><img src="/images/linux-shell/c1.png" alt="alias 입력 시의 결과"></p>
<hr>
<h3 id="5-입출력-redirection"><a href="#5-입출력-redirection" class="headerlink" title="5. 입출력 redirection"></a><strong>5. 입출력 redirection</strong></h3><blockquote>
<p>아직 입출력을 파일을 통해 수행해본 적이 없어서 추후 적절한 예시를 추가하려고 한다. 이번 글에서는 개념적으로 그 사용법만 다룬다.</p>
</blockquote>
<p>표준 입출력의 지점을 임의의 파일에 수행하게 한다.</p>
<p><strong>입력을 파일의 내용으로</strong> : <code>command &lt; input_file</code></p>
<ul>
<li>재미있게도 <code>echo &lt; sample.txt</code> 와 같이, <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/63658/redirecting-the-content-of-a-file-to-the-command-echo">echo 명령은 임의의 input 파일의 내용을 출력할 수 없는데</a>, 표준 입출력에서 내용을 읽지 않기 때문이다.</li>
</ul>
<p><strong>출력을 파일로</strong> : </p>
<ol>
<li><p>새로운 파일로 작성 :  <code>command &gt; output_file</code></p>
</li>
<li><p>기존 파일에 이어 쓰기 : <code>command &gt;&gt; output_file</code></p>
</li>
<li><p>오류의 경우 : <code>command 2&gt; error_file</code></p>
</li>
<li><p>출력, 오류 모두 : <code>command &gt;&amp; output_file</code> 혹은 <code>command &amp;&gt; output_file</code></p>
</li>
<li><p>출력, 오류 각각 : <code>command &gt; output_file 2&gt; error_file</code></p>
</li>
</ol>
<blockquote>
<p>리눅스에서 표준 스트림은 3가지이며 자세한 내용은 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%ED%91%9C%EC%A4%80_%EC%8A%A4%ED%8A%B8%EB%A6%BC">위키 백과 (표준 스트림)</a> 참고</p>
</blockquote>
<hr>
<h3 id="6-Pipe"><a href="#6-Pipe" class="headerlink" title="6. Pipe"></a><strong>6. Pipe</strong></h3><blockquote>
<ol>
<li>각 프로그램이 하나의 일을 잘 할 수 있게 만들 것. 새로운 일을 하려면, 새로운 기능들을 추가하기 위해 오래된 프로그램을 복잡하게 만들지 말고 새로 만들 것.</li>
<li>모든 프로그램 출력이 아직 잘 알려지지 않은 프로그램이라고 할지라도 다른 프로그램에 대한 입력이 될 수 있게 할 것. 무관한 정보로 출력을 채우지 말 것. 까다롭게 세로로 구분되거나 바이너리로 된 입력 형식은 피할 것. 대화식 입력을 고집하지 말 것.</li>
<li>소프트웨어를, 심지어는 운영 체제일지라도 이른 시기에 수주에 걸쳐 이상적으로 시도해가며 설계하고 만들 것. 어설픈 부분을 버리고 다시 만드는 것을 주저하지 말 것.</li>
<li>프로그래밍 작업을 가볍게 하기 위해, 심지어 우회하는 방법으로 도구를 만들고 바로 버릴지라도 어설픈 도움 보다는 도구 사용을 선호할 것.</li>
</ol>
<p>출처: <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%B2%A0%ED%95%99">위키 백과 (유닉스 철학)</a></p>
</blockquote>
<p>Pipe 연산자는 유닉스 철학을 구현하는 도구 중 하나로, 이 중 2번 규칙을 지키는 도구로 사용된다.</p>
<p>(ex) <code>who | sort | awk &#39;&#123;print $1&#125;&#39; | less</code></p>
<blockquote>
<p>pipe 연산자의 효과를 제대로 소개하는 예제를 만들기엔 아직 아는 명령어가 극히 적어서 추후 제대로 소개하고자 한다. 해당 소개 글이 작성될 경우 이 글에서 링크를 제공하도록 하겠다.</p>
</blockquote>
<hr>
<h3 id="7-평가식"><a href="#7-평가식" class="headerlink" title="7. 평가식"></a><strong>7. 평가식</strong></h3><p>평가식이란 그 내용이 코드로 해석되는 영역을 말한다. 셸에서의 평가식은 해당 평가식을 셸에서 따로 실행시켰을 때의 결과를 반환하는 형태를 갖는다. 이 평가식의 문법은 크게 두 가지가 있는데,</p>
<ol>
<li>backtick : <code>echo This year is ``date +%Y\`` </code><ul>
<li>This year is 2021</li>
</ul>
</li>
<li>$() : <code>echo Next year is $(expr $(date +%Y) + 1)</code><ul>
<li>Next year is 2022</li>
</ul>
</li>
</ol>
<p>평가식으로 (5)에서 실패했던 <code>echo &lt; sample.txt</code>를 평가식으로는 실행할 수 있다: <code>echo $(cat sample.txt)</code> (`을 사용해도 된다.)</p>
<hr>
<h3 id="8-작업-제어"><a href="#8-작업-제어" class="headerlink" title="8. 작업 제어"></a><strong>8. 작업 제어</strong></h3><p>셸에서 수행되는 프로그램은 대개 포그라운드로 실행된다. 즉 사용자와의 인터렉션이 블로킹되는데 셸에서 프로그램을 실행할 때 백그라운드로도 실행시킬 수 있다. 또한 포그라운드와 백그라운드를 넘나들 수 있으며 작업을 정지하고 다시 실행할 수도 있으며 셸 마저 정지할 수도 있다.</p>
<p><strong>백그라운드로 작업 실행</strong> : <code>command ... &amp;</code> (<code>&amp;</code>가 핵심이다.)</p>
<p><strong>포그라운드 작업 정지</strong> : <code>Ctrl + Z</code></p>
<p><strong>백그라운드에서 작업 재개</strong> : `bg {id}``</p>
<p><strong>포그라운드로 작업을 가져와 실행</strong> : <code>fg &#123;id&#125;</code></p>
<p><strong>현재 수행 중인 작업의 목록 조회</strong> : <code>jobs</code></p>
<p><strong>현재 셸 정지</strong> : <code>suspend</code> (현재 실행 중인 셸이 2개 이상이어야 호출 가능하다.)</p>
<hr>
<h3 id="9-여러-셸-동시-사용"><a href="#9-여러-셸-동시-사용" class="headerlink" title="9. 여러 셸 동시 사용"></a><strong>9. 여러 셸 동시 사용</strong></h3><p><code>screen</code>은 내장 기능이어서 dependency가 추가로 필요하지 않아 사용에 제약이 없지만 그 기능이 적고 불편하다. <code>tmux</code>가 많이 사용되며 기본으로 설치되는 경우도 있으나(WSL Ubuntu에는 기본으로 설치돼있다.) 둘 모두 사용해본 적이 없어 추후에 다루도록 한다.</p>
<hr>
<p><strong>TODO</strong> :</p>
<p>입출력 Redirection 적극적으로 활용해보기 (특히 알고리즘 테스트 케이스 수행 시)</p>
<p>screen/tmux 모두 사용해보고 비교하기</p>
<p>리눅스 명령어 더 공부하고, pipe로 효과적인 예 만들기</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-14T05:00:00.000Z" title="2021-03-14T05:00:00.000Z">21-03-14</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-14T04:58:49.669Z" title="2021-03-14T04:58:49.669Z">21-03-14</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">7분안에 읽기 (약 999 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-dir/">리눅스 주요 디렉토리의 이름과 의미 정리 (계속 업데이트 예정)</a></h1><div class="content"><p>이 글은 리눅스를 처음 시작하는 경우 다른 OS의 디렉토리 구성과의 큰 차이로 인한 불편함을 줄이기 위한 큰 지도이다.</p>
<hr>
<h3 id="1-Home-디렉토리"><a href="#1-Home-디렉토리" class="headerlink" title="1. Home 디렉토리"></a><strong>1. Home 디렉토리</strong></h3><p>크게 2가지 Home 디렉토리가 있다. 이는 사용자에 따라 구분되는데,</p>
<ul>
<li>일반 사용자: <code>/home/&#123;USER_NAME&#125;</code> </li>
<li>루트 사용자: <code>/root</code></li>
</ul>
<p>형태로 사용한다.</p>
<hr>
<h3 id="2-시스템-디렉토리"><a href="#2-시스템-디렉토리" class="headerlink" title="2. 시스템 디렉토리"></a><strong>2. 시스템 디렉토리</strong></h3><p>시스템 디렉토리란 사용자 디렉토리를 제외한 (거의) 모든 디렉토리를 말한다. 윈도우에서 <code>Program Files</code> 폴더가 시스템 디렉토리에 포함된다고 생각하면 이 정의에 동의할 수 있을 것이고, <code>Windows</code>, <code>AppData</code> 등의 폴더만 시스템 디렉토리라고 생각한다면 이 정의에 동의하긴 어려울 듯 하다.</p>
<hr>
<h4 id="일반적인-경로-구성"><a href="#일반적인-경로-구성" class="headerlink" title="일반적인 경로 구성"></a><strong>일반적인 경로 구성</strong></h4><p><img src="/images/linux-dir/sysdir.png" alt="시스템 디렉토리의 경로 구성"></p>
<hr>
<p>(ex) <code>/usr/local/share/emacs</code></p>
<ul>
<li><code>/usr/local</code> : 스코프</li>
<li><code>/share</code> : 카테고리</li>
<li><code>/emacs</code> : 응용 프로그램</li>
</ul>
<h4 id="경로-구성-요소-스코프"><a href="#경로-구성-요소-스코프" class="headerlink" title="경로 구성 요소 - 스코프"></a><strong>경로 구성 요소 - 스코프</strong></h4><p>스코프는 가장 상위 디렉토리로서 하위 디렉토리인 카테고리나 응용 프로그램이 실행되는 범위를 나타낸다. 다만 구분에 사용되는 명확한 기준은 없고 단지 <code>/</code>가 <code>/usr</code>보다 좀 더 운영 체제에 가까운 근본적인 수준이라는 느낌이라고 한다(출처: 리눅스 핵심 레퍼런스).</p>
<p><strong>스코프의 종류</strong>:</p>
<ol>
<li><p><code>/</code> : 리눅스 시스템 파일</p>
</li>
<li><p><code>/usr</code> : <em>또 다른</em> 리눅스 시스템 파일</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/308045/differences-between-bin-sbin-usr-bin-usr-sbin-usr-local-bin-usr-local">Differences between /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin</a> 참고</li>
</ul>
</li>
<li><p><code>/usr/local</code> : 개인 컴퓨터에서 지역적으로 생성되는 시스템 파일</p>
<p>(ex) <code>/usr/local/bin</code> : 기본 프로그램이 아닌 경우 주로 여기에 설치된다.</p>
</li>
</ol>
<hr>
<h4 id="경로-구성-요소-카테고리"><a href="#경로-구성-요소-카테고리" class="headerlink" title="경로 구성 요소 - 카테고리"></a><strong>경로 구성 요소 - 카테고리</strong></h4><p>카테고리는 하위 디렉토리인 응용 프로그램의 목적을 나타낸다.</p>
<ol>
<li><p>실행 파일:   </p>
<ul>
<li><code>bin</code> : 바이너리</li>
<li><code>sbin</code> : 바이너리 (root 사용자 용이어서 root 권한이 필요하다.)</li>
<li><code>lib</code> : 바이너리에서 사용되는 라이브러리</li>
<li>Ubuntu 20.04의 경우 <code>/</code> 스코프의 <code>bin, sbin, lib</code>이 <code>/usr</code> 스코프로의 심볼릭 링크로 돼 있음 (어떤 배포판들이 또 이렇게 돼있는지는 확인 x)</li>
<li><img src="/images/linux-dir/link.png"></li>
</ul>
</li>
<li><p>설정 파일:</p>
<ul>
<li><code>etc</code> : 시스템 설정 파일</li>
<li><code>init.d</code>, <code>rc.d</code> : 부팅 설정 파일</li>
</ul>
</li>
<li><p>문서: <code>doc</code>, <code>info</code>, <code>man</code>, <code>share</code></p>
</li>
<li><p>HW 관련:</p>
<ul>
<li><code>dev</code> : Linux에서는 장치를 파일로 표현한다.</li>
<li><code>media</code>, <code>mnt</code> : Disk 마운트 지점<ul>
<li>리눅스는 디렉토리 트리가 하나여야 하므로 mount를 통해 트리를 병합해야 함</li>
<li><a target="_blank" rel="noopener" href="https://blog.naver.com/PostView.nhn?blogId=lunarispars&logNo=221462605068">[ 리눅스 마스터 ] 리눅스 디스크관리 - 마운트 (+실습, 명령어정리 )</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Runtime:</p>
<ul>
<li><code>var</code> : 클라이언트마다 다른 파일을 저장<ul>
<li><a target="_blank" rel="noopener" href="https://jadehan.tistory.com/11">Linux 기본 - /var 디렉토리의 이해</a></li>
</ul>
</li>
<li><code>run</code> : 실행 중인 프로세스의 ID를 담고 있는 PID 파일</li>
</ul>
</li>
<li><p>운영체제 관련:</p>
<ul>
<li><code>boot</code> ( <code>/boot/vmlinuz</code> ): 커널, 부팅 관련 파일</li>
<li><code>lost+found</code> : 손상된 파일 등 추후 복구를 위한 임시 저장 경로<ul>
<li><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/18154/what-is-the-purpose-of-the-lostfound-folder-in-linux-and-unix">What is the purpose of the lost+found folder in Linux and Unix?</a></li>
</ul>
</li>
<li><code>proc</code> : 현재 실행 중인 프로세스 정보. 저용량이며 실시간으로 반영한다.<ul>
<li><code>cat /proc/ioports</code> : I/O HW 목록 표시</li>
<li><code>cat /proc/cpuinfo</code> : 프로세서 정보. 코어 단위로 상세 정보를 출력</li>
<li><code>cat /proc/version</code> : OS 버전 정보 표시 (ex: <code>Linux version 4.19.128-microsoft-standard</code>)</li>
<li><code>cat /proc/uptime</code> : ms 단위로 uptime 출력. (<code>uptime</code> 명령어가 더 낫다)</li>
<li><code>ll /proc/&#123;PID&#125;</code> : PID에 대응되는 프로세스의 정보. (많은데 잘 모르겠다)</li>
<li><code>ll /proc/self</code> : 현재 실행중인 프로세스로의 심볼릭 링크 (ex) 1261</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p>이 글은 꾸준히 계속 업데이트될 예정입니다!</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-11T14:55:00.000Z">21-04-11</time></p><p class="title"><a href="/linux-user-and-sudo/">Linux와 Docker의 기술적 관계 (1/3)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-04T12:35:00.000Z">21-04-04</time></p><p class="title"><a href="/linux-namespaces-1/">리눅스에서의 sudo와 권한 관리 (1)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-28T14:58:00.000Z">21-03-28</time></p><p class="title"><a href="/linux-how-to-find-files/">리눅스에서 파일을 찾는 방법</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-26T08:00:00.000Z">21-03-26</time></p><p class="title"><a href="/ndp-5-stream-5/">Stream 생태계 정리</a></p><p class="categories"><a href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-25T06:00:00.000Z">21-03-25</time></p><p class="title"><a href="/ndp-5-stream-4/">5장 Stream API 디자인 패턴 - Pipe, Fork, Merge, Mux/Demux</a></p><p class="categories"><a href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"a5b0a2c99ffc3e96272db5353f20f4e3","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>카테고리: Linux - JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">카테고리</a></li><li class="is-active"><a href="#" aria-current="page">Linux</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-10T14:43:00.000Z" title="2021-10-10T14:43:00.000Z">21-10-10</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-10-10T14:42:14.470Z" title="2021-10-10T14:42:14.470Z">21-10-10</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">6분안에 읽기 (약 904 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-ipc-unix-domain-socket/">리눅스에서의 IPC Socket vs Network Socket</a></h1><div class="content"><blockquote>
<p>Unix Domain Socket은 리눅스 상에서 동작하는 클라이언트-서버 프로세스로 나뉜 소프트웨어에서 자주 사용된다. 예를 들어, Docker에서는 기본 설정으로 TCP Socket이 아닌 Unix Domain Socket으로 dockerd와 docker가 통신한다. 이 경우 외부에서 접속할 수 없다. </p>
<p>비슷하게 MySQL client도 host=”localhost”인 경우 Unix Socket을 사용한다.</p>
</blockquote>
<p>이 글은 Unix Domain Socket이란 무엇이고, 그 사용 예와 특징에 대해 서술한다.</p>
<hr>
<h3 id="1-Socket의-종류"><a href="#1-Socket의-종류" class="headerlink" title="1. Socket의 종류"></a><strong>1. Socket의 종류</strong></h3><p>POSIX(리눅스/유닉스)에는 소켓이 2 종류가 존재한다.</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix_domain_socket">IPC Socket</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_socket">Network Socket</a></li>
</ol>
<p>여기서 Network Socket은 IP Socket, 즉 TCP, UDP 통신에 쓰이는 소켓이며, IPC Socket은 오늘의 주제인 Unix Domain Socket을 의미한다.</p>
<hr>
<h3 id="2-Unix-Domain-Socket"><a href="#2-Unix-Domain-Socket" class="headerlink" title="2. Unix Domain Socket"></a><strong>2. Unix Domain Socket</strong></h3><p>[<a target="_blank" rel="noopener" href="https://serverfault.com/questions/124517/what-is-the-difference-between-unix-sockets-and-tcp-ip-sockets">StackOverFlow</a>]<br>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix_domain_socket">Wikipedia</a>]</p>
<p>Unix Domain Socket, 줄여서 UDS는 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B0%84_%ED%86%B5%EC%8B%A0">IPC</a>의 종류 중 하나로, TCP, UDP에 대응되는 API (<code>SOCK_STREAM</code>, <code>SOCK_DGRAM</code>)가 있기 때문에 소켓의 file descriptor를 할당 받는 구문만 변경하면 네트워크 소켓을 썼을 때와 같은 코드를 사용할 수 있게 된다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// sockaddr 대신 socketaddr_un 구조체 사용</span></span><br><span class="line"><span class="comment">// 이 구조체는 내부 필드 sun_path에 UDS의 경로를 입력받는다. (포트 대신에!)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 네트워크 소켓이라면 AF_INET을, UDS 라면 AF_UNIX 를 사용한다.</span></span><br><span class="line"><span class="keyword">if</span> ((client_sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자세한 UDS 코드에 대해선 간결한 설명은 <a target="_blank" rel="noopener" href="https://yaaam.tistory.com/entry/LinuxUDSUnix-Domain-Socket-UDS">이 블로그</a>를 참고하고, 자세한 설명은 <a target="_blank" rel="noopener" href="http://www.dreamy.pe.kr/zbxe/CodeClip/119393">이 블로그</a>를 참고하면 좋을 것 같다.</p>
<hr>
<p>UDS를 사용할 경우 하부의 네트워크 프로토콜을 거치지 않고 OS 커널만을 통해서 통신이 이루어진다. 따라서 UDP를 사용한 코드더라도 UDS를 쓴다면 항상 순서가 보장되는 등 네트워크의 불확실성이 모두 제거된다. </p>
<p>참고로 IPC의 경우 UDS보다 더 빠른 방법들이 많다 - 가장 빠른 것은 shared memory 방법이라고 한다 [<a target="_blank" rel="noopener" href="https://blog.daum.net/tlos6733/159">IPC 성능 측정에 대한 글</a>]. 해당 링크를 따라가면 알겠지만 IPC 방법 중에는 메모리 복사를 줄일 수 있는 방법이 많은 데 비해 UDS가 가장 많은 메모리 복사를 하는 것을 알 수 있다.</p>
<hr>
<h3 id="UDS는-리눅스의-파일-권한을-따르므로-통신에-대한-권한을-제어할-수-있다"><a href="#UDS는-리눅스의-파일-권한을-따르므로-통신에-대한-권한을-제어할-수-있다" class="headerlink" title="UDS는 리눅스의 파일 권한을 따르므로, 통신에 대한 권한을 제어할 수 있다."></a><strong>UDS는 리눅스의 파일 권한을 따르므로, 통신에 대한 권한을 제어할 수 있다.</strong></h3><p>Linux는 소켓도 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix_file_types">파일로 관리</a>하는데, UDS는 파일 속성의 첫 글자가 <code>srwxrwxrwx</code>와 같이 <code>s</code>이다. Network 소켓도 소켓이기 때문에 파일이긴 하지만, UDS는 파일 이름이 있고, <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/a/116568">Network Socket은 파일 이름이 없어서(unnamed)</a> 포트로 접근해야 한다. UDS 소켓 코드를 보면, UDS 소켓의 경로를 알고, 해당 파일에 대한 권한이 있으면 해당 소켓으로 통신을 수행할 수 있다. 따라서 해당 소켓 파일에 대한 접근 권한을 통해 통신 권한도 조절할 수 있다!</p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><ol>
<li><p>Socket 프로그래밍 해보고 실제 코드 차이에 대해 더 뜯어보기</p>
</li>
<li><p>loopback IP에서의 overhead 비교해보기</p>
</li>
<li><p>다른 IPC 메커니즘과 성능 비교해보기</p>
</li>
</ol>
<hr>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-03T14:50:00.000Z" title="2021-10-03T14:50:00.000Z">21-10-03</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-10-03T14:48:23.890Z" title="2021-10-03T14:48:23.890Z">21-10-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">5분안에 읽기 (약 762 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-install-zsh/">ZSH를 WSL2에 설치하는 방법</a></h1><div class="content"><p>이 글은 WSL2 환경에서 zsh 및 주요 플러그인을 설치하는 것을 다룬다.</p>
<p>zsh는 주로 맥을 쓰는 개발자들은 항상 쓰는 그 셸이라고 생각하면 된다.</p>
<blockquote>
<p>기준 환경: WSL 2 (Windows 10 2004)</p>
</blockquote>
<hr>
<h3 id="1-zsh-oh-my-zsh-설치"><a href="#1-zsh-oh-my-zsh-설치" class="headerlink" title="1. zsh, oh-my-zsh 설치"></a><strong>1. zsh, oh-my-zsh 설치</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># oh-my-zsh 설치</span></span><br><span class="line">$ sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>참고로 <a target="_blank" rel="noopener" href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>는 zsh 설정을 관리하는 도구로, 주로 플러그인 설치 시 매우 깔끔히 되게 해준다.</p>
<p><img src="/images/zsh/ohmyzsh1.png"></p>
<hr>
<h3 id="2-zsh-테마-설정-agnoster"><a href="#2-zsh-테마-설정-agnoster" class="headerlink" title="2. zsh 테마 설정: agnoster"></a><strong>2. zsh 테마 설정: agnoster</strong></h3><p>그냥 zsh는 별로이다. <code>agnoster</code> 테마가 바로 그 ‘익숙한 테마’이므로, 해당 테마를 사용하도록 설정한다. 해당 테마는 특수한 폰트를 사용하므로 설치해준다.</p>
<p>설치를 위해 Powershell을 관리자 권한으로 실행한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Powershell</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/powerline/fonts.git</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> fonts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 자동으로 폰트 묶음을 설치한다.</span></span><br><span class="line">$ .\install.ps1 <span class="comment"># 윈도우여서, / 가 아니고, \이다.</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/zsh/ohmyzsh3.png"></p>
<p>일단 zsh를 사용하기로 한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>폰트 설치 전 셸은 아래와 같이 폰트가 깨짐을 확인할 수 있다.</p>
<p><img src="/images/zsh/ohmyzsh4.png"></p>
<p>폰트 설치 및 터미널에서 폰트 설정을 진행하면</p>
<p><img src="/images/zsh/ohmyzsh5.png"></p>
<p>아래와 같이 폰트 깨짐이 제거된다.</p>
<p><img src="/images/zsh/ohmyzsh6.png"></p>
<hr>
<h3 id="3-zshrc에-bashrc-설정-옮겨타기"><a href="#3-zshrc에-bashrc-설정-옮겨타기" class="headerlink" title="3. zshrc에 bashrc 설정 옮겨타기"></a><strong>3. zshrc에 bashrc 설정 옮겨타기</strong></h3><p>zsh를 사용한 순간 bash에서 제공하는 명령 및 <code>bashrc</code> 파일의 내용이 적용되지 못한다. 따라서 수동으로 복붙해준다.</p>
<blockquote>
<p>zsh 적용 후 source ~/.bashrc를 호출해봤더니 셸이 아예 깨져버렸다.</p>
</blockquote>
<p><img src="/images/zsh/ohmyzsh7.png"></p>
<hr>
<h3 id="4-zsh-주요-플러그인-2개-설치하기"><a href="#4-zsh-주요-플러그인-2개-설치하기" class="headerlink" title="4. zsh 주요 플러그인 2개 설치하기"></a><strong>4. zsh 주요 플러그인 2개 설치하기</strong></h3><p>zsh에서 유명한 플러그인들이 있다. 이러한 플러그인 설치 과정에서 oh-my-zsh의 편리함을 느낄 수 있다. 우리가 설치할 플러그인은 아래 2개이다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/zsh-users/zsh-autosuggestions">autosuggestions</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zsh-users/zsh-syntax-highlighting">syntax highlighting</a></li>
</ul>
<hr>
<h5 id="4-1-autosuggestions부터-설치한다"><a href="#4-1-autosuggestions부터-설치한다" class="headerlink" title="4-1. autosuggestions부터 설치한다."></a><strong>4-1. autosuggestions부터 설치한다.</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line">$ nano ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 아래와 같이 수정해준다. (기본값으론 목록에 git만 있을 것이다.)</span></span><br><span class="line">plugins=( </span><br><span class="line">    <span class="comment"># other plugins...</span></span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>설치된 모습을 확인하면</p>
<p><img src="/images/zsh/ohmyzsh8.png"></p>
<p>위와 같이 자동 완성이 기능한다. 오른쪽 방향키를 누르면 끝까지 완성된다.</p>
<hr>
<h5 id="4-2-syntax-highlighting도-설치한다"><a href="#4-2-syntax-highlighting도-설치한다" class="headerlink" title="4-2. syntax highlighting도 설치한다."></a><strong>4-2. syntax highlighting도 설치한다.</strong></h5><p>아래 명령어로 설치한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">$ nano ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 아래와 같이 수정해준다. (기본값으론 목록에 git만 있을 것이다.)</span></span><br><span class="line">plugins=( </span><br><span class="line">    <span class="comment"># other plugins...</span></span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> 아래의 <code>fin</code>과 <code>find</code> 예제의 차이를 확인할 수 있다. <code>fin</code>만 입력한 경우 찾을 수 없는 명령이어서 미리 실패함을 확인할 수 있고, <code>find</code>의 경우 유효한 명령이어서 사용자가 명령이 성공할 것을 예상할 수 있다.</p>
<p><img src="/images/zsh/ohmyzsh9.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-26T14:50:00.000Z" title="2021-09-26T14:50:00.000Z">21-09-26</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-09-26T14:55:35.020Z" title="2021-09-26T14:55:35.020Z">21-09-26</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">5분안에 읽기 (약 688 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-shell-2-screen/">screen: 리눅스에서 셸을 유지하면서 나갔다 들어오는 방법</a></h1><div class="content"><p>이번 글은 Linux 내장 유틸리티인 screen에 대해 소개한다. screen은 셸을 나가도 history가 유지해주는 프로그램이다. tmux와 비교되는 경우도 있는데 화면 분할 및 창 이동이 screen의 주요 기능 중 하나지만 그것만 있다면 대부분 tmux를 사용할 것이다. </p>
<p>아직 screen의 작동 원리는 잘 모르겠지만, 비유적으로 설명하자면 tmux는 셸 단위로 실행되는 것에 비해 screen은 셸 밖에서 실행된다고 볼 수 있다. 따라서 셸을 종료하더라도 screen으로 실행한 셸은 계속 살아있으며, 다른 셸에서 해당 screen 세션으로 접속하면 애초에 접속을 끊지 않은 것 같은 UX를 경험할 수 있는 것이다.</p>
<blockquote>
<p>기준 환경:</p>
<p>WSL v2</p>
</blockquote>
<hr>
<h3 id="1-설치-및-명령어-소개"><a href="#1-설치-및-명령어-소개" class="headerlink" title="1. 설치 및 명령어 소개"></a><strong>1. 설치 및 명령어 소개</strong></h3><p>screen은 Debian 계열에서 기본 설치돼있으므로 설치 방법은 생략한다. (<code>apt-get install screen</code>)</p>
<p>screen은 sudo 권한이 필요하다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># screen 세션의 목록을 표시한다.</span></span><br><span class="line">$ sudo screen -list</span><br><span class="line"></span><br><span class="line"><span class="comment"># screen 세션의 도움말을 표시한다.</span></span><br><span class="line">$ sudo screen -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># screen 세션을 하나 시작한다.</span></span><br><span class="line">$ sudo screen</span><br><span class="line"></span><br><span class="line"><span class="comment"># screen 세션에서 빠져나온다.</span></span><br><span class="line">$ ctrl+a+d</span><br><span class="line"></span><br><span class="line"><span class="comment"># screen 세션에 다시 접속한다.</span></span><br><span class="line"><span class="comment"># 이름을 짓지 않았던 경우 -list 옵션으로 조회한 후 해당 이름을 넘긴다.</span></span><br><span class="line"><span class="comment"># 이름이 보통 긴데, 도커 파일처럼 unique한 길이까지만 앞 글자만 입력해도 되는 듯하다.</span></span><br><span class="line"><span class="comment"># 정확한 name 쿼리 방식은 잘 모르겠다. `3225.test`인데, 3225도 동작하고 test도 동작한다...</span></span><br><span class="line">$ screen -r &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># screen 세션을 이름을 제공해 하나 시작한다.</span></span><br><span class="line"><span class="comment"># 이 경우 조금 더 접속이 쉬울 것이다.</span></span><br><span class="line">$ sudo screen -s &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># screen 세션을 제거한다.</span></span><br><span class="line">$ screen -X -S &lt;sessionId&gt; quit</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-예제"><a href="#2-예제" class="headerlink" title="2. 예제"></a><strong>2. 예제</strong></h4><p><code>sudo screen -list</code> 명령으로 현재 열려 있는 screen 세션을 확인한다.</p>
<p><img src="/images/linux-shell-2-screen/screen-list.jpg"></p>
<p>현재 <code>3806</code>과 <code>317</code> 세션이 열려있는 것을 확인할 수 있다. (<code>3806</code>의 경우 이 예제에서 사용하지 않는다.)</p>
<hr>
<p><code>sudo screen -r 317</code> 명령으로 <code>317</code> 세션으로 접속하고 임의의 명령들을 실행했다.</p>
<p><img src="/images/linux-shell-2-screen/screen-1.jpg"></p>
<hr>
<p>이후 <code>ctrl+a+d</code>를 입력해 현재 screen 세션에서 원래 셸로 돌아왔다.</p>
<p><img src="/images/linux-shell-2-screen/screen-2.jpg"></p>
<hr>
<p>아예 다른 셸에서 <code>sudo screen -r 317</code>로 재접속하였다. 성공적으로 재접속되었고 마치 셸을 닫지 않은 것처럼 그대로 작업이 수행되고 그 기록까지 곧장 확인할 수 있다.</p>
<p><img src="/images/linux-shell-2-screen/screen-3.png"></p>
<hr>
<p><code>ctrl+a+d</code>로 세션에서 나온 후 <code>sudo screen -X -S 317 quit</code> 명령으로 <code>317</code> 세션을 종료했다.</p>
<p><img src="/images/linux-shell-2-screen/screen-4.png"></p>
<hr>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-19T14:30:00.000Z" title="2021-09-19T14:30:00.000Z">21-09-19</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-09-19T14:29:20.677Z" title="2021-09-19T14:29:20.677Z">21-09-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">5분안에 읽기 (약 763 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-profile-not-loaded/">왜 .profile 파일이 적용되지 않을까</a></h1><div class="content"><p>이 글은 <code>~/.profile</code> 파일이 왜 로드되지 않는지 설명한다.</p>
<hr>
<p>나는 컨테이너를 활용할 땐 항상 WSL2를 사용한다. 이 때 재밌는 이슈가 있다. </p>
<p>자주 사용하는 퍼블릭 클라우드의 SSH 머신의 IP를 <code>~/.profile</code> 파일에 <code>export A=B</code> 와 같이 등록해두고 사용하는 등 여러 상수들을 환경 변수로 등록하고 사용했는데, WSL2를 새 터미널로 열면 해당 환경변수가 로딩되지 않았다. 그래서 항상 <code>source ~/.profile</code>을 실행했었는데, 이 글에선 이 이유를 알아보고 그 해결법까지 소개한다.</p>
<hr>
<h4 id="bash-profile-bash-login-profile-파일"><a href="#bash-profile-bash-login-profile-파일" class="headerlink" title="bash_profile, bash_login, profile 파일"></a><strong>bash_profile, bash_login, profile 파일</strong></h4><p>[<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11498070/bash-profile-not-loading">StackOverFlow</a>]</p>
<p>문제는 생각보다 비직관적이고 간단했는데 <code>~/.bash_profile</code> 혹은 <code>~/.bash_login</code> 파일이 존재하면, <code>~/.profile</code> 파일은 로드되지 않는다고 한다.</p>
<p>나의 경우 bash와 관련된 파일은 <code>.bash_profile</code>, <code>.bashrc</code>가 있었고 추가적으로 <code>.bash_logout</code>, <code>.bash_history</code> 파일이 존재했다.</p>
<p>재밌게도 <code>~/.bash_profile</code> 파일의 마지막 라인은 <code>source ~/.bashrc</code> 이다. 기본적으로 로딩되는 파일이 아니기 때문이다. (사실 애초에 둘의 차이도 잘 모르겠다.)</p>
<hr>
<h4 id="Login-Shell인지-아는-방법"><a href="#Login-Shell인지-아는-방법" class="headerlink" title="Login Shell인지 아는 방법?"></a><strong>Login Shell인지 아는 방법?</strong></h4><p>[<a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/26676/how-to-check-if-a-shell-is-login-interactive-batch">StackOverFlow</a>]</p>
<p>참고로 WSL2는 직접 로그인하는 과정이 생략되지만 Login Shell이다.</p>
<p><code>shopt -q login_shell &amp;&amp; echo &#39;Login shell&#39; || echo &#39;Not login shell&#39;</code>를 실행해보면 알 수 있다.</p>
<hr>
<h4 id="Login-Shell의-설정-파일-읽기-루틴"><a href="#Login-Shell의-설정-파일-읽기-루틴" class="headerlink" title="Login Shell의 설정 파일 읽기 루틴"></a><strong>Login Shell의 설정 파일 읽기 루틴</strong></h4><blockquote>
<p>Bash Startup Files</p>
<p>When a “login shell” starts up, it reads the file /etc/profile and then ~/.bash_profile or ~/.bash_login or ~/.profile (whichever one exists - it only reads ONE of these, checking for them in the order mentioned).</p>
<p>When a “non-login shell” starts up, it reads the file /etc/bashrc and then the file ~/.bashrc.</p>
<p>Note that when bash is invoked with the name sh, it tries to mimic the startup sequence of the Bourne shell (sh). In particular, a non-login shell invoked as sh does not read any dot files by default. See the bash man page for details.</p>
</blockquote>
<p>충격적이게도, 가장 기본 옵션인 <code>~/.profile</code>이 무시될 수도 있었다. (대신 모든 사용자를 대상으로 하는 <code>/etc/profile</code> 파일은 무시되지 않고 항상 가장 처음으로 로딩된다.)</p>
<p>현재 Bash가 나의 로그인 셸이고 해당 셸의 설정파일인 <code>~/.bash_profile</code>이 존재하기 때문에 해당 파일을 로딩한다는 것이다. (<code>~/.bash_profile</code> &gt; <code>~/.bash_login</code>, <code>~/.profile</code> 순으로 찾으며, 하나라도 찾으면 해당 파일만 로딩된다고 한다.)</p>
<hr>
<h4 id="솔루션"><a href="#솔루션" class="headerlink" title="솔루션"></a><strong>솔루션</strong></h4><p>솔루션은 크게 두 가지가 있다.</p>
<p>아래 솔루션은 bash를 사용하는 경우로 한정되지만 애초에 bash를 사용하지 않았다면 <code>.profile</code>이 로딩됐을 것이므로 조건에서 생략한다.</p>
<ol>
<li><p><code>bash_profile</code> 혹은 <code>bashrc</code> 파일만 사용하기</p>
</li>
<li><p><code>bash_profile</code>에 아래 내용 추가하기</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load user profile file</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.profile ]; <span class="keyword">then</span></span><br><span class="line">  . ~/.profile</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h4 id="추가-참고자료"><a href="#추가-참고자료" class="headerlink" title="추가 참고자료"></a><strong>추가 참고자료</strong></h4><p>[<a target="_blank" rel="noopener" href="https://apple.stackexchange.com/questions/12993/why-doesnt-bashrc-run-automatically">StackOverFlow</a>]</p>
<p>[<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/161249/bashrc-not-executed-when-opening-new-terminal">StackOverFlow</a>]</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-12T13:33:00.000Z" title="2021-09-12T13:33:00.000Z">21-09-12</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-09-12T13:32:26.160Z" title="2021-09-12T13:32:26.160Z">21-09-12</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">9분안에 읽기 (약 1395 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-debian-dpkg-apt/">데비안 리눅스 패키지 매니저 dpkg와 apt</a></h1><div class="content"><p>이 글은 리눅스의 패키지 매니저와 그 사용 방법을 설명한다.</p>
<hr>
<p>얘기하기 전에 리눅스 배포판 얘기가 나오면 항상 그 종류가 너무 많아서 이번에 정리를 하려고 한다.</p>
<h4 id="두-가지-주요-리눅스-배포판-Debian-Redhat"><a href="#두-가지-주요-리눅스-배포판-Debian-Redhat" class="headerlink" title="두 가지 주요 리눅스 배포판 - Debian, Redhat"></a><strong>두 가지 주요 리눅스 배포판 - Debian, Redhat</strong></h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_Linux_distributions">모든 리눅스 배포판의 목록</a>은 여기서 얻을 수 있다.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_Linux_distributions#/media/File:Linux_Distribution_Timeline_27_02_21.svg">리눅스 배포판 간의 부모-자식 트리</a>를 보면, <strong>개수 기준으로(점유율 X)</strong> 대충 눈대중으로 계산했을 때</p>
<ul>
<li>Redhat 1/4<ul>
<li>Redhat은 아래의 배포판들을 제작한다. <ul>
<li>RHEL(GPL 기반 enterprise. 안정성 중점)</li>
<li>CentOS(GPL + RHEL의 상표 제거 버전 - 커뮤니티 드리븐인데 레드헷에서 인수했다), </li>
<li>Fedora(RHEL의 upstream 버전. 신규 기능 출시 중점)</li>
</ul>
</li>
</ul>
</li>
<li>Slackware 1/10</li>
<li>기타 전체 1/4</li>
</ul>
<p>정도이므로, 나머지 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Debian">Debian</a> 기반의 리눅스 배포판의 개수는 전체 배포판 중 40%를 차지한다.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OpenSUSE">OpenSUSE</a>도 여러 글에서 빠지지 않고 Wikipedia에서도 well-known으로 소개되는데, 기반 배포판이 없고, 파생 배포판도 유명한 게 없다.</p>
</li>
</ul>
<hr>
<p>점유율도 궁금해져서 찾아봤는데, </p>
<ul>
<li>Ubuntu 34%</li>
<li>Debian 15% (Ubuntu가 아닌 Debian 및 자식 배포판인 듯하다)</li>
<li>CentOS 10%</li>
<li>Redhat 1% (RHEL)</li>
<li>알 수 없음 39%</li>
</ul>
<p>[<a target="_blank" rel="noopener" href="https://w3techs.com/technologies/details/os-linux">출처</a>]</p>
<p>으로 Ubuntu가 강세였다. 다만 크고 보수적인 기업일수록 CentOS 혹은 RHEL을 쓰는 게 타당할 듯하다. Ubuntu가 좋지 못하다는 게 아니라, 아무래도 상용 OS 이니까 더 나은 면이 있을 수 밖에 없다고 생각한다.</p>
<hr>
<h4 id="Debian-Ubuntu의-패키지-매니저-dpkg-apt"><a href="#Debian-Ubuntu의-패키지-매니저-dpkg-apt" class="headerlink" title="Debian, Ubuntu의 패키지 매니저 dpkg, apt"></a><strong>Debian, Ubuntu의 패키지 매니저 dpkg, apt</strong></h4><h5 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a><strong>dpkg</strong></h5><p>일단 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dpkg">dpkg</a>는 데비안 배포판에 포함된 패키지 매니저로, 우분투 등의 데비안 기반 배포판에 모두 포함돼있다. dpkg는 설치, 제거, 설치된 패키지 조회가 가능하지만 기능 면에서 부족하다. dpkg는 설치 파일로 <code>.deb</code> 확장자를 쓰며 사용자들이 직접 dpkg로 패키지를 관리하지는 않는다.</p>
<p>Ubuntu가 아닌 Debian도 apt를 사용한다. 즉 apt 역시 모든 데비안 배포판에 포함된 패키지 매니저이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 패키지 설치</span></span><br><span class="line">$ dpkg -i &lt;packageFile&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 설치된 패키지 조회</span></span><br><span class="line">$ dpkg -l [options...]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 패키지 제거</span></span><br><span class="line">$ dpkg -r &lt;packageName&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="apt"><a href="#apt" class="headerlink" title="apt"></a><strong>apt</strong></h5><p><a target="_blank" rel="noopener" href="https://salsa.debian.org/apt-team/apt">apt</a>는 사용자들이 사용하는 패키지 매니저이며, dpkg를 감싼 것으로 더 많은 기능을 제공한다.</p>
<p>apt는 프론트엔드라고 불리는데, apt의 주요 기능은 다음과 같다:</p>
<ul>
<li>Search for new packages.</li>
<li>Upgrade packages.</li>
<li>Install or remove packages (dpkg와 동일).</li>
<li>Upgrade the whole system to a new release (= OS 버전 업그레이드).</li>
</ul>
<hr>
<p>apt로 묶이는 도구들은 다음과 같다:</p>
<ul>
<li><strong>apt-get</strong> for retrieval of packages and information about them from authenticated sources and for installation, upgrade and removal of packages together with their dependencies</li>
<li><strong>apt-cache</strong> for querying available information about installed as well as available packages</li>
<li><strong>apt-cdrom</strong> to use removable media as a source for packages</li>
<li><strong>apt-config</strong> as an interface to the configuration settings</li>
<li><strong>apt-key</strong> as an interface to manage authentication keys</li>
<li><strong>apt-extracttemplates</strong> to be used by debconf to prompt for configuration questions before installation</li>
<li><strong>apt-ftparchive</strong> creates Packages and other index files needed to publish an archive of deb packages</li>
<li><strong>apt-sortpkgs</strong> is a Packages/Sources file normalizer</li>
<li><strong>apt</strong> is a high-level command-line interface for better interactive usage</li>
</ul>
<p>여기서 apt만 사용할 줄 알면 충분하다.</p>
<hr>
<p>우리가 흔하게 사용하는 apt 명령어를 돌아보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 쉽고 직관적인 명령어</span></span><br><span class="line">$ apt install &lt;packageName&gt;</span><br><span class="line"></span><br><span class="line">$ apt remove &lt;packageName&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>이 중 평소 따라치라고 해서 따라쳤지만 정확히 무슨 의미인지 몰랐던 명령어들을 정리한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 패키지 목록을 갱신한다. </span></span><br><span class="line"><span class="comment"># /var/lib/apt/lists 밑에, 레포지토리 이름에 대응되는 파일에 각 패키지와 메타데이터가 저장된다.</span></span><br><span class="line"><span class="comment"># 레포지토리 목록은 /etc/apt/sources.list 파일에 저장된다.</span></span><br><span class="line">$ apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 가능한 최신 버전으로 업그레이드 가능한 모든 패키지를 업그레이드한다.</span></span><br><span class="line"><span class="comment"># upgrade 명령이 새 버전의 새 의존성에 포함된 패키지를 설치할 순 있어도, 더 이상 필요 없는 기존 패키지를 제거하는 일은 없다.</span></span><br><span class="line">$ apt upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># upgrade + 현재 버전의 패키지가 삭제돼야 하는 경우 삭제를 수행한다.</span></span><br><span class="line">$ apt full-upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># apt full-upgrade와 문서화가 유사하게 돼있다. (정확히 무슨 기능인지는 잘 모르겠다.)</span></span><br><span class="line">$ apt-get dist-upgrade</span><br></pre></td></tr></table></figure>
<p>어떤 패키지의 최신 버전을 설치하려면 설치 전에 <code>apt update</code>를 하는 것은 중요하다.</p>
<p>다만 <code>apt upgrade</code> 등의 작업은 모든 패키지 대상이므로 대개 예상치 못한 결과를 가져올 수 있을 듯하다.</p>
<hr>
<p>아래는 기타 apt 명령어를 정리한 것이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># purge는 remove와 다르게, &#x27;설정&#x27; 파일도 제거한다.</span></span><br><span class="line">$ apt purge &lt;packageName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 미사용 패키지를 추려 모두 제거한다. </span></span><br><span class="line"><span class="comment"># 어떤 패키지가 삭제될지 미리보기는 없는 듯하다.</span></span><br><span class="line"><span class="comment"># 그냥 해봤는데 아무 패키지도 제거되지 않았다.</span></span><br><span class="line">$ apt autoremove</span><br><span class="line"></span><br><span class="line"><span class="comment"># 패키지 키워드 검색</span></span><br><span class="line"><span class="comment"># 별로 쓸모는 없는 듯하다.</span></span><br><span class="line">$ apt search &lt;keyword&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 설치된 패키지 조회</span></span><br><span class="line"><span class="comment"># 매우 길기 때문에 grep 등으로 조회하는 게 좋겠다.</span></span><br><span class="line">$ apt list [--upgradable] <span class="comment"># upgradable 옵션 사용 시 업그레이드 가능한 패키지 및 업그레이드 버전을 표시한다.</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-29T14:59:00.000Z" title="2021-08-29T14:59:00.000Z">21-08-29</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-28T06:48:07.456Z" title="2021-08-28T06:48:07.456Z">21-08-28</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">7분안에 읽기 (약 1064 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-uptime-top/">uptime, top으로 CPU 부하 확인하기</a></h1><div class="content"><p>이 글은 리눅스 상에서 CPU 자원의 현재 상황을 모니터링하는 방법을 소개한다.</p>
<blockquote>
<p>“데브옵스: 개발자, QA, 관리자가 함께 보는 리눅스 서버 트러블슈팅 기법”을 참고했다.</p>
</blockquote>
<p>코드가 예전보다 훨씬 느리게 실행돼 응답이 느려졌다면 무엇부터 확인해야 할까?</p>
<p>시스템의 특정 자원을 모두 소비했기 때문에 시스템이 느려질 수도 있다.</p>
<p>여기서 말하는 자원의 종류로는</p>
<ul>
<li>CPU</li>
<li>Main Memory</li>
<li>Disk I/O</li>
<li>Network I/O </li>
</ul>
<p>이 있고, 이 글은 CPU 부하에 한정해 소개한다.</p>
<hr>
<h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a><strong>uptime</strong></h4><p><code>load average</code> 다음의 세 실수값이 중요하다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 05:23:41 up 5 days,  1:41,  0 users,  load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure>
<blockquote>
<p>System load averages is the average number of processes that are either in a runnable or uninterruptable state.  A  process  in  a runnable  state is either using the CPU or waiting to use the CPU.  A process in uninterruptable state is waiting for some I/O access, eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of  CPUs  in a system, so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time.</p>
<p>[man uptime]</p>
</blockquote>
<p>load average는 실행 중 혹은 인터럽트 불가능한 상태의 프로세스의 평균 개수이다. </p>
<ul>
<li>실행 중인 프로세스: CPU를 사용 중이거나 CPU 사용을 기다리는 중인 프로세스</li>
<li>인터럽트 불가능한 프로세스: I/O 접근을 대기하는 프로세스</li>
</ul>
<p>예를 들어 average가 <code>1.00</code>이면 항상 1개의 프로세스가 실행 된다는 것으로 1개의 코어의 로드가 100%라는 의미이다.</p>
<blockquote>
<p>[<a target="_blank" rel="noopener" href="https://superuser.com/questions/1105654/logical-vs-physical-cpu-performance">superuser</a>]</p>
<p>멀티코어 CPU에서는 코어 별로 독립적인(병렬적인, parallel) 프로세스(스레드) 실행이 가능하기 때문에 프로세스 개수가 n이면 <code>n</code>이 전체 코어의 로드가 100%임을 나타내는 것이다.</p>
<p>Hyperthreading이 적용되어 CPU에서 2배의 스레드 실행이 가능한 경우 <code>2n</code>이 100%의 로드를 나타낼 것이다. </p>
<ul>
<li>(ex) <a target="_blank" rel="noopener" href="https://ark.intel.com/content/www/kr/ko/ark/products/212282/intel-xeon-platinum-8358-processor-48m-cache-2-60-ghz.html">코어 수 32, 스레드 수 64인 Xeon 프로세서</a>의 경우 64.00이 100%의 로드를 나타낸다.</li>
</ul>
</blockquote>
<p>다시 돌아와서, <code>uptime</code>이 표시하는 세 개의 숫자는 <strong>각각 최근 1분, 5분, 15분</strong>의 프로세스 평균 개수를 의미한다.</p>
<p>최근 1분의 부하는 현재 시스템에 가해지는 부하를 나타내는 것이다.</p>
<p>아래의 예시를 살펴보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 05:23:41 up 25 days,  1:41,  2 users,  load average: 17.29, 1.12, 0.10</span><br></pre></td></tr></table></figure>
<p>최근 15분간의 로드가 거의 없던 것에 비해 현재 1분의 로드가 꽤 큰 것을 확인할 수 있다.</p>
<ul>
<li>따라서 부하는 최근에 시작됐음을 확인할 수 있다.</li>
</ul>
<hr>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a><strong>top</strong></h4><p>top은 기본값으로 CPU 사용률로 프로세스 정보를 나열하는 유틸이지만, 상단에 표시된 <code>%Cpu(s)</code>행은 CPU 정보를 표시한다.</p>
<p><img src="/images/top_screenshot.png"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Full Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>us</td>
<td>User CPU time</td>
<td>사용자 프로세스가 소비한 CPU 사용량 비율 (nice가 적용되지 않은)</td>
</tr>
<tr>
<td>sy</td>
<td>System CPU time</td>
<td>커널과 커널 프로세스의 CPU 사용량 비율</td>
</tr>
<tr>
<td>ni</td>
<td>nice CPU time</td>
<td>nice가 적용된 프로세스의 CPU 사용량 비율</td>
</tr>
<tr>
<td>id</td>
<td>CPU idle time</td>
<td>CPU가 사용되지 않는 유휴 비율</td>
</tr>
<tr>
<td>wa</td>
<td>I/O wait</td>
<td>CPU가 I/O를 대기하면서 소비한 시간의 비율</td>
</tr>
<tr>
<td>hi</td>
<td>hardware interrupts</td>
<td>하드웨어 인터럽트를 제공하는데 CPU가 소비한 시간의 비율</td>
</tr>
<tr>
<td>si</td>
<td>software interrupts</td>
<td>소프트웨어 인터럽트를 제공하는데 CPU가 소비한 시간의 비율</td>
</tr>
<tr>
<td>st</td>
<td>steal time</td>
<td>(비교적 세부 사항이라 생략)</td>
</tr>
</tbody></table>
<p>위 표에서 가장 중요한 값은 <code>wa</code>라고 한다. 이 값이 낮으면 I/O가 문제가 아니라고 한다.</p>
<p>I/O 대기(<code>wa</code>)와 유휴 시간(<code>id</code>)이 모두 낮으면 사용자 CPU 사용률(<code>us</code>)을 확인하고 어떤 프로세스가 높은 CPU 사용량을 보이는지 확인해야 한다.</p>
<p>I/O 대기는 낮은데 유휴 시간은 높다면 병목은 CPU가 아니다. (당연하다. 유휴시간이 있다는 것 자체가..)</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-22T09:20:00.000Z" title="2021-08-22T09:20:00.000Z">21-08-22</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-22T09:18:36.910Z" title="2021-08-22T09:18:36.910Z">21-08-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/RabbitMQ/">RabbitMQ</a></span><span class="level-item">3분안에 읽기 (약 431 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-rmq-monitoring-easy/">리눅스에서 tmux와 rabbitmqctl을 이용한 Queue 잔여 메시지 모니터링하기</a></h1><div class="content"><p>이 글은 RabbitMQ에서 하나의 One Queue, One Producer, Two Consumer로 구성해 메시지를 처리하는 과정을 모니터링하는 방법을 다룬다.</p>
<hr>
<h4 id="1-tmux-사용-방법"><a href="#1-tmux-사용-방법" class="headerlink" title="1. tmux 사용 방법"></a><strong>1. tmux 사용 방법</strong></h4><p>[<a href="https://jsqna.com/linux-tmux/">jsqna</a>]</p>
<p>이 글에서 사용하는 tmux 명령어는 아래의 명령어로 한정된다.</p>
<ul>
<li>Ctrl + b 를 통해 명령어 모드 활성</li>
<li>Ctrl + b 후 <code>&quot;</code>를 누르면 새 <strong>가로</strong> 패널 생성 (<code>%</code>를 누르면 <strong>세로</strong> 패널 생성)</li>
<li>Ctrl + b + <code>방향키</code>를 누르면 각 패널 전환</li>
<li>Ctrl + b + <code>[</code>를 누르면 현재 패널에서 스크롤 활성화 (기본으로 스크롤이 불가능하다.)</li>
</ul>
<hr>
<h4 id="2-RabbitMQ-설치"><a href="#2-RabbitMQ-설치" class="headerlink" title="2. RabbitMQ 설치"></a><strong>2. RabbitMQ 설치</strong></h4><p>간단하게 Docker로 설치한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.9-management</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-RabbitMQCtl-실행-및-모니터링"><a href="#3-RabbitMQCtl-실행-및-모니터링" class="headerlink" title="3. RabbitMQCtl 실행 및 모니터링"></a><strong>3. RabbitMQCtl 실행 및 모니터링</strong></h4><p>해당 컨테이너에 bash로 접속하고 <code>watch</code>  명령어로 <code>rabbitmqctl list_queues</code>를 1초마다 반복 실행한다.</p>
<p>해당 명령어는 현재 RabbitMQ 인스턴스에 존재하는 큐와 잔여 메시지를 출력한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it &lt;container-id&gt; /bin/bash</span><br><span class="line"></span><br><span class="line">$ watch -n 1 rabbitmqctl list_queues <span class="comment"># 1초마다 해당 명령어를 실행한다.</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="4-tmux로-MQ-Producer-Consumer-총-4개의-Pane으로-구성하기"><a href="#4-tmux로-MQ-Producer-Consumer-총-4개의-Pane으로-구성하기" class="headerlink" title="4. tmux로 MQ, Producer, Consumer 총 4개의 Pane으로 구성하기"></a><strong>4. tmux로 MQ, Producer, Consumer 총 4개의 Pane으로 구성하기</strong></h4><blockquote>
<p>코드는 [<a target="_blank" rel="noopener" href="https://github.com/seongbin9786/rabbitmq_tutorial_and_explanation/tree/main/02_work_queue">github</a>]를 사용했다. 코드에 대한 설명은 주석을 참고하기 바란다.</p>
</blockquote>
<p>RabbitMQ는 기본 동작으로 Multi Consumer에 대해 Round Robin으로 메시지를 전달한다.</p>
<p>아래와 같이 네 개의 Pane으로 화면을 구성하고, 아래와 같이 구성한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 두 Pane에서는 Consumer를 실행한다.</span></span><br><span class="line">$ node receive.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 한 Pane에서는 Producer를 실행한다.</span></span><br><span class="line">$ node send.js</span><br></pre></td></tr></table></figure>
<p>아래와 같은 화면을 구성하면 성공이다. </p>
<p><img src="/images/linux-rabbitmq/monitoring.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-15T10:10:00.000Z" title="2021-08-15T10:10:00.000Z">21-08-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-15T10:03:30.544Z" title="2021-08-15T10:03:30.544Z">21-08-15</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/NCloud/">NCloud</a></span><span class="level-item">12분안에 읽기 (약 1747 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-new-machine-settings/">리눅스 - 클라우드 머신 세팅하기 (Naver Cloud)</a></h1><div class="content"><p>이 글은 네이버 클라우드에서 Server 인스턴스를 생성한 후 수행해야 할 가장 기본적인 작업인 계정 생성 및 ssh 설정을 다룬다. 이후 Docker 설치까지 진행한다.</p>
<hr>
<h2 id="1-Server-생성-및-인증키-비밀번호-확인"><a href="#1-Server-생성-및-인증키-비밀번호-확인" class="headerlink" title="1. Server 생성 및 인증키, 비밀번호 확인"></a><strong>1. Server 생성 및 인증키, 비밀번호 확인</strong></h2><h3 id="Server-생성"><a href="#Server-생성" class="headerlink" title="Server 생성"></a><strong>Server 생성</strong></h3><p>그냥 하면 된다. Zone과 사양만 지정한다.</p>
<h3 id="ACG-생성"><a href="#ACG-생성" class="headerlink" title="ACG 생성"></a><strong>ACG 생성</strong></h3><p>그냥 하면 된다. 없으면 하나 만든다. 단순한 방화벽 설정이다.</p>
<h3 id="인증키-다운로드"><a href="#인증키-다운로드" class="headerlink" title="인증키 다운로드"></a><strong>인증키 다운로드</strong></h3><p>다운로드 하면 된다. 그냥 key다.</p>
<p>[<a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/115838/what-is-the-right-file-permission-for-a-pem-file-to-ssh-and-scp">StackExchange</a>]</p>
<blockquote>
<p>WSL을 사용한다면 Windows에서 cp로 WSL에 파일을 옮기고 난 후 <code>chmod 400 $FILENAME.pem</code>으로 적절한 권한을 줘서 보호한다.</p>
</blockquote>
<h3 id="비밀번호-확인"><a href="#비밀번호-확인" class="headerlink" title="비밀번호 확인"></a><strong>비밀번호 확인</strong></h3><p>서버 콘솔 &gt; 서버 관리 및 설정 변경 버튼 &gt; 관리자 비밀번호 확인</p>
<p>열리는 Modal에 인증키를 업로드하면 확인할 수 있다.</p>
<h3 id="포트포워딩-설정하기"><a href="#포트포워딩-설정하기" class="headerlink" title="포트포워딩 설정하기"></a><strong>포트포워딩 설정하기</strong></h3><p>모든 포트를 열어주는 게 아니라 SSH 접속 용도로만 공인 아이피를 제공한다. 1024~65535 사이의 포트는 임의로 지정할 수 있다.</p>
<ul>
<li><p>보통 편리하게 2222로 하는 편이다.</p>
</li>
<li><p>애초에 포트포워딩을 안 하더라도 ssh 포트는 변경하는 편이다.</p>
</li>
<li><p>포트 설정의 자유를 제공한 것은</p>
<ul>
<li>enterprise에선 요구사항이 다양하기 때문이고,</li>
<li>통계적으로 특정 포트로 몰리지 않기 때문인 듯하다.</li>
</ul>
</li>
</ul>
<h3 id="서버-접속"><a href="#서버-접속" class="headerlink" title="서버 접속"></a><strong>서버 접속</strong></h3><p><code>ssh root@SERVER_IP -p PORT</code> 로 비밀번호 방식으로 ssh 접속을 할 수 있다. </p>
<h2 id="2-privatekey-기반-ssh-로그인-구성"><a href="#2-privatekey-기반-ssh-로그인-구성" class="headerlink" title="2. privatekey 기반 ssh 로그인 구성"></a><strong>2. privatekey 기반 ssh 로그인 구성</strong></h2><p>ssh의 비밀번호 방식을 허용할 경우 Bruteforce 공격의 대상이 된다. </p>
<ul>
<li>이는 aws instance를 생성한 후 아무런 정보 없이도 공격이 매우 많이 쌓이는 것을 확인할 수 있다.</li>
</ul>
<p>이는 임의의 매우 긴 rsa keypair를 사용한다면 공격의 비용이 매우 커지므로 효과적으로 줄일 수 있으며, 일반적인 password에 비해 key의 길이가 훨씬 더 기므로 더 안전할 것이다.</p>
<blockquote>
<p> RSA 방식으로 생성된 key로 로그인하는 방식이다.</p>
<ul>
<li><p>서버에 publickey를 직접 등록한다. (즉, 최초의 rsa 방식의 연결 이전에 미리 서버에 접근할 수 있어야 한다.)</p>
</li>
<li><p>publickey 방식으로 ssh 접속한다.</p>
<ol>
<li>server에서 메시지를 publickey로 암호화한다.</li>
<li>client에서 메시지를 privatekey로 복호화한다.</li>
<li>client에서 메시지를 전송하고, server에서 일치 여부를 확인하고 접근을 허가한다.</li>
</ol>
</li>
</ul>
</blockquote>
<p>[<a target="_blank" rel="noopener" href="https://opentutorials.org/module/432/3742">생활코딩</a>]</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-----내 PC------</span></span><br><span class="line"><span class="comment"># 클라이언트에서 privatekey, publickey 쌍을 생성한다.</span></span><br><span class="line"><span class="comment"># id_rsa가 privatekey, id_rsa.pub이 publickey이다.</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----원격 서버------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 본인 클라이언트에서 생성한 데이터로 파일을 생성한다.</span></span><br><span class="line"><span class="comment"># 굳이 파일로 만드는 이유는 cat으로 redirect하기 위함</span></span><br><span class="line">nano id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; 는 append의 의미이다.</span></span><br><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>


<p>[<a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/127307/how-to-configure-ssh-public-key-per-user">StackExchange</a>]</p>
<p>authorized_keys는 .ssh 밑에 있으므로 유저 한 명의 범위이다.</p>
<p>같은 privatekey로 여러 사용자로 접속하고 싶다면, <code>/home/&#123;USER&#125;/.ssh/authorized_keys</code>에 모두 등록해주어야 한다.</p>
<p>authorized_keys 등록을 하지 않고 passwordlogin을 못하게 설정하면 이후 해당 서버로는 영영 접속할 수 없게 된다.</p>
<ul>
<li>클라우드 상에서 직접 접속할 수 있는 콘솔을 제공하는 경우는 될지도 모르겠다.</li>
</ul>
<h2 id="3-sudo-계정-생성"><a href="#3-sudo-계정-생성" class="headerlink" title="3. sudo 계정 생성"></a><strong>3. sudo 계정 생성</strong></h2><p>네이버 클라우드로 인스턴스를 프로비저닝한 경우 계정이 따로 생성되지 않으므로 직접 생성해야 한다.</p>
<blockquote>
<p>root 계정을 그냥 사용하는 경우의 단점:</p>
<ol>
<li>과도한 권한이 있다. (모든 작업이 가능하다.)</li>
<li>생성한 파일 소유권이 root가 된다. (root 계정의 사용의 악순환 유발)</li>
<li>이름이 root이다. (공격 대상이 되기 매우 쉽다.)</li>
</ol>
</blockquote>
<h3 id="계정-생성"><a href="#계정-생성" class="headerlink" title="계정 생성"></a><strong>계정 생성</strong></h3><p>[<a target="_blank" rel="noopener" href="https://jhnyang.tistory.com/10">jhnyang</a>]</p>
<blockquote>
<p>아래 파일을 생성 즉시 곧장 실행한다면 Permission denied이 발생한다.</p>
<p><code>chmod +x ./&#123;filename&#125;</code>을 수행하여, 실행 권한을 부여한 후 실행(<code>./&#123;filename&#125;</code>)한다.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">NAME=<span class="string">&quot;username&quot;</span></span><br><span class="line">PWD=<span class="string">&quot;password&quot;</span> <span class="comment"># 8글자까지면 상관 없음. 길면 truncate 됨.</span></span><br><span class="line">SHELL=<span class="string">&quot;/bin/bash&quot;</span> <span class="comment"># 배쉬 사용</span></span><br><span class="line">ENC_PWD=<span class="string">&quot;<span class="subst">$(openssl passwd -crypt $PWD)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ENC_PWD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 보통 그룹을 이름과 같게 생성해줌</span></span><br><span class="line">groupadd <span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 사용자 추가</span></span><br><span class="line"><span class="comment"># 비밀번호 지정</span></span><br><span class="line"><span class="comment"># sudo 사용할 수 있게 수정</span></span><br><span class="line"><span class="comment"># 홈 디렉토리 자동 생성</span></span><br><span class="line">useradd -p <span class="variable">$ENC_PWD</span> -s <span class="variable">$SHELL</span> -g <span class="variable">$NAME</span> -G sudo -m <span class="variable">$NAME</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>신기한 점은, home_directory를 자동으로 생성하면, <code>/etc/skel</code>에 있는 파일이 자동으로 복사되지 않아 <code>ll</code>과 같은 alias를 사용할 수 없다는 점이다. 이는 <code>useradd</code>에서 <code>-m</code> 옵션을 주면 자동으로 생성되며 파일들도 잘 복사되어 해결된다.</p>
</li>
<li><p><code>-p</code> 옵션으로 plaintext로 비밀번호를 전달하니 해당 비밀번호로는 로그인할 수 없었다. 암호화를 적용하니 잘 됐는데,  <code>passwd</code>로 변경 시 자동으로 암호화되는 듯하다.</p>
</li>
</ul>
<h3 id="계정-생성-삭제-과정의-명령어들-모음"><a href="#계정-생성-삭제-과정의-명령어들-모음" class="headerlink" title="계정 생성, 삭제 과정의 명령어들 모음"></a><strong>계정 생성, 삭제 과정의 명령어들 모음</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 그룹 조회</span></span><br><span class="line">cat /etc/group</span><br><span class="line"></span><br><span class="line"><span class="comment"># 그룹 생성</span></span><br><span class="line">groupadd <span class="variable">$GROUPNAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 그룹 삭제</span></span><br><span class="line">groupdel <span class="variable">$GROUPNAME</span> (-f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 유저 조회</span></span><br><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 유저 생성</span></span><br><span class="line">useradd <span class="variable">$USERNAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 유저 삭제</span></span><br><span class="line">userdel (-r) <span class="variable">$USERNAME</span> <span class="comment"># -r 로 홈 디렉토리까지 제거</span></span><br></pre></td></tr></table></figure>

<h3 id="sudoer-등록"><a href="#sudoer-등록" class="headerlink" title="sudoer 등록"></a><strong>sudoer 등록</strong></h3><p>나중에 수동으로 sudoer에 등록하려면 간단하다.</p>
<p>sudo 그룹에 사용자명을 추가하면 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/group</span><br><span class="line"></span><br><span class="line">sudo:x:27:user1,user2 <span class="comment"># 여기 뒤에 사용자 명을 추가하면 된다.</span></span><br></pre></td></tr></table></figure>


<h3 id="기본-셸을-bash-사용하게-등록"><a href="#기본-셸을-bash-사용하게-등록" class="headerlink" title="기본 셸을 bash 사용하게 등록"></a><strong>기본 셸을 bash 사용하게 등록</strong></h3><p>나중에 수동으로 bash 셸을 사용하게 하려면 간단하다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 맨 밑 라인으로 가서,</span></span><br><span class="line">sb:x:1001:1001::/home/sb:/bin/sh</span><br><span class="line"><span class="comment"># 에서</span></span><br><span class="line">sb:x:1001:1001::/home/sb:/bin/bash</span><br><span class="line"><span class="comment"># 로 변경한다.</span></span><br></pre></td></tr></table></figure>


<h2 id="4-sshd-보안-설정"><a href="#4-sshd-보안-설정" class="headerlink" title="4. sshd 보안 설정"></a><strong>4. sshd 보안 설정</strong></h2><h3 id="root-계정-로그인-시도-차단"><a href="#root-계정-로그인-시도-차단" class="headerlink" title="root 계정 로그인 시도 차단"></a><strong>root 계정 로그인 시도 차단</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes <span class="comment"># 이걸 no로 바꾸면 된다.</span></span><br></pre></td></tr></table></figure>


<h3 id="비밀번호-접속-차단"><a href="#비밀번호-접속-차단" class="headerlink" title="비밀번호 접속 차단"></a><strong>비밀번호 접속 차단</strong></h3><p>비밀번호 접속을 차단하지 않으면 bruteforce 공격이 매우 많이 들어오게 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PasswordAuthentication yes</span></span><br><span class="line"><span class="comment"># 위 주석을 제거하고 no로 변경한다.</span></span><br></pre></td></tr></table></figure>


<h2 id="5-Docker-및-Docker-compose-설치"><a href="#5-Docker-및-Docker-compose-설치" class="headerlink" title="5. Docker 및 Docker-compose 설치"></a><strong>5. Docker 및 Docker-compose 설치</strong></h2><p>[<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/">Docker Docs</a>] [<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/">Docker Docs</a>]</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Engine 설치</span></span><br><span class="line"><span class="comment"># -y가 필요한 진 모르겠음.</span></span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># compose 설치 (Optional)</span></span><br><span class="line"><span class="comment"># 최신 버전의 도커 엔진은 compose 명령세트가 포함돼서 배포되므로</span></span><br><span class="line"><span class="comment"># docker compose 형식으로 사용하면 되므로 굳이 설치할 필요는 없다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 참고로 apt install로 깔면 무슨 옛날 버전 나온다.</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-25T14:55:00.000Z" title="2021-07-25T14:55:00.000Z">21-07-25</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-25T14:55:46.220Z" title="2021-07-25T14:55:46.220Z">21-07-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">5분안에 읽기 (약 788 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-file-descriptor/">리눅스에서의 파일 디스크립터와 리다이렉션</a></h1><div class="content"><p>이 글은 리눅스에서의 파일 디스크립터와 이를 활용한 리다이렉션에 대해 소개한다.</p>
<hr>
<h3 id="1-리눅스-표준-스트림-3가지와-파일-디스크립터"><a href="#1-리눅스-표준-스트림-3가지와-파일-디스크립터" class="headerlink" title="1. 리눅스 표준 스트림 3가지와 파일 디스크립터"></a><strong>1. 리눅스 표준 스트림 3가지와 파일 디스크립터</strong></h3><blockquote>
<p>각 유닉스 프로세스는 아래 세 개의 표준 스트림에 대응되는 세 개의 POSIX 표준 파일 디스크립터를 갖는다.</p>
</blockquote>
<p>파일 디스크립터란 <code>C int</code> 타입의 값이며 아래에서 소개할 파일 디스크립터 테이블의 index 번호이다.</p>
<p>표준 입력, 출력, 오류 스트림은 각 프로세스의 파일 디스크립터의 0, 1, 2번을 할당받는다.</p>
<table>
<thead>
<tr>
<th align="center">Integer value</th>
<th align="center">Name</th>
<th align="center">symbolic constant</th>
<th align="center">file stream</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stdin">Standard input</a></td>
<td align="center">STDIN_FILENO</td>
<td align="center">stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stdout">Standard output</a></td>
<td align="center">STDOUT_FILENO</td>
<td align="center">stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stderr">Standard error</a></td>
<td align="center">STDERR_FILENO</td>
<td align="center">stderr</td>
</tr>
</tbody></table>
<p>리눅스 셸에서의 Redirect는 기본적으로 파일에 쓰고, 파일에서 읽지만 파일 대신 파일 디스크립터를 사용하고, 파일 디스크립터 앞에 <code>&amp;</code>를 붙이면 그대로 적용된다. </p>
<p>예를 들어, <code>command &gt; 1</code> 은 표준 출력으로 Redirect 하라는 의미가 아니라 파일 <code>1</code>로 출력하라는 것으로 해석되며, <code>command &gt;&amp; 1</code>는 파일 디스크립터 1이 가리키는 파일로 출력하라는 것으로 해석되며, 이는 표준 출력이므로, 정상적으로 출력됨을 확인할 수 있다.</p>
<p>참고로 <code>command 2 &gt;&amp; 1</code>의 경우 표준 오류 스트림이 표준 출력 스트림으로 Redirect되는데 왜 2 앞에는 <code>&amp;</code>가 붙지 않아도 될까? 그 이유는…</p>
<blockquote>
<p>&amp; is only interpreted to mean “file descriptor” in the context of redirections</p>
</blockquote>
<p>라고 한다. (나도 잘 모르겠다. 왜 <code>2&gt;</code>가 stderr를 Redirect 한다는 의미로 쓰일 수 있는지도 모르겠다. 이건 셸 문서를 봐야할듯.)</p>
<p>참고: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/818255/in-the-shell-what-does-21-mean">StackOverFlow</a></p>
<hr>
<h3 id="2-파일-디스크립터-테이블"><a href="#2-파일-디스크립터-테이블" class="headerlink" title="2. 파일 디스크립터 테이블"></a><strong>2. 파일 디스크립터 테이블</strong></h3><p><img src="https://t1.daumcdn.net/cfile/tistory/2778633C56A9E24622"></p>
<p>Process마다 파일 디스크립터 테이블이 하나씩 존재한다. 파일 디스크립터는 index이므로 <code>auto_increment</code>와 같이 1씩 증가하며 발급된다. (따라서 Process에서 처음 파일 디스크립터를 발급 받는 경우 3부터 시작한다.)</p>
<p>아래와 같은 함수들이 파일 디스크립터를 하나 생성한다. (<code>&lt;unistd.h&gt;</code>에 정의돼있다.)</p>
<ul>
<li><code>open()</code></li>
<li><code>creat()</code></li>
<li><code>socket()</code></li>
<li><code>accept()</code></li>
</ul>
<p>네트워크 관련해서도 <code>select()</code>, <code>bind()</code>, <code>listen()</code>, <code>connect()</code> 등 파일 디스크립터와 관련된 함수들이 많은데 아직 C/C++ 기반 TCP/IP 프로그래밍을 해보지 못해서 추후에 다루려고 한다.</p>
<hr>
<h3 id="3-파일-디스크립터-조회-및-제한"><a href="#3-파일-디스크립터-조회-및-제한" class="headerlink" title="3. 파일 디스크립터 조회 및 제한"></a><strong>3. 파일 디스크립터 조회 및 제한</strong></h3><p><code>ls -trn</code> 명령으로 프로세스별 파일 디스크립터를 조회할 수 있다.</p>
<p><img src="/images/linux-file-descriptor/get_fd_by_pid.png"></p>
<p><code>ulimit</code> 명령으로 프로세스별 파일 디스크립터 개수의 제한 역시 조회할 수 있다.</p>
<p>이 명령은 또한 그 제한을 바꿀 수도 있는데, ulimit의 open files의 경우 65535까지 가능했다. (이를 초과해서는 root 권한으로도 할 수 없었다.)</p>
<p><img src="/images/linux-file-descriptor/ulimit-a.png"></p>
<hr>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-17T14:58:00.000Z" title="2021-07-17T14:58:00.000Z">21-07-17</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-17T14:58:53.820Z" title="2021-07-17T14:58:53.820Z">21-07-17</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">6분안에 읽기 (약 869 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-env-security/">환경 변수와 보안</a></h1><div class="content"><p>이 글은 리눅스의 환경 변수에 대해 설명하고, 환경 변수가 얼마나 안전한지 다룬다.</p>
<hr>
<h3 id="1-환경-변수의-종류"><a href="#1-환경-변수의-종류" class="headerlink" title="1. 환경 변수의 종류"></a><strong>1. 환경 변수의 종류</strong></h3><p>출처: <a target="_blank" rel="noopener" href="http://howtolamp.com/articles/difference-between-local-and-environment-variables/">howtolamp</a>, <a target="_blank" rel="noopener" href="https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-linux">digitalocean</a></p>
<p>환경 변수란 String Key-Value 쌍으로, 두 종류가 있다. Local Env와 Global Env가 있는데, Local Env는 셸에서 사용되는 변수를 의미하고, Global Env는 흔히 말하는 환경 변수를 의미한다. </p>
<h3 id="2-환경-변수의-조회와-변경"><a href="#2-환경-변수의-조회와-변경" class="headerlink" title="2. 환경 변수의 조회와 변경"></a><strong>2. 환경 변수의 조회와 변경</strong></h3><p>Local Env는 <code>set</code> 명령으로 조회할 수 있고, 환경 변수는 <code>env</code> 명령으로 조회할 수 있다.</p>
<p>Local Env를 <code>set</code>로 조회하는 경우, 셸 변수, 환경 변수, 로컬 변수, 셸 함수가 출력된다.</p>
<p>Local Env는 <code>&#123;KEY&#125;=&#123;VALUE&#125;</code> 형태로 등록할 수 있으며, <code>set | grep &#123;KEY&#125;=</code> 으로 반영됐는지 확인해볼 수도 있다. 단 이런 방식으로 등록한 경우 <code>printenv | grep &#123;KEY&#125;</code>로 확인하면 등록되지 않음을 확인할 수 있다.</p>
<blockquote>
<p>printenv는 환경 변수 출력 면에서 env와 같다. 자세한 내용은 <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/123473/what-is-the-difference-between-env-and-printenv">stackoverflow</a> 참고</p>
</blockquote>
<p>등록된 Local Env는 셸에서 <code>$&#123;KEY&#125;</code>로 참조할 수 있다. 즉, <code>echo $&#123;KEY&#125;</code>로 출력할 수 있다.</p>
<p>Global Env를 등록하려면 <code>export &#123;KEY&#125;=&#123;VALUE&#125;</code>를 사용한다.</p>
<h3 id="3-Local-Env의-범위"><a href="#3-Local-Env의-범위" class="headerlink" title="3. Local Env의 범위"></a><strong>3. Local Env의 범위</strong></h3><p>Local Env는 현재 셸 프로세스 및 자식 프로세스 범위에서만 존재한다. 즉, 새로운 터미널 등에서 실행한 셸 프로세스에서 <code>echo $&#123;KEY&#125;</code>를 수행하면 아무것도 나오지 않음을 확인할 수 있다.</p>
<h3 id="4-Global-Env의-범위"><a href="#4-Global-Env의-범위" class="headerlink" title="4. Global Env의 범위"></a><strong>4. Global Env의 범위</strong></h3><p>Global Env의 경우 모든 프로세스에서 접근이 가능하다. </p>
<h3 id="5-Process-별-Env"><a href="#5-Process-별-Env" class="headerlink" title="5. Process 별 Env"></a><strong>5. Process 별 Env</strong></h3><p><code>/proc/&#123;pid&#125;/environ</code>로 프로세스에서 사용되는 환경 변수를 조회할 수 있다. 이 경우 프로세스에 접근할 수 있는 권한이 필요하다.</p>
<blockquote>
<p>정확히 무슨 권한이 필요한지는 더 공부가 필요하다.</p>
</blockquote>
<h3 id="6-환경변수의-안전성-secureness"><a href="#6-환경변수의-안전성-secureness" class="headerlink" title="6. 환경변수의 안전성(secureness)"></a><strong>6. 환경변수의 안전성(secureness)</strong></h3><p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12461484/is-it-secure-to-store-passwords-as-environment-variables-rather-than-as-plain-t">stackoverflow</a></p>
<p>환경 변수에 중요 정보를 저장하는 것은 안전하지 않다. 보통 환경 변수가 사용되는 경우는 Credential을 배포할 때인데, 패스워드 등을 저장한 파일과 비교했을 때 더 안전하지는 않다고 한다.</p>
<p>그럼에도 환경 변수를 쓰는 이유가 뭘까?</p>
<blockquote>
<p>As mentioned before, both methods do not provide any layer of additional “security” once your system is compromised. I believe that one of the strongest reasons to favor environment variables is version control: I’ve seen way too many database configurations etc. being accidentially stored in the version control system like GIT for every other developer to see (and whoops! it happened to me as well …).</p>
<p>Not storing your passwords in files makes it impossible for them to be stored in the version control system.</p>
</blockquote>
<p>즉, Git 등으로 관리하면 실수할 여지가 크기 때문에 환경 변수를 사용한다고 한다.</p>
<p>배포 측면에선 환경 변수가 편리하지만 둘 다 안 좋은 방법이다.</p>
<blockquote>
<p>a library author could email stack traces plus the ENV variables to themselves for debugging</p>
</blockquote>
<p>즉 라이브러리 등에서도 모두 접근이 가능하기 때문에 (ex: NodeJs의 경우 <code>process.env</code>) 디버깅 혹은 스택 트레이스가 서버로 전송될 수도 있어서, 이런 경우 훨씬 위험할 수 있다.</p>
<hr>
<h3 id="7-환경변수는-안전한가"><a href="#7-환경변수는-안전한가" class="headerlink" title="7. 환경변수는 안전한가?"></a><strong>7. 환경변수는 안전한가?</strong></h3><p>그렇지 않다.</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Linux/page/0/">이전</a></div><div class="pagination-next"><a href="/categories/Linux/page/2/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Linux/">1</a></li><li><a class="pagination-link" href="/categories/Linux/page/2/">2</a></li><li><a class="pagination-link" href="/categories/Linux/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/NCloud/"><span class="level-start"><span class="level-item">NCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/RabbitMQ/"><span class="level-start"><span class="level-item">RabbitMQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T14:43:00.000Z">21-10-10</time></p><p class="title"><a href="/linux-ipc-unix-domain-socket/">리눅스에서의 IPC Socket vs Network Socket</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-03T14:50:00.000Z">21-10-03</time></p><p class="title"><a href="/linux-install-zsh/">ZSH를 WSL2에 설치하는 방법</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-26T14:50:00.000Z">21-09-26</time></p><p class="title"><a href="/linux-shell-2-screen/">screen: 리눅스에서 셸을 유지하면서 나갔다 들어오는 방법</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-19T14:30:00.000Z">21-09-19</time></p><p class="title"><a href="/linux-profile-not-loaded/">왜 .profile 파일이 적용되지 않을까</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-12T13:33:00.000Z">21-09-12</time></p><p class="title"><a href="/linux-debian-dpkg-apt/">데비안 리눅스 패키지 매니저 dpkg와 apt</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">10월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">9월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NCloud/"><span class="tag">NCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RabbitMQ/"><span class="tag">RabbitMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
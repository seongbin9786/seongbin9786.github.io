{"pages":[],"posts":[{"title":"10분 만에 기반 지식 없이 Node.js를 위한 Github Actions CI 구축하기","text":"목표 10분 만에 Github Actions를 통한 CI를 구축한다. master에 Merge 시에 ESLint와 테스트를 자동으로 수행하고, 결과에 따라 Merge할 수 없게 한다. 1. 기본 개념 설명기본 개념 몇 가지를 소개하고 넘어간다. 1. CIContinuous Integration. 각자의 코드를 병합하기 전에 검토하는 절차를 말한다. 보통 자동화된 상태를 지칭하며, master(or main) 등의 특정 브랜치에 Push(or Merge) Request가 올라오면 코드를 검토한다. 2. GitHub ActionsGitHub에서 특정 작업을 할 때 마다, 이벤트를 발생시키는데, 이를 구독해 특정 작업을 실행하는 것을 Github Actions라고 한다. (옵저버 패턴 참고) 3. Worflow FileGitHub Actions의 이벤트에 대해 무엇을 실행할 지에 대해 기록해 놓은 명령서를 workflow 파일이라고 한다. 4. Github Actions 사용 시의 CI 흐름PR Created(EVENT!) &gt; Build &gt; Test &gt; PR Merged(EVENT!) &gt; Deploy (배포 자동화는 다음에) PR을 생성할 때 CI 수행 Merge할 때 CD 수행 CI 과정에서 빌드가 성공했을 때만 Merge가 가능하게 설정하자. 2. Node.js App 으로 CI 구축 시작이 챕터에서 구축을 완료하고, 결과를 확인한다. 아주 간단한 과정이어서 CI라고 하긴 부끄럽지만, 아래 과정을 수행한다. npm module 설치 ESLint를 통한 코드 스타일 체크 테스트 실행 1. 필요한 자료 ESLint가 설치된, 스택에 상관 없는 Node.js 샘플 앱 샘플 앱을 올린 Public Repo가 필요하다. (이 글에서 코드를 따로 제공하지는 않는다.) 글쓴이는 토이 작업 중인 이 레포를 활용하였다. 글에서 Jest를 설치하고, ESLint와 연동할 것이다. 2. Node.js 템플릿 가져와서 사용하기아래는 레포지토리에서 Actions 탭을 눌러, Get started with GitHub Actions 아래에 있는 Node.js 템플릿을 가져온 것이다. 12345678910111213141516171819202122232425262728293031323334353637383940name: Node.js CI# 구독할 이벤트on: push: branches: [master] pull_request: branches: [master]# jobs 단위로 개별 서버(정확히는 Docker 컨테이너 단위라고 한다.)에서 작업이 수행된다.# 각 작업은 병렬로 실행 된다고 하는데, needs: build와 같이 표시해서 기다릴 수도 있다.jobs: build: # Ubuntu, Windows, MacOS를 지원한다. runs-on: ubuntu-latest # 영상에서도 소개됐는데, 변수 개념으로 생각하면 된다. # node-version 과 같이 배열로 돼있으면, 해당 원소를 순회하면서 작업이 반복해서 실행된다. # matrix 때문인지 배열만 되는 것 같다. (TODO) # 응용해서 runs-on에 여러 OS에서 돌릴 수도 있다. strategy: matrix: node-version: [14.x] # 템플릿 기본값: [10.x, 12.x, 14.x] # uses 개념은 다른 사람이 작성한 내용을 실행하는 개념이다. # actions/checkout: GitHub의 마지막 커밋으로 Checkout 한다. # actions/setup-node: Node.js를 설치한다. # run 개념은 명령어를 실행한다. 셸 스크립트와 동일하다. steps: - uses: actions/checkout@v2 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node-version }} # npm ci는 npm install과 같은 기능을 수행한다. 자세한 내용은 아래 링크 참조. - run: npm ci # --if-present 옵션은 npm 스크립트가 존재할 때만 실행시키라는 의미이다. # 만약 build 스크립트가 없는 경우, 오류 없이 지나간다. - run: npm run build --if-present - run: npm test npm ci에 대한 스택 오버 플로우 설명 (속도가 2배 가량 빠르다고 한다. 캐싱에 대한 내용도 있으면 좋겠다) –if-present 옵션에 대한 스택 오버 플로우 설명 GitHub Actions Checkout ? 프로젝트에 이 파일을 .github/workflows/ci.yml로 저장한다. 이후 Push 하면 Actions 탭을 눌렀을 때 해당 빌드 과정이 수행됨을 볼 수 있다. 단, 아직 설정이 다 끝나지 않았으므로, 이 파일의 구조만 확인하기 바란다. 2. 기본 제공 Workflow에 Lint, Test 추가Lint와 Test 과정을 추가한다. 각 과정은 실패 없이 진행돼야 빌드가 성공한다. Lint 과정에선 error로 설정된 Rule을 위반한 경우 빌드가 실패하게 된다. 1. Lint: node_modules 에 있는 ESLint를 수행하는 스크립트가 필요하다. 아래 내용을 추가하자. 12345//...&quot;scripts&quot;: { //... &quot;lint&quot;: &quot;./node_modules/.bin/eslint .&quot;}, ci.yaml 파일에 npm run lint를 추가하자. 12345steps: # ... - run: npm run build --if-present - run: npm run lint - run: npm test 2. Test: Jest를 설치하고, 아래 내용을 추가하자. 폴더를 /tests로 설정했는데, 굳이 그럴 필요가 없다면 생략해도 된다. Test가 하나라도 실패하면 당연히 빌드는 실패하게 된다. 12345//...&quot;scripts&quot;: { //... &quot;test&quot;: &quot;./node_modules/.bin/jest --verbose ./tests&quot;}, Jest 폴더 설정 스택 오버플로우 설명 Jest는 글로벌로 API를 expose하기 때문에 ESLint error가 나지 않으려면 플러그인을 설치해줘야 한다. npm i --save-dev eslint-plugin-jest 로 ESLint-Plugin-Jest를 설치한다. eslintrc.yml 파일에 아래의 내용을 추가한다. 12345678910111213141516171819//...env: //... jest: true # Jest 글로벌plugins: - jest # Jest 테스트를 위해 플러그인이 필요하다.rules: //... # Jest Eslint 옵션은 0,1,2 (off, warn, error) 만 옵션으로 사용 가능하다. jest/no-disabled-tests: - warn jest/no-focused-tests: - error jest/no-identical-title: - error jest/prefer-to-have-length: - warn jest/valid-expect: - error ESLint 설정 스택오버플로우 설명 3. 빌드 성공 전에 Merge Button을 누를 수 없게 하기GitHub에서 Branch Protection Rule이라는 기능을 제공한다. 레포지토리 &gt; Settings 탭 &gt; Branches 탭 &gt; Branch protection rules 탭 &gt; Add Rule 버튼 클릭 후 아래와 같이 설정하였다. 4. 끝! ci.yml 파일을 Push 하자. Master에 Push하거나 Pull Request를 올리자 CI가 동작함을 확인하자. 글쓴이는 아래처럼 잘 동작함을 확인했다. 코드 베이스가 작고, 테스트가 사실상 전무하지만, 그래도 Node 설치부터 실행까지 20초밖에 걸리지 않는다는 점은 신기하고 인상적이다. Public 레포로 작업하면 좋은 성능의 CI를 무료로 사용할 수 있어 좋은 것 같다. TODO CD 과정도 구축하기. Docker 레지스트리 배포가 일반적인 듯하다. (쿠버네티스가 사용되는듯) Jobs에서 build 하나만으로 괜찮은 것 같긴 한데, 나누는 case는 뭐가 있을지 확인해보기 npm run build 명령어로 무엇을 실행할지 고민해보기. Node.js로 프로덕션 배포를 해 본 적이 없어서 뭐가 필요한지 아직 파악하지 못 했다. GitHub Actions에 대해 이론적으로 더 공부해보고, 할 수 있는 것들 더 많이 배우기 Git Hooks라는 개념도 있다고 한다. 로컬 수준에서도 프로세스를 자동화할 수 있는 것 같은데, 한 번 알아봐야겠다. 기타 내용 정리Why is it free?public은 무료, private은 사용량 만큼 낸다고 한다. 왜 무료일지 확인해봤는데, 출처에 따르면 Open Source 프로젝트 지원이라는 명목이다. We want every open source project to be productive and use best practices, so Actions is free for the 40 million developers on GitHub to use with public repositories. For private repositories, Actions offers simple, pay-as-you-go pricing. (…) Supported OS위에서 언급했듯, Ubuntu, Windows, MacOS 이다. Docker 컨테이너로 작동한다고 하며, 매 번 Fresh한 Docker Container가 제공된다고 한다. 계기가 된 Video참고한 유튜브 비디오. 간단하게 Github Actions이 뭔지 영상을 보기만 해도 파악이 가능하다. https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana 글쓴이는 도커 기본 개념과 컨테이너 개념에 조금 익숙한 상태로 봐서 쉽다고 느꼈지만, 정말 아무것도 모른다면 조금 어려울 수도 있다. 영상에서도 언급했듯 Github Actions의 설정 파일은 Docker와 비슷하다.","link":"/ci-1-github-actions-nodejs/"},{"title":"[1 Month Docker] 1. Docker의 기본 컨셉과 Hello World","text":"Docker의 기본 컨셉을 다루고, 간단한 Hello World를 실습한다. build, share, run: build: (생략) share: DockerHub에서 이미지를 공유할 수 있다. run: 공유된 이미지를 통해 누구나 컨테이너를 실행할 수 있다. 이미지? 일단 Docker의 재사용 단위라고 생각하자. 도커 컨테이너? 애플리케이션을 담은 박스. 이 박스에는 기기명, IP 주소, 스토리지가 딸린, Docker에서 만들어낸 논리적인 가상 컴퓨터가 있다. 애플리케이션은 이 컴퓨터에서 실행된다. 박스 안의 애플리케이션은 박스 밖을 볼 수 없다. 이 박스는 여러 개가 동시에 실행될 수도 있다. 박스는 같은 실제 컴퓨터를 공유하면서 격리된 환경을 갖는다. 일관된 작업 방식: 아무리 애플리케이션이 복잡하더라도 Docker Image 단위로 Share, Run 만 하면 된다. 몇 개의, 어떤 컴포넌트, 설정 파일, 라이브러리를 사용하는지는 중요하지 않다. Portability: Docker가 있는 컴퓨터에선 명령어 하나로 곧바로 설치가 가능하다. 효율적인 자원 활용: 도커는 VM이 그렇듯, 여러 애플리케이션을 동시에 실행하는 것으로 컴퓨터 자원을 최대한 활용할 수 있다. 다만 VM보다 나은 점을 아래 표로 정리했다. 사용 자원 Docker VM Guest OS 사용 여부 No (커널 공유) Yes 가상화 리소스 비용 매우 낮음 (커널 공유) 독립적인 OS 수준 Gust OS Update 다운로드 Base Image 교체 수동 설치 아주 작은 앱 띄우기 Yes No 인수인계/배포 비용 A Dockerfile hours of installation 책에서는 Guest OS License 비용 문제에서도 차이가 난다고 언급했지만, Docker Image 형태로 쓴다고 해서 License 비용이 낮아지거나 사라지지는 않을 것 같다. 반대로 대수가 늘어나기 때문에 Open Source 기반으로 사용하지 않을까 생각이 든다. 네이티브 vs Docker vs KVM(VM 계열) 벤치마크 p.19 참고 주요 도커 명령어: 명령어 기능 docker container ls 실행 중인 컨테이너의 목록 표시 docker container ls –all 전체 컨테이너의 목록 표시 (종료된 것 포함) docker container run –detach {IMG} 컨테이너를 백그라운드로 실행 docker container run –publish 8088:80 {IMG} Host의 8088 포트로 Listen하여 컨테이너의 80포트로 전달 docker container inspect {ID} 컨테이너의 상세 정보를 JSON으로 출력 docker container stats {ID} 컨테이너가 사용하는 Host 자원 출력 docker container rm (–force) {ID} 컨테이너를 완전히 제거 (실행 중인 경우 force) docker container rm –force $(docker container ls –all – quiet) 모든 컨테이너를 강제 제거 종료된 컨테이너는 제거된 것이 아니어서 계속 용량을 차지하며, 아래 작업이 가능하다. 그대로 다시 실행 컨테이너 내의 App이 생성한 로그를 확인 파일을 Host에서 or Host로 복사 컨테이너의 네트워크: 기본적으로, 각 컨테이너는 Host 네트워크에 대해 격리된다. 컨테이너는 Host 내의 가상 사설망으로 구성된다. Docker는 Host의 네트워크 트래픽을 가로채 컨테이너로 보낼 수 있다. Docker가 컨테이너를 실행하는 방법: Docker Engine은 Docker Backend이다. Docker API(HTTP 기반의 REST API)를 제공한다. 이미지 재사용에 관한 기능은 직접 하고, 컨테이너는 containerd에 기반해 관리한다고 한다. containerd는 CNCF에 의해 관리되는 오픈소스 프로젝트이다. Docker CLI: Docker의 Frontend이다. Docker Engine과 소통하는 방법을 제공한다. 기타 정보: Docker는 가장 인기가 많은 컨테이너 플랫폼이지만, 다른 기술도 있으며 컨테이너 기술로 인해 플랫폼에 락인될 걱정은 하지 않아도 된다. Docker는 이미지를 사용해 컨테이너를 실행한다. 이 때 이미지가 로컬에 있어야 한다. docker container run을 할 때에 없으면 docker pull을 받게 된다. 한 번 다운로드한 이미지는 재사용한다. 도커 컨테이너 Id는 컨테이너의 hostname이 된다. 컨테이너를 선택할 때, 이름 앞 몇글자만 입력해도 된다. 예: f1695...일 때, docker container top f1만 해도 된다. 실습솔루션 목표: 실행 중인 Apache 컨테이너에서 index.html을 변경하라. 힌트: 컨테이너는 독립된 파일 시스템을 가지며, 컨테이너 내의 웹 서버 또한 컨테이너의 파일 시스템의 파일을 제공한다. docker container 명령어를 통해 컨테이너에서 수행할 수 있는 명령어 목록을 볼 수 있다. docker {command} --help를 통해 해당 명령어의 상세 설명을 확인할 수 있다. diamol/ch02-hello-diamol-web 이미지는 /usr/local/apache2/htdocs 폴더 내의 파일을 정적으로 제공한다. (윈도우의 경우, C:\\user\\local\\apache2\\htdocs 폴더.) 내 풀이풀이 과정을 서술함. 1. 제공된 컨테이너 트러블 슈팅: 일단 ch02-hello-diamol-web 의 기본 포트인 8088은 접속할 수가 없었다. 그래서 DockerHub 가서 Apache 이미지를 받아서 실행해봤다. 8080 포트로 잘 되더라. 이 때 명령어가 $ docker run -dit --name my-apache-app -p 8080:80 -v &quot;$PWD&quot;:/usr/local/apache2/htdocs/ httpd:2.4 였는데, 배운 점: -dit: --detach --interactive의 약자인데, -dit가 필요한 이유를 보면, bash 스크립트가 엔트리 포인트인 경우 -d만 하면 정지된 상태에서 아무것도 못한다고 한다. -it를 줘서 셸이 있어야 스크립트가 실행된다고 한다. -p: --publish의 약자이다. -v: 아직 안 배웠지만, 볼륨 개념일 것으로 추정된다. 도커 자체의 네트워크 문제가 아님을 알고, 80으로 하니까 잘 됐는데, 이유는 모르겠다. 2. 컨테이너 셸 접속: 일단 docker container exec -it --tty {id} /bin/bash 로 접속할 순 있었다. (나오는건 exit 치면 된다.) --tty 옵션에 대한 글 참고 3. 직접 파일 수정: 무슨 망할 기반 이미지를 쓰는지 vi 밖에 지원을 하지 않아서 직접 수정은 포기했다. 파일을 복사해야 하는데, 어떻게 하는지 모르겠다. 4. 파일 복사 방법: Dockerfile을 수정하는 게 가장 쉬울 것 같았지만, 제공되지 않아서 할 수 없었다. 복사를 해야 하는데, 호스트에서 컨테이너로 파일 복사하기로 docker cp 명령어를 배워서 수행했고, 성공했다. 매우 작은 작업이었지만 너무 오랜 기간이 걸렸다. 아무래도 기록하면서 하니까 오래 걸리고, 책의 내용을 요약했음에도 불구하고 며칠만에 다시 보는거여서 오래 걸렸다. 많이 헤맨 덕분에, docker container ls, docker container rm, docker container exec, docker container run은 정말 많이 사용해서 다행이다. 참고 자료: Docker In A Month of Lunches (Manning, 2020) 추가로 읽을 것: Docker와 VM","link":"/docker-diamol-1-hello-world/"},{"title":"[1 Month Docker] 2. Dockerfile, Docker Image","text":"Dockerfile과 Docker Image 개념을 소개하고, 핵심적인 내용을 설명한다. Docker에 대한 간단한 소개의 내용을 기본으로 가정하고 시작한다. 저번 글에선 Container와 Docker를 체험해보았다. Container는 어떠한 스택의 애플리케이션이든 배포 측면에서 일관된 경험을 제공하므로 사용하는 것이 좋지 않을까 생각한다. Docker로 Container를 실행하려면 Docker Image가 필요한데, 이번 글에서는 최종적으로 Image를 직접 생성한다(공식적으로는 build 한다고 표현함.). 1. 기초 개념 설명1. Dockerfile: 이미지 빌드 명령어의 입력으로 들어가는 스크립트이다. 아래와 같은 내용을 담는다. 12345678910111213141516171819202122# Parent Image 지정# Dockerfile은 이미지를 정의하는 파일이다.# 새 이미지를 만들 때 다른 이미지의 내용에 기반해 덧씌우는 형태이다.FROM diamol/node# 환경 변수 3개 설정# Docker와 같이 컨테이너 환경으로 앱이 배포되는 경우,# 환경 변수를 arguments로 많이 활용한다.ENV TARGET=&quot;blog.sixeyed.com&quot;ENV METHOD=&quot;HEAD&quot;ENV INTERVAL=&quot;3000&quot;# Working Directory를 /web-ping으로 지정 (폴더 생성 후 이동함. mkdir &amp;&amp; cd)WORKDIR /web-ping# Host의 app.js 파일을, Working Directory(.)에 복사COPY app.js .# node로 다음의 js를 실행# CMD 명령어는 컨테이너 실행 시에 1회 수행되는# container.once('start', callback)과 같다.CMD [&quot;node&quot;, &quot;/web-ping/app.js&quot;] 아마 셸 스크립트에 익숙한 사람은 셸 스크립트와 다름 없다고 생각할 것이다. 맞다. 똑같다. 아마 셸 스크립트가 익숙하지 않으면 Dockerfile에 쉽게 친해질 순 없을텐데, 리눅스 환경 구성 기초 | T 아카데미나 리눅스 커맨드 라인 &amp; 쉘 스크립트 #1 | ABCD DevOps라는 좋은 자료가 있으니 참고하자. Dockerfile 안에서만 쓸 수 있는, Dockerfile에서 쓰일 만한, 명령어가 10개 정의돼있다. 이 명령어들이 주축이 돼서 Dockerfile의 내용을 구성하게 된다. 전체 기능에 대해서는 Dockerfile Cheat Sheet를 참고하라. 걔 중 유사한 명령어인 CMD vs RUN vs ENTRYPOINT를 정리한 글도 있으니 참고하기 바란다. Dockerfile 명령어는 대소문자를 구분하지 않지만 대문자로 쓰는 게 컨벤션이다. 2. Image: 이미지는 Dockerfile에서 기술한 내용이 실행된 모습을 스냅샷 형태로 담은 파일이다. 컨테이너 실행 시 이미지를 통해 Dockerfile에 정의된 내용이 그대로 재현된다. 3. Image 받아오기: 이미지를 직접 생성하지 않고, DockerHub 등의 Docker Registry (이미지 저장 서버)에서 받아올 수도 있다. 단순히 받아오기만 하는 명령어는 docker image pull 이다. docker image pull diamol/ch03-web-ping 을 실행해 DockerHub에서 이미지를 받자. 하나의 이미지를 받는데, 여러 Pull Complete가 표시돼있다. (나중에 설명한다.) 4. Image 빌드: docker image build 명령어를 실행하면, 이미지는 자동으로 빌드된다. 예: docker image build --tag web-ping . =&gt; web-ping이라는 이미지를 생성. (Mandatory) .은 Dockerfile 및 COPY 등에서 Host의 기준 디렉토리로 사용된다. (Mandatory) --tag는 이미지의 이름을 지정한다. 주의: 파일을 Windows -&gt; Linux로 복사하는 경우, 권한이 rwxrwx로 지정되는데, 이는 서로 권한 정보가 호환되지 않기 때문이다. 로컬에서 직접 빌드된 이미지는 도커 엔진에 캐시돼 보관된다. 새로운 버전을 빌드하려는 경우, --tag web-ping:v2와 같이 :으로 버전을 구분하여 명시하면 된다. 5. Image 실행(컨테이너로): docker container run {image_name}으로 실행 6. Image Layer: 이미지에는 생성 과정에 대한 메타데이터도 포함된다. 이미지 생성 과정을 통해 docker image history web-ping Docker Image는 Image Layer라는 더 작은 개념으로 구성되며, Dockerfile의 각 명령(CREATED BY) 마다 Layer가 생성된다. 이미지는 각 Layer의 논리적인 집합이다. Layer는 도커 엔진에 물리적인 파일의 형태로 캐시되는 단위이다. 이미지 간에 Layer가 공유되므로 전체 용량 부하를 낮출 수 있다. docker image ls로 논리적인 용량을 확인할 수 있지만, docker system df로 이미지가 차지하는 물리적인 용량을 확인할 수 있다. 이런 Image Layer 캐시를 활용하려면 조건이 필요한데: Layer 이전의 Layer 들의 내용과 순서가 바뀌지 않아야 한다. 이전 내용이 바뀌었는데, 이 명령(Layer)을 실행한 결과가 같음을 보장할 수 없다. 만약 내용을 바꾸는 경우, 이 Layer에 의존하고 있던 모든 이미지에 영향을 끼친다. 그러므로, 이전 Layer가 변경되는 경우, 이후 Layer는 캐시로 사용될 수 없게 되고, 새로 Layer를 생성하게 된다. 7. Layer 캐시 최적화 전략: Layer 캐시 활용을 통해 전체 용량과 이미지 빌드 시간을 줄일 수 있다. 이미지에서 변하지 않는 부분을 최대한 먼저 실행해 새로 빌드할 Layer 수를 줄인다. 캐시 사용 가능 여부는 Instruction의 내용과 Arguments(명령어 내용일 수도 있지만, COPY와 같은 경우 파일의 내용까지.)로 Hash 값을 만들고 비교하여 결정한다. Hash가 일치하는 경우 빌드하지 않고 도커 엔진에 캐시된 Layer를 사용한다. 일치하지 않는 경우, 해당 Layer부터 최종 Layer까지 새로 빌드한다. (뒷 Layer의 해시가 같아도, 재사용할 수 없다.) app.js 파일을 수정한 후 (nano app.js) 빌드한 모습이다. COPY app.js를 수행하는 step 6가 다시 Layer를 만듦을 확인할 수 있고, 이후 Layer인 step 7은 바뀐 내용이 없지만 앞 Layer가 바뀌어서 다시 만들어짐을 확인할 수 있다. 8. Layer 캐시 최적화 예시: 123456789101112131415FROM diamol/node# 시작 시 실행될 명령어를 지정하는 것이므로, 어디에 놓아도 상관 없다.# 캐시를 위해 앞에 놓는다.CMD [&quot;node&quot;, &quot;/web-ping/app.js&quot;]# 환경 변수 3개를 한 번에 등록해 Layer 개수를 줄였다.# 개수를 줄인 것과 캐시 최적화는 큰 연관은 없지만...ENV TARGET=&quot;blog.sixeyed.com&quot; \\ METHOD=&quot;HEAD&quot; \\ INTERVAL=&quot;3000&quot;WORKDIR /web-pingCOPY app.js . 이제 docker image build -t web-ping:v3를 실행해보자. 환경 변수 개수가 줄어들어 7단계에서 5단계로 줄었음을 확인할 수 있다. 이제부턴 app.js를 수정해도 마지막 Layer만 바뀐다. 2. 실습1. 목표: diamol/ch03-lab 폴더의 이미지에서 /diamol/ch03.txt 파일을 수정하고 새 Image를 생성하라. 이 때 Dockerfile을 수정해서는 안 된다. 2. 힌트: -it으로 컨테이너에 키보드 I/O 가능 컨테이너 파일 시스템이 Exit 상태에도 제거되지 않음을 활용 docker container --help로 모르는 명령어에 대해 공부할 것 3. 처음 생각한 접근 방법: Container에서 일단 파일을 수정한다. 컨테이너로 이미지를 생성해낸다. 명령어를 찾아보자. 4. 실제 수행 과정: 1. 일단 이미지를 빌드함 cd ../../lab (빌드를 위해 lab 폴더로 이동) docker build image -t ch03-lab . (빌드 성공) 2. 이제 컨테이너를 실행해야 함 docker container run ch03-lab (실패) docker container ls (없었음) cat Dockerfile (CMD 등 명령어 실행이 없고, COPY 뿐이었음) 3. 컨테이너에서 수행할 명령어로 주어 실행해야 함 docker container run ch03-lab /bin/bash (실패) docker container run ch03-lab /bin/sh (이미지에 bash가 없었음..) vi ch03.txt (텍스트 파일 수정) exit (sh 나옴) 4. 정지된 컨테이너를 이미지로 빌드해야 함 Docker Commit Reference를 참고해서 빌드 명령어 학습 docker container ls --all 로 종료된 컨테이너 ID 확인 (67a) docker image commit 67a ch03-lab:v2 (무슨 해시값이 출력됨..) docker image ls (v2로 생성됨을 확인) docker container run ch03-lab:v2 cat ch03.txt (파일 갱신됨을 확인) 끝! Lab 하면서 배운 점: docker commit 명령어로 컨테이너 내용으로 이미지를 빌드할 수 있다는 점. 다만 이렇게 되면 Dockerfile은 없는게 아닌가? docker container run {IMAGE} {COMMAND}로 명령어를 실행할 수 있음 다만 이는 이미지에서 수행하는 명령어가 없는 경우에 한한 것 같고, docker container exec으로 셸을 띄우는 것이 일반적인 것 같다. TO DO: 컨테이너에서 Commit으로 생성한 이미지에서 Dockerfile을 추출할 수 있을지 확인해보기","link":"/docker-diamol-2-dockerfile-image/"},{"title":"Express를 사용해야 할 이유 (1)","text":"잠시나마 사용해본 Express는 내게 React 같았다. 무엇이든 할 수 있어 보였으나 직접 하기에는 매우 불편하고, 그러다보니 REST API를 작성할 때 이런 것까지 해야 돼? 혹은 이런 기능이 없어서 불편하네 등이 많았는데 이번에 알아보려고 한다. 얼마나 많이 Express를 사용하며, 왜 Express를 사용하는지 팩트 위주로 체크해봤다. 1. Node와 Express의 장점을 헷갈리면 안 된다.대부분의 웹사이트에서 소개하는 Express의 장점들은 Javascript, Node.js의 장점들이었다. 많은 글을 읽어보아도 Express의 장점을 소개하는 글은 많이 없었고 대부분 Node.js의 장점을 소개하고 있었다. Express가 Node 기반인 게 큰 장점이라는 걸까… 그래서 Node.js와 같은 목적으로 생성된 프레임워크/런타임을 조사해보았다. 2. Reactor Pattern을 구현한 프레임워크/런타임A. 역시 Node.js만 있는 것은 아니었다. Javascript를 깊게 배우고 생태계를 옮겨 탈 바에 기존에 사용하던 언어로 작업하는 게 현실적이긴하다. Lang Sync Framework Async Framework Java Spring Web MVC Spring WebFlux (Reactor Pattern), Vert.x (JVM 기반) Python Flask, Django FastAPI, Tornado, Sanic, … (꽤 많다.) Javascript - * 다른 언어에 대해선 찾아보지 않았지만 Java, Python이 점유율이 큰 언어들이므로 충분하다고 생각한다. 벤치마크를 찾아보진 않았지만 같은 패턴을 기반으로 제작됐기 때문에 실제 서비스로 구현했을 땐 성능 면에서도 비슷할 것으로 예상된다. 다만 Node.js의 장점이라면, 선천적으로 비동기 API가 장려되어왔기 때문에 비동기 API로 작성된 라이브러리 활용 면에서 낫지 않을까 생각한다. 출처: 대용량 트래픽을 감당하기 위한 Spring Webflux 도입, Spring Webflux는 어떻게 적은 리소스로 많은 트래픽을 감당할까 3. Node.js 백엔드 프레임워크 간의 점유율/만족도 비교제대로 비교하기 전에 통계 자료부터 확인하자. 참고로 Next.js는 SSR 용 백엔드(SSR, Code Splitting 자동)라고 생각하면 된다. 점유율 요약 (아래 그림): Express의 점유율이 압도적이다. Koa, Hapi 라는 네임드의 점유율이 꽤 낮다. 서비스 개발에 가장 유리할 거라고 생각했던 Nest.js의 점유율이 13%밖에 안돼서 의문이다. Hapi Koa Nest Express 물론 Express를 기반으로 하는 다른 프레임워크 등이 어느 정도 반영됐을 것이긴 하다. Nest도 처음에는 Express 기반이었으니까. 그래도 다운로드 수의 큰 차이를 보면 나머지 프레임워크의 시장성이 의심되긴 한다. 만족도 비교 (아래 그림): Express는 점유율에 이어 만족도도 최상위권이다. Nest.js가 5% point 정도의 차이가 있지만 준수한 편이다. Koa의 만족도가 76%인 점인 이유는 장점이었던 동기식 코딩 방식인 async-await이 표준화됐기 때문임으로 보인다. Hapi는 만족도가 매우 낮은 것으로 보아 사용할 수 없겠다는 생각이 들었다. (추후 조사를 해봐야겠다.) 출처: 2020 State Of JS (한국어 번역) 4. 왜 이렇게 Express를 많이 쓰는 걸까? 정말 Express가 좋은걸까? 다른 언어의 프레임워크를 비교해봤을 때 솔직히 좋다고 하진 못 할것 같다. 1. 단순함 (+0)정말 많은 블로그에서 Express의 최장점을 단순함으로 꼽고 있었는데 장점보다는 목적에 가까운 것이라 생각한다. 목표에 따라 단순함은 장점이 될 수도, 단점이 될 수도 있기 때문이다. 단순함을 장점으로 꼽는 경우 둘 중 하나이다. Rich Framework를 감당할 만큼 숙련된 개발자로 채우기 어려운 조직이거나 애초에 큰 규모의 서비스를 작성하기 위해 Express를 사용하지 않거나 만약 서비스 개발을 위해 Express를 사용한다면 단순함은 직접적인 단점이 된다. 기본적인 의존성만 담은 Boilerplate(1.4k stars)만 보더라도 같이 깔아야 할 라이브러리들이 많아 학습 곡선이 가팔라진다. 처음 입문하는 경우 미들웨어들을 직접 찾는 추가적인 일을 하게 된다. (한 프레임워크 내에서 찾는 것과 대조적.) Rich Framework 들에 비해 설계를 너무 근본적인 것들부터 해야 해 오히려 설계 측면에선 난도가 높다. (DI/IOC가 없고 여러 라이브러리를 비교 분석 후 사용해야 함.) 다만 적절한 Boilerplate를 찾으면 이 문제가 어느 정도 해소된다는 점과 이후 단락에서 소개할 내용들을 통해 단순함의 단점을 상쇄할 수 있다. Node.js는 출시 후 아직까지도 작은 서비스를 만드는 데 적합하다는, 프로토 타이핑 위주라는 인식이 남아 있는 것 같고, 그런 용도로 채택하여 단순함이 종종 장점이 되는 것 같기도 하다. 2. Express Middleware (+0)어떤 언어, 프레임워크로 웹 개발을 하더라도 Express에 미들웨어에 해당하는 계층에서 확장성을 가져가는 것은 기본이지 특별한 기능은 아니다. 또한 Express에서 제공하던 자체 Middleware들은 모두 Connect 미들웨어 라이브러리로 옮겨갔다. Next.js에서는 이 미들웨어들을 지원하는데, 그럼 다른 프레임워크에서도 의도하기만 하면 재사용 할 수 있는 셈이다. (의존성이 req, res, next 인자 밖에 없으니.) 3. Community (+3)Express는 꽤 많은 사용자 풀을 보유하고 있다. 이미 사용자가 많아 검색을 통한 문제 해결이 비교적 원활하다. 아래는 StackOverFlow 트렌드인데 koa(js), hapi(js)는 태그로 잡히지도 않아서 비교가 불가능했다. 이는 생태계 조성이 거의 전무하다는 뜻인데 koa나 hapi는 출시된 지 시간이 지났음에도 이정도이며 특히 Hapi는 정말 작은 사용자 풀을 보여준다(사용하지 마세요). 4. Async-await을 workaround로 쓸 수 있다. (+1)Express v5 부터는 Response Handler 및 Middleware에서 async/await을 사용할 수 있지만 아직 Release 되지 않은 관계로 사용할 수는 없다. Express QnA 이슈의 답변이다. Q. How to use async/await in express 5? A: There is one main difference between v4 and v5 when it comes to async/await and promises in general. In v5, if you return a promise from a response handler (or middleware), if that promise rejects and is not handled elsewhere, then Express will handle the error. It handles the rejection by passing the rejection reason to next for you. v4에서도 async-await을 쓸 수 있는데, 아주 간단한 미들웨어 express-async-handler로 한 번 감싸주면 된다. (원리는 이 설명 참고) (같은 원리로 Promise도 처리 가능) 12345678910111213// find a user by idrouter.get( '/:id', asyncHandler(async (req, res) =&gt; { if (req.user.id === req.params.id) { return res.status(403).send(FORBIDDEN); } const user = await UserRepository.findUserById(req.params.id); if (!user) return res.status(404).send(NOT_FOUND); res.json(user); }),); 5. Koa나 Express나 둘 다 개발은 하지 않는다. (+0)Koa나 Express나 발전을 멈춘지 좀 됐다. Koa의 Roadmap 3.0을 보면 현재 모습이 Koa의 완성형이라고 생각할 수 있다. 17년도 이후로 유지보수가 대부분 Documentation에 치중되어 있다. KoaJS는 2013년에 시작해 제너레이터 기반으로 미들웨어를 쉽게 작성하기 위해 나온 프레임워크인데, async-await 표준이 2017년 초부터 Node.js에서 공식적으로 지원되면서 그 의미가 퇴색되지 않았나 생각이 든다. Express 역시 Documentation 위주의 유지보수, v5를 6-7년 째 안 내고 있긴 하다. (14, 15년도 쯤까지만 일한듯) Is express dying? Release v5 Router 모듈 (Express가 라우팅 관련 책임을 이 모듈로 넘긴 듯하다.) (얘도 유지보수가 죽었고.) Node.js Foundation to Add Express to its Incubator Program 16년 초에 Express 소유권이 넘어갔다고 한다.(인과관계는 잘x) 5. 서비스 개발 측면에선 NestJs가 더 낫지 않을까? (추후 보강 예정)Express, Koa는 현재 사실상 유지보수가 되고 있지 않다. 프로젝트에서 돈을 벌지 못하기 때문인 것으로 보이는데, 기업 스폰서가 없으며 프레임워크도 간단해 기술 지원이 불가능해 수익 모델이 없다. (Hapi는 Walmart에서 사용 중이긴 하지만 너무 마이너하다. 왜 인기가 없을까?) NestJS는 구조가 Angular의 영향을 받았다고 돼있지만 Spring과 유사한 구조와 개발자 경험을 제공한다고 생각하며, Spring은 그 기능과 복잡성을 통해 기술 지원으로 돈을 벌고 있기 때문에 NestJS가 이 모델을 구현한다면 긴 시간 유지보수를 해나갈 수 있을 것 같다. 정확히 무슨 벤치마크를 했는진 모르겠지만 성능 측면에서 NestJs-Fasitfy[현재 버전]가 Express보다 낫다고 한다. (출처) Framework Req/sec Trans/sec Req/sec DIFF Trans/sec DIFF Nest-Express 15370 3.17MB +4.38% +4.23% Nest-Fastify 30001 4.38MB +2.20% +2.23% Express 17208 3.53MB +8.38% +8.31% Fastify 33578 4.87MB +6.55% +6.53% NestJS에 대해선 추후 더 조사하려고 한다. TODO1. NestJSNestJS는 다루는 양이 방대하기도 하고 앞의 리서치에서 시간을 너무 많이 사용해서 따로 시간을 내서 리서치하진 못 해서 다음 기회에 꼭 하도록 한다. 2. Fasify한 번 조사해봐야 할 것 같다. async-await도 지원하며 제대로 관리되고 있는 것 같다. 아래는 README에 게시된 벤치마크인데 성능도 역시 좋고. Framework Version Router? Requests/sec Express 4.17.1 ✓ 15,978 hapi 19.1.0 ✓ 45,815 Restify 8.5.1 ✓ 49,279 Koa 2.13.0 ✗ 54,848 Fastify 3.0.0 ✓ 78,956 - http.Server 12.18.2 ✗ 70,380 3. HapiJSHapi도 개발이 계속 진행 중이고 Nest처럼 Rich한 Framework를 목표로 하는 것 같고, Walmart에서 실제로 사용하면서 주도적으로 개발하다가 작년 중순부터 Community-driven으로 간다고 한다. 성장 가능성이 꽤 있는 것 같아서 시간이 나면 조사하면 좋을 것 같다. Facebook이 React를 만들어 프론트엔드 생태계를 많이 바꿔낸 것처럼. 4. Express In Action (2016)이 책을 좀 더 읽어보고 Express의 가치를 발견하다면 정말 좋을 것 같다. 5. 기타Promise, Async-await이 성능이 CPS 패턴에 비해 느리다는 의견이 종종 나왔는데 왜 그런지 확인해보기 D2에서 Node.js는 Socket.IO 때문에 떴다고 하던데 정말인지 확인해보기","link":"/ejs-1-why-express/"},{"title":"실행 결과를 재사용하는 함수 skip","text":"사용 예시12345&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;Item 1&lt;button&gt;삭제&lt;/button&gt;&lt;/li&gt; &lt;li&gt;Item 2&lt;button&gt;삭제&lt;/button&gt;&lt;/li&gt; &lt;li&gt;Item 3&lt;button&gt;삭제&lt;/button&gt;&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617const askOnRemove = skip(() =&gt; confirm( '정말 삭제하시겠습니까? 최초 1회만 확인합니다.', ),);const list = document.getElementById('list');list.addEventListener('click', (e) =&gt; { const { nodeName, parentNode: targetItem, } = e.target; const { parentNode } = targetItem; nodeName === 'BUTTON' &amp;&amp; askOnRemove() &amp;&amp; parentNode.removeChild(targetItem);}); 함수 본문123456function skip(callback) { let result; // 클로저 영역 return function (...args) { return result || (result = callback(...args)); };} 함수 본문 해설함수 skip은 callback를 받아 실행하고, 만약 그 함수의 반환값이 truthy이면 해당 값을 반환하고, 이후에는 함수를 실행하지 않는다. 함수형 프로그래밍과의 연관성 함수형 자바스크립트는 함수를 N 단계로 조합해서 사용한다. 즉, 고차 함수 응용의 반복이다. skip은 고차 함수이고, callback은 skip이 남겨 놓은 로직을 완성하는 함수다. 예시로 사용된 askOnRemove는 클로저인데, 함수로 만들어진 함수는 대부분 클로저다. 고차 함수란?함수를 인수로 사용하거나 함수를 반환하는 함수이다. 예시: const filter = (predicate, xs) =&gt; xs.filter(predicate) // 함수가 인자 const is = (type) =&gt; (x) =&gt; Object(x) instanceof type // 함수를 반환 filter(is(Number), [0, '1', 2, null]) // [0, 2]","link":"/fjs-1-skip/"},{"title":"함수를 부분 실행하는 currying 개념","text":"사용 예시 112345678&lt;Field name=&quot;username&quot; onChange={handleChange('username')}/&gt;&lt;Field name=&quot;password&quot; onChange={handleChange('password')}/&gt; 함수 본문 1123const handleChange = (fieldName) =&gt; (value) =&gt; { fields[fieldName].value = value;}; 함수 본문 1 해설함수 handleChange는 fieldName를 받아 새로운 함수를 반환한다. 반환한 함수에 value를 전달하는 경우, fields 객체에서 fieldName에 해당하는 프로퍼티에 value를 전달받은 value로 갱신한다. 사용 예시 2123456const createForm = createElHtml('form');const createInput = createElHtml('input');const form = createForm();const idInput = createInput('name=&quot;username&quot;');form.innerHTML = idInput; 함수 본문 21234const createElHtml = (tag) =&gt; ( arrtibutes = '', children = '',) =&gt; `&lt;${tag} ${arrtibutes}&gt;${children}&lt;/${tag}&gt;`; 사용 예시 31234567891011121314151617const toBoolean = (x) =&gt; !!x;const double = (n) =&gt; n * 2;const toNumber = (str) =&gt; Number.parseInt(str, 10);const composedFunction = compose( toBoolean, double, toNumber,); // toNumber -&gt; double -&gt; toBoolean 순으로 실행된다.// 매개변수는 composedFunction에 전달된 것부터// 각 함수의 반환값이 다음 함수의 매개변수가 된다.composedFunction('0'); // falsecomposedFunction(''); // falsecomposedFunction(); // falsecomposedFunction('hello'); // falsecomposedFunction('2'); // true 함수 본문 31234const compose = (...functions) =&gt; [...functions].reduce((f, g) =&gt; (...args) =&gt; f(g(...args)), ); 함수 본문 3 해설 compose(f,g,h)(1) =&gt; f(g(h(1)))의 형태로 실행한다. compose 내부에선 functions를 배열에 넣어 reduce를 호출한다. Array.reduce는 (result, currentvalue) =&gt; result; 이다. reduce에게 (f, g) =&gt; (...args) =&gt; f(g(...args))를 인자로 넘겨준다. 단계별 흐름도 (f, g) =&gt; (...args) =&gt; f(g(...args)) // f, g ((...args) =&gt; f(g(...args)), h) =&gt; ((...args) =&gt; f(g(h(...args)))) // f,g 합성함수, h 함수 함수형 프로그래밍과의 연관성 currying은 함수를 인자로 받게 만들 수도 있고, 함수가 아닌 값을 받게 만들 수도 있다. 두 방법 모두 유용하다. currying은 마지막으로 반환되는 경우를 제외하면 대부분 계속해서 함수를 반환한다. 이는 함수간의 조합이 쉽다. 참고 JavaScript ES6 curry functions with practical examples (EN) Learning Javascript Courses: ES6 Curry (EN) What is the advantage of currying? (EN)","link":"/fjs-2-currying/"},{"title":"함수형 자바스크립트 기본","text":"함수형 패러다임을 자바스크립트에 적용할 때에 알면 좋은 Javascript의 기본 문법과 배경 지식을 설명한 글이다. 자바스크립트와 타 언어들간의 함수형 프로그래밍 지원의 차이Javascript에는 없는 함수형 언어의 특징 순수 함수 강제 (side effect를 발생시키는 표현식을 허용하지 않음) 불변성 강제 (변수라고 부르지만, 상수. 객체까지도.) 재귀 강제 (반복문 미지원) 아무래도 Javascript는 멀티 패러다임이라 함수형 패러다임만 지원하는 언어에 비해서는 제약이 덜할 수 밖에 없을 것이다. Javascript에서 이를 극복하는 방법 eslint 규칙 사용으로 부분적으로 극복. ImmerJS 등의 라이브러리 도입 함수형 프로그래밍에 익숙해진다면, 괜찮을 것. (1과 마찬가지로 eslint 규칙 도입 등.) Javascript 런타임들이 대부분 꼬리 재귀 호출 최적화를 지원하지 않기 때문에, 재귀가 타 함수형 언어에 비해 성능이 낮을 수 밖에 없다. 꼬리 재귀 호출 최적화는 재귀 호출이 함수의 마지막에서 발생하는 경우에 적용된다. 컴파일러가 자동으로 재귀를 반복문으로 치환한다. 덕분에 스택 프레임을 1개만 사용한다. Javascript의 장점 다른 모든 함수형 언어는 학습 곡선이 높다. 누구나 이해하고 사용할 수 있다고 하기 힘들다. ES6+부터 함수형 지원이 좋은 편이다. 타 함수형 언어들에 비해 시장이 크고, Production-level Application 구축이 용이하다. 함수 실행(call, apply)과 인자(arguments), 점(.) 다시 보기Javascript의 함수 안에서는 arguments 객체와 this 키워드를 사용할 수 있다. ※ 화살표 함수에서는 arguments를 사용할 수 없다. 123Uncaught ReferenceError: arguments is not defined at hi (&lt;anonymous&gt;:1:37) at &lt;anonymous&gt;:1:1 arguments 객체배열과 유사한 Arguments 객체(Arguments(4) [ ‘a’, ‘b’, ‘c’, ‘d’, … ])로 매개변수들이 전달된다. arguments에 접근하는 시점에 따라 값이 변경될 수 있다. Javascript의 parameter는 변경할 수 있기 때문에, 이를 변경 후 arguments를 찍어보면 다르게 나온다. 12345function hello(a, b) { a = 1; console.log(arguments);}hello('a', 'b'); // Arguments [1, 'b']; this 객체obj.prop()으로 호출 시 obj가 this가 된다. . 좌측의 객체가 항상 this가 된다. 최상단 scope에서 호출하면 기본적으로 window., global.이 생략된 것이기 때문에 this가 window, global이 된다. (global은 Node.js 환경에서.) const { prop } = obj; prop(); 하면 prop이 obj에 속해있음에도 불구하고 this가 window, global이 된다. Function.prototype.callthis 객체를 지정해서 함수를 호출할 수 있다. 12345678const obj = { thisIs: 'obj',};function hello(a, b) { console.log(this);}// 매개변수는 가변 매개변수여서 개수 제한 없이 전달 가능하다.hello.call(obj, 'a', 'b'); // { thisIs: &quot;obj&quot; } Function.prototype.applycall과 다른 점은 매개변수를 배열과 유사한 객체로 넘겨야 한다는 점이다. 12345678910111213const obj = { thisIs: 'obj',};function hello(a, b) { console.log(this);}// 매개변수는 배열과 같은 객체로 전달하면 된다.hello.apply(obj, ['a', 'b']); // { thisIs: &quot;obj&quot; }hello.apply(obj, { 0: 'a', 1: 'b', length: 2,}); // { thisIs: &quot;obj&quot; }","link":"/fjs-3-functional-js-basics/"},{"title":"순수함수와 curry 함수","text":"이번 글은 쉽다(?). 순수함수에 대해 이론적으로 다루고, curry 함수를 소개한다. 다만 객체지향과의 비교, 테스트와 설계에 대한 내 생각을 공유하므로 지식이 없으면 어렵게 보일 수도 있다. 순수함수?순수함수는 수학에서 정의하는 함수와 동일하다. 입력에 대한 출력이 항상 동일하고, 입력에 대한 출력이 항상 1가지이다. 이게 가능하기 위해선 DB, HTTP, 현재 시간 등에 의존하면 안 된다! 함수 외부의 것과 함수 내용이 전혀 연관이 없어야 한다. 부원인과 부작용영어권에서 흔히 side-effects라고 얘기하는 부수효과나 부작용은 함수 밖의 코드의 상태에 영향을 주는 일을 말한다. 부수효과를 크게 부작용과 부원인으로 구분할 수 있다. 부작용은 숨겨진 출력이고, 부원인은 숨겨진 입력이라고 생각하면 된다. 왜 외부의 상태와 상호작용하면 안 될까? 궁금하면 계속 읽어야 된다. 숨겨진 입력숨겨진 입력이라고 하면 뭐가 있을까? Javascript와 같이 객체지향 패러다임을 지원하는 언어의 경우는 this가 항상 함수에 전달된다. this도 숨겨진 입력이다. 또한 함수 내부에서 new Date() 등의 코드로 현재 시간에 의존하는 경우도 숨겨진 입력이라고 할 수 있다. 둘 모두 외부의 상태를 변경하기 때문이다. 숨겨진 출력숨겨진 출력은 함수를 실행했을 때 바뀌는 모든 것이라고 할 수 있다. 순수함수 내에서는 어떤 외부의 상태도 변할 수 없으므로, 어떤 외부의 상태가 조금이라도 변경된다면 그 함수는 순수하다고 할 수 없다. 부수효과는 복잡성 빙산왜 외부의 상태와 상호작용하면 안 될까? 순수함수가 아닌 함수의 Signature는 프로그래머가 읽더라도, 심지어 객체지향 언어의 설계 방식대로 설계했더라도 무슨 부수효과가 일어날지 알 수 없다. 캡슐화는 좋은 규칙이지만 그 구현 코드를 읽기 전까지 부수 효과를 정확히 알 순 없다. 부수효과가 왜 복잡성 빙산일까? 프로그래머가 예상한 그대로 동작하지 않는 경우 논리적 버그의 원인이 되기 때문이다. 부수 효과는 해당 코드 혹은 해당 코드와 간접적으로 연관이 있는 코드를 수정했을 때 바뀌기 또한 쉽고, 바뀌었을 때 작동하지 않게 될 확률도 높다. 그래서 객체지향 방식으로 설계를 하는 경우 회귀테스트를 그렇게 많이 작성해야 하나 보다. 응집성과 캡슐화를 생각해서 상태 의존적이고, 변경 시 서로의 영향을 받아서 깨지기 쉽기 때문이다. 그래서 함수형 패러다임에서는 공유 자체를 하지 않는 방향으로 설계하도록 지향한다. 그 결과가 순수함수이다. 순수함수가 아니면 테스트하기 힘들다어떤 함수가 부수효과가 있는 경우 이미 그 함수는 다른 코드랑 최소한 1번은 엮여 있을 수 밖에 없다. 덕분에 그 함수를 테스트하기 위해서는 다른 코드까지 테스트할 수 밖에 없고, 이 과정에서 Blackbox Testing이 불가능해진다. 구현 상세에 외부 코드와의 연관이 존재하기 때문이다. 이 과정은 객체지향 언어로 작성한 경우 자주 발생하며 덕분에 Mock을 자주 사용하게 된다. 또한 테스트 자체도 구현 상세의 변경에 취약하게 된다. 부수효과를 제거하기, 제거했을 때의 장점부수효과를 제거하려면 순수함수를 만들고 사용하면 된다. 모든 부작용, 부원인은 숨겨진것이기에 이를 Signature에 명시하면 된다. 이렇게 명시하는 것은 객체지향 언어에서는 응집성과 캡슐화를 위해 구현 상세로 분류하여 함수 안에 전부 집어넣는 등 지양하는 편이지만, 함수형 패러다임에서는 권장된다. 덕분에 덜 복잡해지고, 훨씬 테스트하기 쉬워지며, 추론이 훨씬 쉬워지기 때문이다. 부수효과를 완전히 제거할 수는 없다.아무래도 웹 등 실세계의 애플리케이션은 함수 내의 수식을 한 번 계산하고 종료하는 게 목적이 아니라, 부수효과로 불리는 것들 대부분을 사용하여 목적을 달성할 수 밖에 없다. 함수형 패러다임은 이런 한계를 인정하고, 가능한 모든 곳에서 부수효과를 제거하고, 제거할 수 없을 땐 강력히 통제한다. 순수함수의 조합과 재사용성순수함수는 그 자체의 명료함 덕분에 재사용성과 조합이 굉장히 쉽고, 많이 조합하더라도 쉽게 그 결과가 예측 가능하다. 특히 한 번에 풀 수 없는 크고 복잡한 문제를 쪼개서 작은 함수의 조합으로 해결할 수 있다. 앞서 만들어 놓은 산출물을 쉽게 조합하여 새로운 문제를 해결할 수 있게 되고, 생산성도 비약적으로 늘어난다. 순수함수에 대한 간단한 사실들 순수함수는 수학의 함수와 동일한 정의를 갖는다. 순수함수는 (input, output) 쌍이므로 객체로도 표현 가능하다. (key,value 쌍) 순수함수는 항상 캐시 가능하다. 순수함수는 필요한 건 다 전달받는다(dependency injection) 동시성 문제가 적거나 없다. 공유하는 메모리가 없기 때문이다. curry 함수2번째 글에서 currying을 이미 다루었다. 그 때의 currying은 프로그래머가 함수에 대해 직접 curry한 방식이고, 이번에는 어떤 함수에 대해 알아서 curry된 함수를 반환하는 함수를 소개한다. curry 함수는 함수를 받아, 인자가 완전히 전달되지 않은 경우 남은 인자를 받을 함수를 반환한다. curry 함수의 구현은 function.length와 bind, apply를 사용하는 게 핵심이다. 1234567891011function curry(f) { const len = f.length; return function $curry() { if (arguments.length &lt; len) { // 원래 함수의 매개변수의 갯수보다 $curry에 전달된 매개변수의 갯수가 작은 경우. return $curry.bind(null, ...arguments); // $curry에 계속 전달받은 매개변수들이 bind 된다. (arguments가 계속 쌓인다.) } else { return f.apply(null, arguments); // 실제 함수 호출. } };} 12345678910// 예시const add = (a, b, c) =&gt; a + b + c;const addC = curry(add);const add1 = addC(1);const add1and2 = add1(2);const add1and2and3 = add1and2(3);console.log(addC(1, 2)); // function $curryconsole.log(add1(2)); // function $curryconsole.log(add1and2and3); // 6console.log(add1and2(3) === add1and2and3); // true 참고ES6 bind 함수 (KO)","link":"/fjs-4-pure-functions-and-curry/"},{"title":"함수형 패러다임의 꽃: 함수 합성(composition)","text":"함수형 패러다임에서 최우선 설계 원칙으로 삼아진다고 하는 함수들의 합성에 대해서 설명한다. 합성이전에 설명했던 compose 함수를 말한다. 1234const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)), ); 합성은 왜 하는걸까?프로그램을 간결하고 실용적으로 작성할 수 있게 한다. 합성이 되므로 함수를 부담 없이 나눌 수 있게 되어 더 작고 의미있는 단위의 함수를 더 편하게 작성할 수 있다. 이렇게 합성된 함수는 가독성이 좋다. 아무래도 객체지향 패러다임을 강하게 지원하는 언어들에선 함수 합성이 쉽지 않다. 애초에 순수 함수를 작성하기도 쉽지 않다. public static으로 도배할 순 없기 때문이다. 합성함수의 결합법칙함수 합성은 수학에서의 합성함수와 같이 결합법칙이 성립한다. compose(f, compose(g, h)) === compose(compose(f, g), h)가 성립한다. Javascript 상에서 생성되는 함수가 동일하다는 것이 아니라, 그 실행 결과가 언제나 같다는 뜻이다. 결합법칙이 무슨 소용일까합성한 함수들을 재귀적으로 합성한 경우, 결합법칙을 적용하면 결과 예측과 리팩토링 시에 유용하다. 그 예로, 아래 세가지 loudLastUpper 함수는 동일하다. 더 작고 더 의미있는 함수로 정의할수록 재사용성과 가독성은 높아진다. 버전 1 123456const loudLastUpper = compose( exclaim, toUpperCase, head, reverse,); 버전 2 (리팩토링) 123456const last = compose(head, reverse);const loudLastUpper = compose( exclaim, toUpperCase, last,); 버전 3 (리팩토링) 123const last = compose(head, reverse);const angry = compose(exclaim, toUpperCase);const loudLastUpper = compose(angry, last); 쓸모있고 재미있는 디버깅 방법합성 함수를 디버깅하는 재밌는 방법이 있다. 흔히 trace라 부르는 유명한 함수인데, 항등함수(const pass = x =&gt; x;)에 console.log만 추가한 함수이다. 123456789101112131415161718192021const trace = (tag) =&gt; (x) =&gt; { console.log(tag, x); return x;};// 자동 커리const trace = curry((tag, x) =&gt; { console.log(tag, x); return x;});// 사용 예시const toDebug = compose( replace, trace('after A'), applyA, trace('after B'), applyB, trace('after last'), last,); 당연하게도 trace 함수는 순수하지 않다. console를 사용하기 때문이다. 간단한 함수 합성 예제이하의 예제 코드는 아래의 cars 객체를 대상으로 한다. 123456789[ { name: 'Aston Martin One-77', horsepower: 750, dollar_value: 1850000, in_stock: true, }, //...]; 예제 1각 함수들의 정의는 이 문서를 참고하라. 이 문서는 ramdajs documentation과도 호환된다. 12345678910const isLastInStock = (cars) =&gt; { const lastCar = last(cars); return prop('in_stock', lastCar);};// after compose:const isLastInStock = compose( prop('in_stock'), last,); 예제 212345678910111213141516const average = (xs) =&gt; reduce(add, 0, xs) / xs.length;const averageDollarValue = (cars) =&gt; { const dollarValues = map( (c) =&gt; c.dollar_value, cars, ); return average(dollarValues);};// after compose:const averageDollarValue = compose( average, map(prop('dollar_value')),); 예제 312345678910111213const fastestCar = (cars) =&gt; { const sorted = sortBy((car) =&gt; car.horsepower); const fastest = last(sorted); return concat(fastest.name, ' is the fastest');};// after compose:const fastestCar = compose( append(' is the fastest'), prop('name'), last, sortBy(prop('horsepower')),); 함수 합성 예제 프로그램스펙 검색어에 대응하는 URL을 생성한다. flicker API를 호출한다. 결과 JSON에서 이미지 링크를 추출한다. 이미지를 HTML에 표시한다. 구현 코드예제의 스펙에서 보았듯, 2단계 API 호출과 4단계 이미지 표시는 순수하지 않다. 일단 순수하지 않은 함수를 같이 사용하면서 예제를 구현한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 유틸 함수 선언const prop = curry((p, obj) =&gt; obj[p]);// 순수하지 않은 함수// Impure 객체로 접근하도록 하여 사용자에게 주의를 준다.const Impure = { getJSON: curry((callback, url) =&gt; $.getJSON(url, callback), ), setHtml: curry((sel, html) =&gt; $(sel).html(html), ),};/* 참고: 서버의 응답이 아래와 같은 형태로 구성됨 { ... items: [ { ... media: { m: '&lt;image-link&gt;' } }, { ... }, { ... }, ] }*/const host = 'api.flicker.com';const path = '/services/feeds/photos-public.gne';const query = (t) =&gt; `?tags=${t}&amp;format=json&amp;jsoncallback=?`;const url = (t) =&gt; `https://${host}${path}${query(t)}`;const mediaUrl = compose( prop('m'), prop('media'),);const mediaUrls = compose( map(mediaUrl), prop('items'),);const img = (src) =&gt; `&lt;img src=&quot;${src}&quot; /&gt;`;const render = compose( Impure.setHtml('#root'), map(img), mediaUrls,);const app = compose(Impure.getJSON(render), url);app('cat'); compose와 map 리팩토링아주 간단한 리팩토링이다. 같은 배열에 대해 map을 여러 번 실행하기보다, 순서를 유지한 채로 매 원소에 대해 map할 함수를 합성해서 한 번에 실행하게 되면 반복 횟수를 줄일 수 있다. 1234// fromcompose(map(img), map(mediaUrl));// tocompose(map(compose(img, mediaUrl))); 참고mostly-adequate-guide (EN)","link":"/fjs-5-composition/"},{"title":"Async Functions in Javascript 1","text":"이 글은 자바스크립트에서 비동기를 다룰 때 마주치는 개념들인 Promise, Generator, Async-Await을 큰 범위에서 다룬다. 중간 중간에 재밌는 패턴들도 수록했다. Why Promise? What’s Promise?Promise는 순차적인 비동기 코드를 깔끔하게 짤 수 있게 하는 문법이다. 문법에 포함된 Promise 객체로 처리한다. Promise로 거의 모든 비동기를 처리한다고 해도 과언이 아니다. Promise가 익숙하지 않다면 MDN을 참고:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise &gt; https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises 비동기 작업 시 순차적인 흐름을 많이 구현해야 하는데, CPS 방식으론 간결하게 짤 수 없다. CPS 패턴 사용 시의 Tip | JSQnA 참고. Promise의 장점: (콜백과 관련한 비교에 대한 내용은 CPS 패턴 참고.) 프로미스 체인을 사용하면 작업들을 순차 실행시키는 일은 그리 어렵지 않다. throw를 프로미스 체인에서 사용할 수 있다. catch 될 때까지 전체 체인에 오류를 자동으로 전파할 수 있다. 비동기 오류가 누락될 확률이 줄어든다. 동기적으로 값을 반환해도 비동기적인 호출을 보장한다. 함수가 동기, 비동기 반환을 섞어서 하는 것은 나쁘다. Promise.all 함수를 통해 비동기 작업을 병렬로 실행할 수 있다. (이건 CPS도 가능) Promise.race 함수를 통해 비동기 작업 중 가장 먼저 수행이 끝난 결과만 사용할 수 있다. (CPS에선 직접 구현해야 함.) Promise로 함수 배열을 순차적으로 실행하는 패턴 (현재 이해 부족으로 인해 수정 필요함.): 책에 재밌는 코드가 있어 가져왔다. Promise로 함수의 배열을 순차적으로 실행하는 방법이 있을까? 12345678910111213// sequential :: Array(() =&gt; Promise) =&gt; Promisefunction sequential(tasks) { // 빈 값을 반환하는 Promise를 생성한다. let promise = Promise.resolve(); tasks.forEach((task) =&gt; { // promise에 then으로 체인을 걸고, // 다음 순번의 '이전 작업'이 되기 위해 promise 변수로 할당한다. // UPDATE: task는 Promise를 반환하는 함수여야 한다. promise = promise.then(task); }); // 최종 Promise를 반환한다. return promise;} reduce로도 가능하다: 1234567891011const tasks = [ /* ... */];let promise = tasks.reduce( (prev, task) =&gt; prev.then(task), Promise.resolve(),);promise.then((result) =&gt; { // TODO: retreive result}); 제한된 개수로 병렬 실행하기: (현재 이해 부족으로 인해, 추후 삽입 예정) ES8 비동기 함수정의에 대한 자세한 내용은 MDN async function, MDN AsyncFunction 생성자를 참고하라. ES7 비동기 함수는 비동기적으로 동작하는, async, await 문법이 활용된 함수이다. (설명 보충 예정.) Why Generator? What’s Generator? Generator는 시작 지점이 여러 개이며 중간에 실행을 정지/재개할 수 있는 함수이다. 시작 지점이 여러 개: 다른 시작 지점에 대해 매번 새로운 arguments로 호출할 수 있다. 정지/재개할 수 있다: 제너레이터 함수는 실행 후 값을 반환할 때 정지한다. 이후 호출하면 다시 재개된다. Generator가 익숙하지 않다면 MDN을 참고: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator 시작하기 전에 아래 두 코드의 결과를 모르겠다면 이후 내용을 이해하기 어려우므로, Generator에 대해 추가적으로 공부를 하기 바란다. 1234567891011121314151617181920212223242526272829// Generator Example 1function* fruitGenerator() { yield 'apple'; yield 'orange'; return 'watermelon';}const newFruitGenerator = fruitGenerator();console.log(newFruitGenerator.next());console.log(newFruitGenerator.next());console.log(newFruitGenerator.next());// Generator Example 2function* iteratorGenerator(arr) { for (let i = 0; i &lt; arr.length; i++) { yield arr[i]; }}const iterator = iteratorGenerator([ 'apple', 'orange', 'watermelon',]);let currentItem = iterator.next();while (!currentItem.done) { console.log(currentItem.value); currentItem = iterator.next();} Generator with CPS into Async-Await:놀랍게도 Generator에 약간의 양념을 치면 ES7 비동기 함수를 만들어낼 수 있다. 12345678910111213141516171819202122232425262728293031323334const fs = require('fs');const path = require('path');// 제너레이터로 비동기 흐름을 구현하는 방법이다.function asyncFlow(generatorFunction) { // callback 함수는 비동기 함수에 CPS 패턴으로 넘겨져서, 결괏값으로 다시 제너레이터를 호출하는 데 사용된다. function callback(err) { if (err) { return generator.throw(err); } const results = [].slice.call(arguments, 1); generator.next( results.length &gt; 1 ? results : results[0], ); } const generator = generatorFunction(callback); generator.next();}// asyncFlow, callback을 감추고, yield를 await으로 바꾼다면 async-await과 같은 문법을 지닌다.asyncFlow(function* (callback) { const fileName = path.basename(__filename); const myself = yield fs.readFile( fileName, 'utf8', callback, ); yield fs.writeFile( `clone_of_${fileName}`, myself, callback, ); console.log('Clone created');}); try-catchAsync-Await과 유사하게, 제너레이터에는 throw API가 있는데, 제너레이터 함수 내에서 try-catch로 이를 처리할 수 있다: 123const twoWay = twoWayGenerator();twoWay.next(args); // args를 전달twoWay.throw(new Error()); // throw로 Error 객체 전달. 제너레이터 함수 내의 catch 절로 이동하게 된다. 참고자료 전문: Async-Await ≈ Generators + Promises 참고 2: Difference between async/await and ES6 yield with generators | StackOverFlow 참고 3: ES2017 - Async vs. Yield | StackOverFlow 하나의 API로 CPS와 Promise 모두 지원하는 방법mongoose와 같은 많은 라이브러리는 CPS와 Promise 방식을 모두 지원한다. 어떻게 한 함수로 동시에 지원할 수 있을까? 아래 코드와 같이 구현한다면 가능하다. 1234567891011121314151617181920212223242526272829// 마지막 인자로 callback 함수를 받는다.// Promise로 사용하는 경우 callback 함수를 넘기지 않으니, 상관 없다.function asyncDivision(dividend, divisor, cb) { // 항상 Promise를 반환한다. // 어차피 CPS 패턴을 사용하는 코드라면 Promise로 결과를 받아서 처리하지 않는다. return new Promise((resolve, reject) =&gt; { // 비동기로 반환 process.nextTick(() =&gt; { const result = dividend / divisor; if ( isNaN(result) || !Number.isFinite(result) ) { const error = new Error( 'Invalid operands', ); if (cb) { cb(error); } // 콜백이 있으면, 콜백을 호출한다. return reject(error); // 콜백이 있든 없든, Promise reject로 catch 체인을 실행한다. } if (cb) { cb(null, result); } // 콜백이 있으면, 콜백을 결과로 호출한다. resolve(result); // Promise resolve로 then 체인을 실행한다. }); });} 장점: Promise, CPS 패턴 사용자 모두에게 기능을 제공할 수 있다. 비동기와 함수형 자바스크립트Javascript는 순수한 함수형 언어가 아니므로, 모든 코드를 함수형 패러다임을 적용해서 작성할 수 없다고 한다. 비동기를 다루는 코드에 있어서는, 특히 async-await 키워드를 사용하여 작성할 때는 명령형 코드가 되므로, 더 함수형과 멀어지게 되는데, 결론적으론 Javascript에서 함수형 패러다임을 실천할 때에는 함수형인 코드 베이스와 그렇지 않은 부분으로 나누는 게 좋다고 한다. 또한 Promise든 Async-Await이든 하나를 택해서 통일하는 게 좋다고 하니 참고 바란다. 전문: JS: Promises, async/await, and functional programming. TODO: Generator는 아직도 공부 중이다. Iterable 프로토콜에 대한 얘기도 있고, 비동기 처리 외에 Generator의 쓰임새나 Generator 자체 개념에 대해 더 공부해야 한다. 코루틴에 대해서도 공부해봐야 할 것 같다. 공부 중 접하게 된 키워드이다. 제너레이터에 대한 설명을 보강해야겠다. 이해가 완료되면 자체 제작한 예제 코드로 교체한다.","link":"/js-async-1/"},{"title":"이벤트 루프는 환경마다 다를까?","text":"Javascript의 모든 코드는 이벤트 루프에서 처리된다. 그리고 Node.js의 이벤트 루프 구현체로 libuv가 사용 된다는 사실은 널리 알려져 있다. 그런데 이상하지 않은가? 왜 Node.js를 설명할 때 이벤트 루프의 구현체라며 따로 소개하는 걸까? 과연 브라우저 상의 이벤트 루프와 Node.js의 이벤트 루프는 동일하다고 생각해도 될까? 이벤트 루프 구현체가 다르다는 것을 어떻게 생각하면 좋을까? 원인은 환경 차이이벤트 루프의 처리 방식은 스펙으로 결정돼있지만 벤더마다 약간씩 다르게 구현하는 부분이 있다고 한다. Node.js 또한 예외는 아니다. 기능 브라우저 NodeJs File, Network I/O No Yes Event의 종류 Mouse, Keyboard Events File, Network I/O 이벤트 루프 구현체 libevent (크롬 기준) libuv 자바스크립트 엔진 V8 (크롬 기준) V8 process.nextTick (process 모듈 자체 API) No Yes setImmediate (ECMA 표준 아님) No Yes 위 표 이외에 처리 순서의 차이가 약간 있긴 하지만 Node v11부터는 그 차이마저 적은 편이다. 결론: 환경의 차이 때문에 약간의 구현 상의 차이가 있다 정도로 받아들이자. 출처: JavaScript Event Loop vs Node JS Event Loop","link":"/js-event-loop-browser-vs-node/"},{"title":"Javascript의 Generator","text":"이 글은 자바스크립트의 제너레이터 문법에 대해 간략히 소개한다. 정의JavaScript의 제너레이터는 function* 으로 정의된 제너레이터 함수가 반환한 객체이다. 이 객체는 이터레이터(iterator)이다. 123456789function* foo() { yield 1; yield 2; yield 3;}// foo()로 생성된 제너레이터를 순회하며 값을 읽어간다.for (let i of foo()) { console.log(i);} Generator 객체와 함수(팩토리)제너레이터 함수를 호출하면 제너레이터 객체를 반환하고 끝난다. 제너레이터 객체의 next(...args)를 통해 제너레이터의 본문을 일정 부분 실행할 수 있다. 이터레이터는 next() 함수로 파라미터를 전달할 수 없다. 제너레이터가 값을 읽을 수 있기 때문에 협력적 멀티 태스킹이 가능하다. Generator 기반 협력적 멀티 태스킹협력적 멀티 태스킹은 코루틴에 나오는 개념이다. (추후 정리할 예정이다.) 1234567891011121314go(function* producer() { for (let i = 0; i &lt; 10; i++) { yield write(i); yield sleep(100); // -- sleep이 가능해진다! }});go(function* consumer() { let v; while ( typeof (v = yield read()) !== 'undefined' ) { console.log('read:', v); }}); 이 코드의 go와 같은 함수를 제너레이터 실행기라고 한다. co 라이브러리가 훌륭한 제너레이터 실행기를 제공한다. 제너레이터 실행기는 원래 동기적으로 수행되는 제너레이터를 비동기 호출을 수행하게 만든 다음 callback을 통해 다시 제너레이터를 호출하게끔 하여 비동기 코드를 동기 코드처럼 작성할 수 있게 하는 목적의 함수이다. 제너레이터 실행기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 제너레이터 실행기function grun(g) { const it = g(); (function iterate(val) { const x = it.next(val); if (!x.done) { if (x.value instanceof Promise) { x.value .then(iterate) .catch((err) =&gt; it.throw(err)); } else { setTimeout(iterate, 0, x.value); } } })();}// 제너레이터 실행기를 사용한 모습.// 꽤 async-await과 같이 가독성이 있다.function* theFutureIsNow() { let data; try { data = yield Promise.all([ nfcall(fs.readFile, 'a.txt'), nfcall(fs.readFile, 'b.txt'), nfcall(fs.readFile, 'c.txt'), ]); } catch (err) { console.error( 'Unable to read one or more input files: ' + err.message, ); throw err; } yield ptimeout(60 * 1000); try { yield nfcall( fs.writeFile, 'd.txt', data[0] + data[1] + data[2], ); } catch (err) { console.error( 'Unable to write output file: ' + err.message, ); throw err; }} Generator 직접 만들어보기자료 중 재밌는 것이 있었다: Babel은 Generator를 어떻게 바꾸나. 지금 나한테는 바로 이해하긴 어렵다. 직접 만들어보면 이해에 큰 도움이 될 듯 하다. Generator의 단점: Iterable은 가변 인자가 아니다제너레이터 객체는 위에서 말했듯 Iterable이지만, 이는 가변 인자와는 달라서, Math.min같은 함수를 이용할 때 spead 연산자로 배열로 만들어 넘겨야 하므로, 인자 전달 부분에서 아쉽다고 한다. 1234567891011const foo = function* () { /* ... */};// 제너레이터 객체만 넘길 순 없음.// 굳이 제너레이터 객체를 넘길거면, 받는 함수 입장에서 이터레이터를 써야 할 듯?// for-of 문으로.let min = Math.min(foo);// spread 연산자로 넘겨줘야 함.let min = Math.min(...foo()); Generator의 콜 스택? Calling .next() method just pushes that call on the top of the stack. It will then run the code inside the generator function. difference: it has to remember the state of all local variables, but engines already know how to do that from the implementation of closures. A generator call will restore the state so that it can continue where it left off. 일반적인 콜 스택과 동일하다고 한다. 다만 제너레이터 내에서 제너레이터를 호출하는 경우 복잡하다고 하는데, 거기까지 알 필요는 없을 듯 하다. 출처: Javascript stack model for generators | StackOverFlow 출처: Javascript Generator의 재미 (2016.12) 출처: Learning Javascript, O Reilly TODO:부족한 내용 보충하기. 제너레이터가 개념 뿐 아니라 사용이 중요한 개념이어서 정리가 난잡한데 다음주 중으로 정리하려고 한다.","link":"/js-generator/"},{"title":"Javascript의 라이센스","text":"이 글은 자바스크립트의 라이센스 - 소유권과 결정권에 대한 내용과 근거를 찾아 정리한 글이다. 1. Javascript의 라이센스Javascript 이해관계자는 크게 언어 명세을 결정하는 쪽과 언어를 개발하는 쪽으로 나뉜다. 주제 소유자 라이센스 생명 주기 언어 명세(ECMA 262) TC39 수정 하지 않는 선에서 사용 가능 매년 런타임(SW) 각 벤더 개별적으로 다름 상시 업데이트 재밌는 점은 TC39에 벤더들이 참여한다는 점이다. Trademark(유사 상표권)는 Oracle에 있는데, 명칭하는 데 사용하는 것은 문제가 되지 않는다고 한다. 언어 명세(구현 코드가 아님)은 ECMA International(TC39의 상위 개념)에서 제정한다. 언어 표준의 라이센스는 이 글 | StackExchange을 참고 언어 - 인터프리터, 컴파일러, 런타임 - 구현의 몫은 각 벤더사에 있으며 벤더사가 적용하는 라이센스에 따라 각자 라이센스를 가질 수 있다. 아래는 역사를 요약 설명한 내용이다. in 1995, Netscape decided to add a scripting language to Navigator. They pursued two routes to achieve this: collaborating with Sun Microsystems to embed the Java programming language, while also hiring Brendan Eich to embed the Scheme language. Netscape management soon decided that the best option was for Eich to devise a new language, with syntax similar to Java and less like Scheme or other extant scripting languages. Although the new language and its interpreter implementation were officially called LiveScript when first shipped as part of a Navigator release in September 1995, the name was changed to JavaScript three months later. 1995: Netscape Navigator라는 브라우저의 기능으로 스크립트 언어를 내장하기로 개발 In November 1996, Netscape submitted JavaScript to ECMA International, as the starting point for a standard specification that all browser vendors could conform to. This led to the official release of the first ECMAScript language specification in June 1997. 1996: Netscape -&gt; ECMA International로 소유권 이양 (이후 특정 기업의 소유는 아니게 됨) 출처: Javascript | Wikipedia 2. TC39 소개 Ecma International’s TC39 is a group of JavaScript developers, implementers, academics, and more, collaborating with the community to maintain and evolve the definition of JavaScript. TC39에서는 미팅 회의록을 공개하는데, 최근 미팅을 보니 주요 브라우저 벤더사만 참여하는 것은 아니고 회의마다 여러 주체나 외부 인사도 참여하는 듯 하다. TC39에서 Javascript의 스펙을 결정한다고 한다. This Standard defines the ECMAScript 2021 general-purpose programming language. TC39는 가장 최신의 Javascript 스펙 문서를 온라인으로 유지한다. 현재는 ECMAScript 2021이며 이 문서는 Living Standard로 주기적으로 갱신되는 듯하다. TC39이 표준을 제정하는 방식에 대해선 ECMAScript와 TC39 | ahn.heejong을 참고하라. 3. WHATWG 소개 The WHATWG was formed in response to the slow development of World Wide Web Consortium (W3C) Web standards (…) On 28 May 2019, the W3C announced that WHATWG would be the sole publisher of the HTML and DOM standards. WHATWG는 W3C이 제정하는 표준 중 HTML, DOM 표준을 독자적으로 제정하는 그룹이다. WHATWG는 주요 브라우저 벤더로 구성된다. 자세한 내용 WHATWG에서 제정한 HTML 5 스펙은 HTML 뿐만 아니라 - HTML5라고 해서 HTML만을 다루지는 않는다 - (현대) 웹 기술의 전반에 대해 표준화된 문서이다. 4. 번외: 구글은 왜 Chrome, V8을 오픈소스화했을까? [Chromium Release Announcement 발췌] With a richer set of APIs we can build more interesting apps allowing people to do more online. The more people do online, the more they can use our services. […] We believe that open source works not only because it allows people to join us and improve our products, but also (and more importantly) because it means other projects are able to use the code we’ve developed. [StackExchange 답변 중] they just needed the web as a whole to become more attractive. Their decision to open-source V8 led to one such effect: the NodeJS system was built on V8 … The web has become so attractive as a development environment that it is even displacing native apps, e.g. Electron is based on Chromium. 공유되는 일부 내용을 정리해보자면, 크롬을 통해 구글은 웹 시장을 키우고 싶었고, 오픈소스화(2008)로 웹의 기능을 늘리고 늘어난 기능이 널리 퍼지는 것을 유도했다(다른 크로미움 기반 브라우저를 통해). 오픈소스를 활용해 크롬을 개발했으며, V8기반의 NodeJS(2011)를 통해 Javascript 생태계가 커졌다. (숙련된 개발자가 많아질 수 있는 환경 조성) 출처: Why did Google make Chromium Open Source? | StackExchange TODO:Q. Netscape은 왜 넘겼을까? 돈이 안 돼서 그런걸까? 독자적인 기능으로 탑재했다면 더 성공할 수 있지 않았을까? Q. 굳이 오픈소스화 하지 않아도 경쟁을 통해 기능은 늘어났을 것이고 크롬 출시연도인 2009년에 이미 2위 브라우저로 시작해 2012년엔 1위 브라우저가 됐는데 오픈 소스화가 여기서 얼마나 큰 역할을 했는지는 잘 모르겠다. 좀 더 찾아봐야 할 듯.","link":"/js-license/"},{"title":"Promise.all은 Parallel로 실행되는가?","text":"Javascript의 모든 코드는 이벤트 루프에서 처리된다. 그리고 Node.js의 이벤트 루프 구현체로 libuv가 사용 된다는 사실은 널리 알려져 있다. 그런데 이상하지 않은가? Promise.all은 Parallel로 실행되는가?이벤트 루프 모델을 이해했다면 자바스크립트에 병렬 실행은 없다는 것을 이해했을 것이다. 파일, 네트워크 I/O는 자바스크립트 코드가 직접 처리하는 것이 아니고, 콜백은 이벤트 루프에 의해 호출되어 순차적으로 실행된다. 그럼, Promise.all은 어떤가? 음… 애초에 자바스크립트 코드가 병렬적으로 실행될 수 있는가? Promise.all을 잘 몰라서 생긴 일Promise.all은 Promise의 호출 순서와는 전혀 관계가 없다. Promise의 기본 동작을 하나도 건드리지 않는다. Promise.all이 제공하는 기능이란, 트랜잭션과 같이 하나라도 실패하면 catch 훅으로 넘어가게 하는 것이다. 1234567Promise.all([p1, p2, p3, p4, p5]) .then((values) =&gt; { console.log(values); }) .catch((error) =&gt; { console.log(error.message); }); 오히려 순차적으로 Promise를 실행하는 것이 더 특별하다.reduce를 사용해 iterable.reduce((p, fn) =&gt; p.then(fn), Promise.resolve())로 순차적으로 실행시킬 수 있다. (웬만하면 then으로 직접 잇겠지만.) Async Functions in Javascript 1를 참고해도 좋을 것 같다. 출처: How does Promise.all all works interanlly 출처: Is Node.js native Promise.all processing in parallel or sequentially? | StackOverFlow","link":"/js-promise-all/"},{"title":"1장: Reactor 패턴 (내용 검증 필요)","text":"1장은 Node.js에 대한 소개하는 챕터이다. 주의!해당 글의 내용은 부정확한 내용이 아주 많을 수 있습니다. 책의 설명이 추상적이고 OS 개념이 많이 필요하므로 추후 정리가 완료되는 경우 따로 표시하겠습니다. Node.js 철학 (Node Way)최소 기능: 기능 개수를 최소한되므로, 개발자, 사용자 모두에게 간단함 Node.js 자체 뿐만 아니라 node 기반 모듈을 설계할 때도 동일하게 적용 KISS 원칙: 부족하더라도 복잡함보다 단순함이 더 낫다 Reactor 패턴과 Node.js 이벤트 루프Reactor 패턴은 Node.js의 비동기 특성 - Node.js에서 여러 요청이 동시에 있는 경우는 항상 비동기 방식으로 작업을 처리한다 - 의 원인이자, 비동기 방식으로 작업을 처리하는 방법에 해당한다. Reactor 패턴을 배우기 전에, 동시성을 처리하는 2가지 방법에 대해서 알아보자. Blocking I/O : 느린 I/O를 기다리는 방식 많은 스레드 개수: 소켓의 데이터를 매번 기다리게 되면 각 연결 별로 스레드가 적어도 하나씩 돌아야 한다. 기다리는 시간에 타 사용자가 기다리지 않게 하기 위해서이다. 비효율적인 대기 시간: I/O가 CPU에 비해 매우 느리기 때문에 블로킹 API는 스레드의 유휴 시간이 처리 시간에 비해 압도적으로 길 수 밖에 없다. 스레드가 아무 일을 하지 않은 상태로 긴 시간 존재한다. 스레드의 비용: 스레드는 그 비용이 싸지 않다. 아주 많은 스레드가 있는 경우, Context Switching만 해도 비용이 매우 클 것이고, 적은 스레드가 있는 경우 사용자를 처리하지 못하므로 비즈니스적으로 비용이 매우 클 것이다. Non-blocking I/O: 비동기 API를 호출 시 바로 제어권을 반환(내부적으로 특정 상수를 반환)하여 CPU 유휴 시간을 최소화한다. Polling: 비효율적으로 I/O를 처리하는 방식으로, 리소스는 데이터가 없을 때 읽기 조작을 요청 받는 경우 EAGAIN을 반환하는데, 이 때문에 값이 필요한 입장에선 리소스를 계속 확인해야 한다. 이걸 BUSY_WAITING이라고 하는데, CPU를 계속 활용하므로 효율적이지 못하다. 동기 이벤트 디멀티플렉서: 논블로킹을 처리하는 효율적인 방법으로, 이벤트가 완료될 때마다 큐에 이벤트를 쌓아놓고 처리를 수행하는 객체. 이벤트가 없으면 Block 상태로 대기한다. 이벤트 통지자가 감시 대상 리소스의 자원이 읽기가 가능할 때(즉, 이벤트가 완료되었을 때) Demultiplexer에게 통지한다. (이벤트 통지자 역할로 IOCP, epoll/kqueue 등이 있는 것 같다.) Event가 발생하면 Event Demultiplexer가 깨어나 Queue에서 이벤트를 읽어들여 처리하면 됨. 이 시점에서 리소스의 I/O 작업은 (1)에서 이미 완료되어있으므로 동기식으로 처리하면 됨. 또한 처리 방식이 싱글 스레드이므로 공유 자원 문제도 존재하지 않는다. 리액터 패턴: 이벤트 디멀티플렉서 + 이벤트 루프 + 이벤트 큐 + 실행 환경(V8, 싱글 스레드!) 이벤트 디멀티플렉서는 I/O 처리가 끝나면 (완료된) 이벤트를 이벤트 큐에 넣어줌 이벤트 루프는 실행 환경 상에서 스택이 비는 경우(즉 모든 동기 코드가 실행이 끝났을 때 - 노드 환경에서 동기 코드는 얼마 없어서 최초의 동기 코드는 금방 끝나기 마련.), 이벤트 큐에서 이벤트를 꺼내어 실행 환경에 이벤트 핸들러를 올리고, 인자로 이벤트를 넘겨 수행함. 만약 async 내에 async가 있다면 해당 이벤트는 또 이 과정을 거침. 이벤트 디멀티플렉서의 구현체 libuv: 크로스 플랫폼으로(가상머신 느낌으로 각 OS에 대응되는 이벤트 통지자를 활용) 비동기 작업을 처리함. 단, libuv는 이벤트 디멀티플렉서 역할만 하는 게 아니라 이벤트 루프도 구현함. 참고: libuv에 이벤트루프가 포함돼있음: 더 정확한 이벤트 디멀티플렉서, 이벤트 루프 구현 상세에 관한 글, 영상 로우 레벨로 살펴보는 Node.js 이벤트 루프 | Evans Library Node.js 이벤트 루프, 타이머, process.nextTick() | Node.js (놀랍게도 이 문서가 더 어려운 것 같다…) 브라우저 환경에서의 이벤트 루프(자막 있음, 자세함!):Jake Archibald: In The Loop | JSConf.Asia 아마도 이벤트 루프에 대한 가장 유명하고, 쉬운 설명:What the heck is the event loop anyway? | JSConf EU","link":"/ndp-1-reactor-pattern/"},{"title":"2장 (1&#x2F;3): CPS 패턴","text":"이 글은 CPS 패턴과 CPS가 Node.js에서 어떻게 사용되고, 어떤 점을 주의해야 하는지 다룬다. 1. CPS 패턴Node.js는 1장에서 살펴봤듯 비동기 특성을 가지며, 따라서 Node.js 앱은 대부분의 일을 비동기로 처리할 수 밖에 없다. 비동기를 처리하는 방법 중 CPS, Continous Passing Style을 소개한다. CPS: 비동기 API를 사용할 때, 콜백 함수를 인자로 넘기는 패턴이다. 왜 사용하는가: 비동기 API는 return을 할 수 없는데, 함수의 실행이 끝나기 전에 제어권이 넘어가기 때문이다. 이를 해결하기 위해선 결과를 다른 함수에 넘기면 된다. 장점: 간단하고 효과적이다. 단점: 호출 깊이가 깊어지면 가독성이 감소된다. Callback Hell이라고 불린다. 2. Node.js에서의 CPS 패턴Node.js는 CPS 패턴을 사용할 때 일관된 규칙을 따라야 한다. argument 순서에 관한 규칙: (...params, callback) 과 같이, callback 함수를 마지막 인자로 넘겨야 한다. callback 함수의 argument에 관한 규칙: (err, ...args) 와 같이, err가 첫 인자여야 한다. err 인자의 경우, 항상 Error() 객체여야 한다. (이 부분은 잘 지켜지지 않는 듯 하다.) 3. CPS 패턴의 콜 스택Node.js에서 비동기 API를 호출하는 경우, callback 함수는 프로그래머가 예상한 호출 순서로 구성된 스택을 갖지 않는다. 비동기 API가 완료됐을 때, 이벤트 루프에 의해 단일 함수로 Queue에 쌓인 후 다른 타이밍에 실행되기 때문에 새로운 스택에서 실행된다. 비동기 함수에서 예외를 던지면, Error를 반환하며 프로세스가 종료된다. 12345678910111213141516171819202122const fs = require('fs');const readJsonThrows = (filename, cb) =&gt; { try { fs.readFile(filename, 'utf8', (err, data) =&gt; { if (err) return cb(err); cb(null, JSON.parse(data)); // cb이 없거나, data가 불량인 경우 exception 발생 가능. // 콜백 함수 내에서 try-catch하지 않는 경우 프로세스가 죽는다. }); } catch (err) { // 여기서도 catch할 수 없음. 호출 스택은 fs.readFile에서 끝나고, // cb은 별개의 새 스택에서 실행되기 때문 }};// 만약 JSON.parse에서 오류나는 경우, 프로세스가 종료된다.readJsonThrows('C./test.json', (f) =&gt; f);/* SyntaxError: Unexcepted end of JSON input at JSON.parse at FSReqCallback.readFileAfterClose (internal/...)*/ 4. Node.js에서 비동기를 처리할 때 절대 하지 말아야 할 점들1. 결괏값을 동기, 비동기 2가지 방식으로 전달하지 않는다. 결괏값이 비동기일것을 기대하고 이벤트 리스너를 등록할 때, 동기로 결괏값이 제공되는 경우 이벤트 리스너가 동작하지 않는다. 동기 반환값을 비동기화 한다. setTimeout, setImmediate, nextTick, Promise 등이 가능하다. 2. Callback 함수를 argument로 받는 동기 함수를 작성하지 않는다. 동기 API는 바로 결괏값을 받는 형태로 코드를 작성하면 된다.","link":"/ndp-2-cps/"},{"title":"2장 (3&#x2F;3): Node.js의 Observer Pattern","text":"이 글은 Node.js에서 자주 사용되는 Observer Pattern에 대해 소개한다. 리액터 패턴, CPS 패턴에 대한 지식을 전제로 작성했으니 참고바란다. 1. Observer Pattern의 정의 Node.js에서 이벤트는 핵심 중 하나라고 한다. Node.js 코어 모듈과 오픈 소스를 사용하는데도 필수적인 조건이라고 한다. Observer Pattern은 Subject와 Listener 라는 역할로 한 쪽은 등록을, 한 쪽은 통지를 하는 관계이다. Subject는 이벤트를 발생시키는 주체로, 스스로 무슨 행위를 할 때, Listener에게 통지를 해야 한다. Listener는 특정 Subject 객체에 본인의 참조를 등록한다. subject.addListener(this)와 같이 수행한다. foreach (listener : listeners) listener.notify(); 와 같이 Listener에게 이벤트 발생을 알린다. 옵서버 패턴 | Wiki 백과 참고. Observer Pattern이 Callback 보다 나은 점이 뭘까? 기능 Observer Pattern Continuous Passing Style 다중 리스너 지원 Yes No 핸들러 사용 횟수 여러 번(or 주기적으로) 발생하는 경우 한 번 발생하는 경우 핸들러 함수 제약 없음. onError, onSuccess 로 관심사 분리하므로. 한 함수 (err, data)=&gt; { /* ... */ }로 두 상태 모두 처리 핸들러 등록 시점 아무 때나 함수 실행 시점에 매개변수로 전달 2. Event EmitterNode.js는 Event Emitter라는 미리 구현된 객체를 코어 모듈(events)로 포함하고 있다. 이 객체는 emit, on, once, removeListener 로 구성된 총 4개의 메소드를 갖고 있다. 아래는 각 메소드의 사용 예시이다. CodeSandBox가 Node.js를 Beta로 지원하고 있으므로 출력이 정상적이지 않을 수 있습니다. 왼쪽의 탭을 드래그해 코드를 확인해주세요. 아래는 File을 읽는 예제이다. 3. Event Emitter 에서의 예외 처리Event Emitter에서도 비동기 이벤트의 경우, CPS와 마찬가지로 예외가 발생하는 경우 기존 스택을 잃기 때문에 (리액터 패턴 참고) try-catch로 무조건 예외를 처리하여야 한다. 이후 error 이벤트를 발생시켜 리스너들에게 전달함이 일반적이다. 4. Event Emitter 상속하기아래와 같이 EventEmitter를 상속하여 인스턴스에 대해 .on을 붙이는 등의 작업을 할 수도 있다. 책에서는 일반적인 패턴이라고 하지만, emit 메소드까지 의도치 않게 Public API가 되기 때문에 추천하는 방식은 아니다. 위임으로 on, once, removeListener를 따로 API로 내보내는 게 맞다고 생각한다. 123456class FindPattern extends EventEmitter { //...}const findPattern = new FindPattern(/hello \\w+/g);findPattern.on(/* ... */); 5. 동기, 비동기 이벤트 별 리스너 등록 시점이벤트를 동기적으로 발생시키려면, 리스너 등록을 이벤트 발생 이전 시점에 완료하여야 한다. 이벤트를 비동기적으로 발생시키는 경우, 리스너를 동기적으로만 등록한다면 시점이 자유롭다. (리액터 패턴 참고.)","link":"/ndp-2-event-emitter/"},{"title":"2장 (2&#x2F;3): Node.js의 모듈 시스템","text":"이 글은 Node.js의 모듈 시스템에 대해 소개한다. 1. 모듈 시스템의 필요성과 Javascript의 방식모듈 시스템은 프로그램의 구성 요소들 간의 역할을 분리하고, 의존 관계와 구현 상세를 격리하는데 필수적이다. 모듈 시스템의 문법으로 보면, 소스 파일간의 import, export를 하는 것인데, 개념 상 Java의 접근 제한자 - private, protected, public - 도 모듈의 역할 중 일부를 수행 한다고 할 수 있다. Javascript 모듈 시스템으로는 대표적으로 ESM, CommonJs 라는 두 개의 기술이 있는데, 현재의 Node.js는 ESM, CommonJs를 모두 지원한다. 종류 ESM CommonJS 제정 시기 ES6에 제정됨 ESM 이전의 대표적인 비표준 문법(Node 기준) import / export require / module.export Node.js 지원 여부 Yes Yes Browser 지원 여부 최신 브라우저에서 지원 CommonJs.js 로딩 필요 자세한 역사와 기타 모듈 시스템의 종류는 JavaScript 표준을 위한 움직임: CommonJS와 AMD | Naver D2를 참고. 2. Revealing Module PatternJavascript에는 접근 제한자가 없다. 접근을 원천적으로 제한하는 방법 중, 공개할 부분만 객체로 담아 내보내는 패턴이 있다. Private 변수는 클로저를 통해 접근할 수 있으므로, 꽤 괜찮은 방법이다. Revealing Module 패턴을 구현하는 방법은 대표적으로 IIFE(즉시 실행 함수 표현식)가 있다. IIFE는 익명 함수를 ()로 감싼 후 즉시 실행하는 함수 호출 방식이다. 123456789101112const module = (() =&gt; { const privateFoo = () =&gt; { /* private functionality */ }; let privateCounter = 0; const increase = () =&gt; ++privateCounter; const decrease = () =&gt; --privateCounter; // 이 객체를 반환하므로, 외부에선 privateFoo, Bar에 접근할 수 없다. return { increase, decrease };})(); // 즉시 실행하여, { increase, decrease } 객체가 반환된다. 3. CommonJs의 require 방식에 대해CommonJs는 const moduleA = require('./moduleA');와 같이 모듈을 로딩하는 문법을 제공한다. require는 동기로 작동하고, 한 번 로딩한 모듈은 캐시된다. 내보낼 때에는 각 모듈별로 제공되는 exports 객체에 필드를 할당하는 방식으로 진행한다. 모듈은 캐싱되므로 항상 동일한 객체를 반환한다. 아래는 require의 수도 코드이다. 1234567891011121314151617181920212223242526272829const require = (modulePath) =&gt; { // path를 가져오고, unique한 id로 활용한다. const id = require.resolveAbsolutePath( modulePath, ); // 캐시된 모듈은 캐시를 반환한다. if (require.cache[id]) return require.cache[id].exports; // 처음 로딩하는 경우 새 exports 객체가 필요하다. const module = { exports: {}, id, }; // 객체는 캐시한다. require.cache[id] = module; // 이 함수가 소스 코드를 읽어 exports 객체에 export 내용들을 할당한다. readFileAndEvaluate(id, module, require); return module.exports;};require.cache = {};require.resolveAbsolutePath = (modulePath) =&gt; { /* implementation */}; 어느 범위까지 같은 인스턴스가 반환될까? 같은 패키지로 빌드된다면 하나의 인스턴스를 공유할 것이다. package.json별로 독립적으로 dependency를 관리하기 때문에, 각 패키지간에 제 3의 모듈의 객체를 주고 받는 경우, 해당 객체는 버전 불일치가 있을 수 있다. A Simple Explanation | Medium (EN) 4. 비동기 모듈 초기화비동기로 객체를 초기화할 순 없다. require 함수가 동기로 작동하기 때문인데, 아무래도 initialize와 같은 메소드를 호출하는 형태로 비동기 API를 만들어서 활용하는 수 밖에 없을 듯하다. 관련 스택 오버 플로우 참고. 5. 순환 참조가 있는 경우Node.js 환경에서 순환 참조를 하는 경우 한 모듈이 먼저 로딩되기 때문에, 동기로 로딩하는 경우, 한 쪽에서는 null, 한 쪽에서는 정상 로딩이 될 수 밖에 없다. 아니면 명확한 순서를 지정해준다면 해결할 수도 있겠지만(A[A.B = null]-&gt;B[B.A = A]-&gt;[A.B = B]), 순서를 명시하는 API가 따로 있는지 잘 모르겠다. 한 쪽에서 느린 초기화를 진행한다. (Lazy-Init) - 순서 정하기와 사실상 동일함. 순환 참조 관계에 있는 두 객체를 제 3의 객체에 의존하도록 한다. 관련 스택 오버 플로우 - 이 부분은 잘 이해하지 못 했다. 어떻게 export 해야 좋은 모듈일까?1. Substack 패턴모듈의 기능을 객체가 아닌 함수 단위로 노출한다. 진입점이자 주가 되는 함수를 module.exports로 내보내는데, 따라서 const logger = require('./logger')와 같이 바로 사용할 수 있는 함수가 된다. 또한, logger.verbose(msg); 와 같이 서브 함수들도 내보내, 사용하는 입장에서 기능의 중요도를 쉽게 파악할 수 있게 한다. 1234module.exports = mainFn;exports.subFn1 = subFn1;// 2...N-1exports.subFnN = subFnN; (ex) 1234567// 메인 함수module.exports = (msg) =&gt; console.log(`${this.name} ${msg}`);// 서브 함수 1exports.verbose = (msg) =&gt; console.log(`[verbose] ${this.name} ${msg}`); 2. 생성자 내보내기prototype 기반으로 생성자를 만들거나, ES6 Class를 활용하여 생성자를 만들어, 생성자를 내보낸다. 사용하는 입장에선 객체의 기능을 확장할 수도 있고, 쉽게 인스턴스를 생성할 수도 있고, 사용하기도 깔끔한 방법이다. 12345678910111213module.exports = class Logger { constructor(name) { // implementation } log(msg) { console.log(`${this.name} ${msg}`); } verbose(msg) { console.log(`[verbose] ${this.name} ${msg}`); }}; 3. 인스턴스 내보내기생성자 내보내기와 거의 같지만, 싱글톤이 자동으로 구현되는 셈이므로 쉽게 활용하기 좋다. 123456789101112131415class Logger { constructor(name) { // implementation } log(msg) { console.log(`${this.name} ${msg}`); } verbose(msg) { console.log(`[verbose] ${this.name} ${msg}`); }}module.exports = new Logger('App');","link":"/ndp-2-module/"},{"title":"3장: CPS 패턴 사용 시의 Tip","text":"Node.js 환경에서 CPS 패턴을 사용할 때 시도할 만한 Tip들을 정리했다. 1. Callback Hell을 조금 해결하는 방법 본인은 Promise 세대여서 Callback Hell을 제대로 경험해 본 적이 없고, 웬만한 개발 환경이라면 Callback Hell을 겪기 어려울 것으로 예상돼 짧게 요약했다. 들여 쓰기 때문에 가독성이 매우 떨어지게 되고, 변수 이름도 중첩되는 문제가 있다. 만약 Blocking API를 사용해 동일한 내용을 구현했다면 잘 못 이해할 가능성은 거의 없을 것이다. Pattern: 중첩 수준을 낮게 유지하기 위해, else 문을 사용하지 않는다. 인라인 함수의 이름을 지정하면, 함수 이름을 통해 더 쉽게 디버깅이 가능하다. 함수를 쪼갠다. 자주 하는 실수: Callback을 호출한 뒤에도 함수는 계속 실행됨을 잊는다. 12if (err) callback(err);// 여기서도 함수는 계속 실행된다. return callback(err) 혹은 return을 callback 호출 이후 수행하여 함수 실행을 종료한다. 2. 순차적으로 실행시키는 방법Callback Hell을 겪지 않고 비동기 API를 순차적으로 실행하는 방법: 재귀 함수로 실행한다. 재밌는 점은, StackOverFlow가 날 일은 없다는 점이다. 비동기 함수여서 매 번 스택이 초기화되니까. 123456789101112131415161718const length = N;const tasks = [ /* ... */];const data = [ /* ... */];const callback = (f) =&gt; f;const iterate = (idx) =&gt; { if (idx === length) return callback(); const task = tasks[idx]; task(data[idx], (err) =&gt; { if (err) return callback(err); iterate(idx + 1); });};iterate(0); // Callback이 재귀적으로 수행돼, N 만큼 수행된다. 이 방식의 한계: 실행될 작업의 숫자를 알아야 한다. 3. JS 경쟁 조건 해결하기 Javascript는 단일 스레드로 실행된다. 리소스 동기화는 필요 없지만, 비동기 API 타이밍 문제는 아직 남아있다. Javascript 역시 호출 시점과 I/O 수행 시점 차이로 중복 작업 등의 예기치 않은 동작을 할 수 있다. 상호 배제로 해결 가능하다. 12345678910// 실행 중인 job을 등록한다. 공유 리소스 동기화는 필요 없다.const jobs = new Map();const fn = (id, data, callback) =&gt; { // 이 코드로 타이밍 문제를 해결할 수 있다. if (jobs.has(id)) return process.nextTick(callback); jobs.set(id, true); // 정상 분기.}; 4. 동시에 수행되는 작업 개수 제한 하기한 번에 너무 많은 파일을 열려고 하는 등의 경우 리소스 부족으로 뻗어버릴 수 있다. 동시에 실행하는 작업의 수를 제한해 이를 상황을 방지하는 아이디어를 소개한다. 알고리즘: 처음에 동시 실행 제한 개수만큼의 작업을 실행 각 작업이 끝날 때, 동시 실행 제한 개수 - 현재 실행 개수 만큼의 작업을 실행 1234567891011121314151617181920212223242526const tasks = [ /* ... */];const limit = 2; // 동시 실행 제한 개수let running = 0, completed = 0, idx = 0;const next = () =&gt; { // 여유 작업 개수만큼 반복 while (running &lt; limit &amp;&amp; idx &lt; tasks.length) { const task = tasks[idx++]; task(() =&gt; { // 새 작업을 할 수 없음 if (completed === tasks.length) return finish(); completed++; running--; next(); // 새 작업을 할 여유가 있음 }); running++; }};// 동시 실행 제한 개수를 채우며 계속 실행함.next(); 큐로 구현하는 방법: 12345678910111213141516171819202122232425262728293031// Queue로 구현하는 방식// 로직은 같은데 Queue를 사용하는 것만 다르다.class TaskQueue { constructor(limit) { this.limit = limit; this.running = 0; this.queue = []; } // task :: callback =&gt; void; (must call callback) // task를 tasks에서 가져오는 게 아니라, Queue에 넣은 것이 나온다. // =&gt; 새 작업을 큐에 동적으로 추가할 수 있다. pushTask(task) { this.queue.push(task); this.next(); } next() { while ( this.running &lt; this.limit &amp;&amp; this.queue.length ) { const task = this.queue.shift(); task(() =&gt; { this.running--; this.next(); }); this.running++; } }} 5. Async 라이브러리 사용복잡한 비동기 제어 흐름을 선언적인 방식으로 처리할 수 있게 헬퍼 함수들을 제공하는 라이브러리이다. 순차적인 반복 제한된 동시 실행 등을 헬퍼 함수를 통해 쉽게 구현 가능하다. CPS 패턴은 주로 사용할 것 같진 않아 따로 정리하진 않았다. TODO: 여러 번 이해하여 좋은 예제를 만들어 이 글 내용 보강하기","link":"/ndp-3-cps-tips/"}],"tags":[{"name":"CI","slug":"CI","link":"/tags/CI/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"GitHub Actions","slug":"GitHub-Actions","link":"/tags/GitHub-Actions/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"1 Month Docker","slug":"1-Month-Docker","link":"/tags/1-Month-Docker/"},{"name":"ExpressJs","slug":"ExpressJs","link":"/tags/ExpressJs/"},{"name":"함수형 자바스크립트","slug":"함수형-자바스크립트","link":"/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Node.js 디자인 패턴","slug":"Node-js-디자인-패턴","link":"/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"}],"categories":[{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/categories/CI-CD/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"ExpressJs","slug":"ExpressJs","link":"/categories/ExpressJs/"},{"name":"함수형 자바스크립트","slug":"함수형-자바스크립트","link":"/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Node.js 디자인 패턴","slug":"Node-js-디자인-패턴","link":"/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"}]}
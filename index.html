<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-22T09:20:00.000Z" title="2021-08-22T09:20:00.000Z">21-08-22</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-22T09:18:36.910Z" title="2021-08-22T09:18:36.910Z">21-08-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/RabbitMQ/">RabbitMQ</a></span><span class="level-item">3분안에 읽기 (약 431 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-rmq-monitoring-easy/">리눅스에서 tmux와 rabbitmqctl을 이용한 Queue 잔여 메시지 모니터링하기</a></h1><div class="content"><p>이 글은 RabbitMQ에서 하나의 One Queue, One Producer, Two Consumer로 구성해 메시지를 처리하는 과정을 모니터링하는 방법을 다룬다.</p>
<hr>
<h4 id="1-tmux-사용-방법"><a href="#1-tmux-사용-방법" class="headerlink" title="1. tmux 사용 방법"></a><strong>1. tmux 사용 방법</strong></h4><p>[<a href="https://jsqna.com/linux-tmux/">jsqna</a>]</p>
<p>이 글에서 사용하는 tmux 명령어는 아래의 명령어로 한정된다.</p>
<ul>
<li>Ctrl + b 를 통해 명령어 모드 활성</li>
<li>Ctrl + b 후 <code>&quot;</code>를 누르면 새 <strong>가로</strong> 패널 생성 (<code>%</code>를 누르면 <strong>세로</strong> 패널 생성)</li>
<li>Ctrl + b + <code>방향키</code>를 누르면 각 패널 전환</li>
<li>Ctrl + b + <code>[</code>를 누르면 현재 패널에서 스크롤 활성화 (기본으로 스크롤이 불가능하다.)</li>
</ul>
<hr>
<h4 id="2-RabbitMQ-설치"><a href="#2-RabbitMQ-설치" class="headerlink" title="2. RabbitMQ 설치"></a><strong>2. RabbitMQ 설치</strong></h4><p>간단하게 Docker로 설치한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.9-management</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-RabbitMQCtl-실행-및-모니터링"><a href="#3-RabbitMQCtl-실행-및-모니터링" class="headerlink" title="3. RabbitMQCtl 실행 및 모니터링"></a><strong>3. RabbitMQCtl 실행 및 모니터링</strong></h4><p>해당 컨테이너에 bash로 접속하고 <code>watch</code>  명령어로 <code>rabbitmqctl list_queues</code>를 1초마다 반복 실행한다.</p>
<p>해당 명령어는 현재 RabbitMQ 인스턴스에 존재하는 큐와 잔여 메시지를 출력한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it &lt;container-id&gt; /bin/bash</span><br><span class="line"></span><br><span class="line">$ watch -n 1 rabbitmqctl list_queues <span class="comment"># 1초마다 해당 명령어를 실행한다.</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="4-tmux로-MQ-Producer-Consumer-총-4개의-Pane으로-구성하기"><a href="#4-tmux로-MQ-Producer-Consumer-총-4개의-Pane으로-구성하기" class="headerlink" title="4. tmux로 MQ, Producer, Consumer 총 4개의 Pane으로 구성하기"></a><strong>4. tmux로 MQ, Producer, Consumer 총 4개의 Pane으로 구성하기</strong></h4><blockquote>
<p>코드는 [<a target="_blank" rel="noopener" href="https://github.com/seongbin9786/rabbitmq_tutorial_and_explanation/tree/main/02_work_queue">github</a>]를 사용했다. 코드에 대한 설명은 주석을 참고하기 바란다.</p>
</blockquote>
<p>RabbitMQ는 기본 동작으로 Multi Consumer에 대해 Round Robin으로 메시지를 전달한다.</p>
<p>아래와 같이 네 개의 Pane으로 화면을 구성하고, 아래와 같이 구성한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 두 Pane에서는 Consumer를 실행한다.</span></span><br><span class="line">$ node receive.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 한 Pane에서는 Producer를 실행한다.</span></span><br><span class="line">$ node send.js</span><br></pre></td></tr></table></figure>
<p>아래와 같은 화면을 구성하면 성공이다. </p>
<p><img src="/images/linux-rabbitmq/monitoring.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-15T10:10:00.000Z" title="2021-08-15T10:10:00.000Z">21-08-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-15T10:03:30.544Z" title="2021-08-15T10:03:30.544Z">21-08-15</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/NCloud/">NCloud</a></span><span class="level-item">12분안에 읽기 (약 1747 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-new-machine-settings/">리눅스 - 클라우드 머신 세팅하기 (Naver Cloud)</a></h1><div class="content"><p>이 글은 네이버 클라우드에서 Server 인스턴스를 생성한 후 수행해야 할 가장 기본적인 작업인 계정 생성 및 ssh 설정을 다룬다. 이후 Docker 설치까지 진행한다.</p>
<hr>
<h2 id="1-Server-생성-및-인증키-비밀번호-확인"><a href="#1-Server-생성-및-인증키-비밀번호-확인" class="headerlink" title="1. Server 생성 및 인증키, 비밀번호 확인"></a><strong>1. Server 생성 및 인증키, 비밀번호 확인</strong></h2><h3 id="Server-생성"><a href="#Server-생성" class="headerlink" title="Server 생성"></a><strong>Server 생성</strong></h3><p>그냥 하면 된다. Zone과 사양만 지정한다.</p>
<h3 id="ACG-생성"><a href="#ACG-생성" class="headerlink" title="ACG 생성"></a><strong>ACG 생성</strong></h3><p>그냥 하면 된다. 없으면 하나 만든다. 단순한 방화벽 설정이다.</p>
<h3 id="인증키-다운로드"><a href="#인증키-다운로드" class="headerlink" title="인증키 다운로드"></a><strong>인증키 다운로드</strong></h3><p>다운로드 하면 된다. 그냥 key다.</p>
<p>[<a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/115838/what-is-the-right-file-permission-for-a-pem-file-to-ssh-and-scp">StackExchange</a>]</p>
<blockquote>
<p>WSL을 사용한다면 Windows에서 cp로 WSL에 파일을 옮기고 난 후 <code>chmod 400 $FILENAME.pem</code>으로 적절한 권한을 줘서 보호한다.</p>
</blockquote>
<h3 id="비밀번호-확인"><a href="#비밀번호-확인" class="headerlink" title="비밀번호 확인"></a><strong>비밀번호 확인</strong></h3><p>서버 콘솔 &gt; 서버 관리 및 설정 변경 버튼 &gt; 관리자 비밀번호 확인</p>
<p>열리는 Modal에 인증키를 업로드하면 확인할 수 있다.</p>
<h3 id="포트포워딩-설정하기"><a href="#포트포워딩-설정하기" class="headerlink" title="포트포워딩 설정하기"></a><strong>포트포워딩 설정하기</strong></h3><p>모든 포트를 열어주는 게 아니라 SSH 접속 용도로만 공인 아이피를 제공한다. 1024~65535 사이의 포트는 임의로 지정할 수 있다.</p>
<ul>
<li><p>보통 편리하게 2222로 하는 편이다.</p>
</li>
<li><p>애초에 포트포워딩을 안 하더라도 ssh 포트는 변경하는 편이다.</p>
</li>
<li><p>포트 설정의 자유를 제공한 것은</p>
<ul>
<li>enterprise에선 요구사항이 다양하기 때문이고,</li>
<li>통계적으로 특정 포트로 몰리지 않기 때문인 듯하다.</li>
</ul>
</li>
</ul>
<h3 id="서버-접속"><a href="#서버-접속" class="headerlink" title="서버 접속"></a><strong>서버 접속</strong></h3><p><code>ssh root@SERVER_IP -p PORT</code> 로 비밀번호 방식으로 ssh 접속을 할 수 있다. </p>
<h2 id="2-privatekey-기반-ssh-로그인-구성"><a href="#2-privatekey-기반-ssh-로그인-구성" class="headerlink" title="2. privatekey 기반 ssh 로그인 구성"></a><strong>2. privatekey 기반 ssh 로그인 구성</strong></h2><p>ssh의 비밀번호 방식을 허용할 경우 Bruteforce 공격의 대상이 된다. </p>
<ul>
<li>이는 aws instance를 생성한 후 아무런 정보 없이도 공격이 매우 많이 쌓이는 것을 확인할 수 있다.</li>
</ul>
<p>이는 임의의 매우 긴 rsa keypair를 사용한다면 공격의 비용이 매우 커지므로 효과적으로 줄일 수 있으며, 일반적인 password에 비해 key의 길이가 훨씬 더 기므로 더 안전할 것이다.</p>
<blockquote>
<p> RSA 방식으로 생성된 key로 로그인하는 방식이다.</p>
<ul>
<li><p>서버에 publickey를 직접 등록한다. (즉, 최초의 rsa 방식의 연결 이전에 미리 서버에 접근할 수 있어야 한다.)</p>
</li>
<li><p>publickey 방식으로 ssh 접속한다.</p>
<ol>
<li>server에서 메시지를 publickey로 암호화한다.</li>
<li>client에서 메시지를 privatekey로 복호화한다.</li>
<li>client에서 메시지를 전송하고, server에서 일치 여부를 확인하고 접근을 허가한다.</li>
</ol>
</li>
</ul>
</blockquote>
<p>[<a target="_blank" rel="noopener" href="https://opentutorials.org/module/432/3742">생활코딩</a>]</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-----내 PC------</span></span><br><span class="line"><span class="comment"># 클라이언트에서 privatekey, publickey 쌍을 생성한다.</span></span><br><span class="line"><span class="comment"># id_rsa가 privatekey, id_rsa.pub이 publickey이다.</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----원격 서버------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 본인 클라이언트에서 생성한 데이터로 파일을 생성한다.</span></span><br><span class="line"><span class="comment"># 굳이 파일로 만드는 이유는 cat으로 redirect하기 위함</span></span><br><span class="line">nano id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; 는 append의 의미이다.</span></span><br><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>


<p>[<a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/127307/how-to-configure-ssh-public-key-per-user">StackExchange</a>]</p>
<p>authorized_keys는 .ssh 밑에 있으므로 유저 한 명의 범위이다.</p>
<p>같은 privatekey로 여러 사용자로 접속하고 싶다면, <code>/home/&#123;USER&#125;/.ssh/authorized_keys</code>에 모두 등록해주어야 한다.</p>
<p>authorized_keys 등록을 하지 않고 passwordlogin을 못하게 설정하면 이후 해당 서버로는 영영 접속할 수 없게 된다.</p>
<ul>
<li>클라우드 상에서 직접 접속할 수 있는 콘솔을 제공하는 경우는 될지도 모르겠다.</li>
</ul>
<h2 id="3-sudo-계정-생성"><a href="#3-sudo-계정-생성" class="headerlink" title="3. sudo 계정 생성"></a><strong>3. sudo 계정 생성</strong></h2><p>네이버 클라우드로 인스턴스를 프로비저닝한 경우 계정이 따로 생성되지 않으므로 직접 생성해야 한다.</p>
<blockquote>
<p>root 계정을 그냥 사용하는 경우의 단점:</p>
<ol>
<li>과도한 권한이 있다. (모든 작업이 가능하다.)</li>
<li>생성한 파일 소유권이 root가 된다. (root 계정의 사용의 악순환 유발)</li>
<li>이름이 root이다. (공격 대상이 되기 매우 쉽다.)</li>
</ol>
</blockquote>
<h3 id="계정-생성"><a href="#계정-생성" class="headerlink" title="계정 생성"></a><strong>계정 생성</strong></h3><p>[<a target="_blank" rel="noopener" href="https://jhnyang.tistory.com/10">jhnyang</a>]</p>
<blockquote>
<p>아래 파일을 생성 즉시 곧장 실행한다면 Permission denied이 발생한다.</p>
<p><code>chmod +x ./&#123;filename&#125;</code>을 수행하여, 실행 권한을 부여한 후 실행(<code>./&#123;filename&#125;</code>)한다.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">NAME=<span class="string">&quot;username&quot;</span></span><br><span class="line">PWD=<span class="string">&quot;password&quot;</span> <span class="comment"># 8글자까지면 상관 없음. 길면 truncate 됨.</span></span><br><span class="line">SHELL=<span class="string">&quot;/bin/bash&quot;</span> <span class="comment"># 배쉬 사용</span></span><br><span class="line">ENC_PWD=<span class="string">&quot;<span class="subst">$(openssl passwd -crypt $PWD)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ENC_PWD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 보통 그룹을 이름과 같게 생성해줌</span></span><br><span class="line">groupadd <span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 사용자 추가</span></span><br><span class="line"><span class="comment"># 비밀번호 지정</span></span><br><span class="line"><span class="comment"># sudo 사용할 수 있게 수정</span></span><br><span class="line"><span class="comment"># 홈 디렉토리 자동 생성</span></span><br><span class="line">useradd -p <span class="variable">$ENC_PWD</span> -s <span class="variable">$SHELL</span> -g <span class="variable">$NAME</span> -G sudo -m <span class="variable">$NAME</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>신기한 점은, home_directory를 자동으로 생성하면, <code>/etc/skel</code>에 있는 파일이 자동으로 복사되지 않아 <code>ll</code>과 같은 alias를 사용할 수 없다는 점이다. 이는 <code>useradd</code>에서 <code>-m</code> 옵션을 주면 자동으로 생성되며 파일들도 잘 복사되어 해결된다.</p>
</li>
<li><p><code>-p</code> 옵션으로 plaintext로 비밀번호를 전달하니 해당 비밀번호로는 로그인할 수 없었다. 암호화를 적용하니 잘 됐는데,  <code>passwd</code>로 변경 시 자동으로 암호화되는 듯하다.</p>
</li>
</ul>
<h3 id="계정-생성-삭제-과정의-명령어들-모음"><a href="#계정-생성-삭제-과정의-명령어들-모음" class="headerlink" title="계정 생성, 삭제 과정의 명령어들 모음"></a><strong>계정 생성, 삭제 과정의 명령어들 모음</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 그룹 조회</span></span><br><span class="line">cat /etc/group</span><br><span class="line"></span><br><span class="line"><span class="comment"># 그룹 생성</span></span><br><span class="line">groupadd <span class="variable">$GROUPNAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 그룹 삭제</span></span><br><span class="line">groupdel <span class="variable">$GROUPNAME</span> (-f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 유저 조회</span></span><br><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 유저 생성</span></span><br><span class="line">useradd <span class="variable">$USERNAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 유저 삭제</span></span><br><span class="line">userdel (-r) <span class="variable">$USERNAME</span> <span class="comment"># -r 로 홈 디렉토리까지 제거</span></span><br></pre></td></tr></table></figure>

<h3 id="sudoer-등록"><a href="#sudoer-등록" class="headerlink" title="sudoer 등록"></a><strong>sudoer 등록</strong></h3><p>나중에 수동으로 sudoer에 등록하려면 간단하다.</p>
<p>sudo 그룹에 사용자명을 추가하면 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/group</span><br><span class="line"></span><br><span class="line">sudo:x:27:user1,user2 <span class="comment"># 여기 뒤에 사용자 명을 추가하면 된다.</span></span><br></pre></td></tr></table></figure>


<h3 id="기본-셸을-bash-사용하게-등록"><a href="#기본-셸을-bash-사용하게-등록" class="headerlink" title="기본 셸을 bash 사용하게 등록"></a><strong>기본 셸을 bash 사용하게 등록</strong></h3><p>나중에 수동으로 bash 셸을 사용하게 하려면 간단하다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 맨 밑 라인으로 가서,</span></span><br><span class="line">sb:x:1001:1001::/home/sb:/bin/sh</span><br><span class="line"><span class="comment"># 에서</span></span><br><span class="line">sb:x:1001:1001::/home/sb:/bin/bash</span><br><span class="line"><span class="comment"># 로 변경한다.</span></span><br></pre></td></tr></table></figure>


<h2 id="4-sshd-보안-설정"><a href="#4-sshd-보안-설정" class="headerlink" title="4. sshd 보안 설정"></a><strong>4. sshd 보안 설정</strong></h2><h3 id="root-계정-로그인-시도-차단"><a href="#root-계정-로그인-시도-차단" class="headerlink" title="root 계정 로그인 시도 차단"></a><strong>root 계정 로그인 시도 차단</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes <span class="comment"># 이걸 no로 바꾸면 된다.</span></span><br></pre></td></tr></table></figure>


<h3 id="비밀번호-접속-차단"><a href="#비밀번호-접속-차단" class="headerlink" title="비밀번호 접속 차단"></a><strong>비밀번호 접속 차단</strong></h3><p>비밀번호 접속을 차단하지 않으면 bruteforce 공격이 매우 많이 들어오게 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PasswordAuthentication yes</span></span><br><span class="line"><span class="comment"># 위 주석을 제거하고 no로 변경한다.</span></span><br></pre></td></tr></table></figure>


<h2 id="5-Docker-및-Docker-compose-설치"><a href="#5-Docker-및-Docker-compose-설치" class="headerlink" title="5. Docker 및 Docker-compose 설치"></a><strong>5. Docker 및 Docker-compose 설치</strong></h2><p>[<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/">Docker Docs</a>] [<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/">Docker Docs</a>]</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Engine 설치</span></span><br><span class="line"><span class="comment"># -y가 필요한 진 모르겠음.</span></span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># compose 설치 (Optional)</span></span><br><span class="line"><span class="comment"># 최신 버전의 도커 엔진은 compose 명령세트가 포함돼서 배포되므로</span></span><br><span class="line"><span class="comment"># docker compose 형식으로 사용하면 되므로 굳이 설치할 필요는 없다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 참고로 apt install로 깔면 무슨 옛날 버전 나온다.</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-25T14:55:00.000Z" title="2021-07-25T14:55:00.000Z">21-07-25</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-25T14:55:46.220Z" title="2021-07-25T14:55:46.220Z">21-07-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">5분안에 읽기 (약 788 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-file-descriptor/">리눅스에서의 파일 디스크립터와 리다이렉션</a></h1><div class="content"><p>이 글은 리눅스에서의 파일 디스크립터와 이를 활용한 리다이렉션에 대해 소개한다.</p>
<hr>
<h3 id="1-리눅스-표준-스트림-3가지와-파일-디스크립터"><a href="#1-리눅스-표준-스트림-3가지와-파일-디스크립터" class="headerlink" title="1. 리눅스 표준 스트림 3가지와 파일 디스크립터"></a><strong>1. 리눅스 표준 스트림 3가지와 파일 디스크립터</strong></h3><blockquote>
<p>각 유닉스 프로세스는 아래 세 개의 표준 스트림에 대응되는 세 개의 POSIX 표준 파일 디스크립터를 갖는다.</p>
</blockquote>
<p>파일 디스크립터란 <code>C int</code> 타입의 값이며 아래에서 소개할 파일 디스크립터 테이블의 index 번호이다.</p>
<p>표준 입력, 출력, 오류 스트림은 각 프로세스의 파일 디스크립터의 0, 1, 2번을 할당받는다.</p>
<table>
<thead>
<tr>
<th align="center">Integer value</th>
<th align="center">Name</th>
<th align="center">symbolic constant</th>
<th align="center">file stream</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stdin">Standard input</a></td>
<td align="center">STDIN_FILENO</td>
<td align="center">stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stdout">Standard output</a></td>
<td align="center">STDOUT_FILENO</td>
<td align="center">stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stderr">Standard error</a></td>
<td align="center">STDERR_FILENO</td>
<td align="center">stderr</td>
</tr>
</tbody></table>
<p>리눅스 셸에서의 Redirect는 기본적으로 파일에 쓰고, 파일에서 읽지만 파일 대신 파일 디스크립터를 사용하고, 파일 디스크립터 앞에 <code>&amp;</code>를 붙이면 그대로 적용된다. </p>
<p>예를 들어, <code>command &gt; 1</code> 은 표준 출력으로 Redirect 하라는 의미가 아니라 파일 <code>1</code>로 출력하라는 것으로 해석되며, <code>command &gt;&amp; 1</code>는 파일 디스크립터 1이 가리키는 파일로 출력하라는 것으로 해석되며, 이는 표준 출력이므로, 정상적으로 출력됨을 확인할 수 있다.</p>
<p>참고로 <code>command 2 &gt;&amp; 1</code>의 경우 표준 오류 스트림이 표준 출력 스트림으로 Redirect되는데 왜 2 앞에는 <code>&amp;</code>가 붙지 않아도 될까? 그 이유는…</p>
<blockquote>
<p>&amp; is only interpreted to mean “file descriptor” in the context of redirections</p>
</blockquote>
<p>라고 한다. (나도 잘 모르겠다. 왜 <code>2&gt;</code>가 stderr를 Redirect 한다는 의미로 쓰일 수 있는지도 모르겠다. 이건 셸 문서를 봐야할듯.)</p>
<p>참고: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/818255/in-the-shell-what-does-21-mean">StackOverFlow</a></p>
<hr>
<h3 id="2-파일-디스크립터-테이블"><a href="#2-파일-디스크립터-테이블" class="headerlink" title="2. 파일 디스크립터 테이블"></a><strong>2. 파일 디스크립터 테이블</strong></h3><p><img src="https://t1.daumcdn.net/cfile/tistory/2778633C56A9E24622"></p>
<p>Process마다 파일 디스크립터 테이블이 하나씩 존재한다. 파일 디스크립터는 index이므로 <code>auto_increment</code>와 같이 1씩 증가하며 발급된다. (따라서 Process에서 처음 파일 디스크립터를 발급 받는 경우 3부터 시작한다.)</p>
<p>아래와 같은 함수들이 파일 디스크립터를 하나 생성한다. (<code>&lt;unistd.h&gt;</code>에 정의돼있다.)</p>
<ul>
<li><code>open()</code></li>
<li><code>creat()</code></li>
<li><code>socket()</code></li>
<li><code>accept()</code></li>
</ul>
<p>네트워크 관련해서도 <code>select()</code>, <code>bind()</code>, <code>listen()</code>, <code>connect()</code> 등 파일 디스크립터와 관련된 함수들이 많은데 아직 C/C++ 기반 TCP/IP 프로그래밍을 해보지 못해서 추후에 다루려고 한다.</p>
<hr>
<h3 id="3-파일-디스크립터-조회-및-제한"><a href="#3-파일-디스크립터-조회-및-제한" class="headerlink" title="3. 파일 디스크립터 조회 및 제한"></a><strong>3. 파일 디스크립터 조회 및 제한</strong></h3><p><code>ls -trn</code> 명령으로 프로세스별 파일 디스크립터를 조회할 수 있다.</p>
<p><img src="/images/linux-file-descriptor/get_fd_by_pid.png"></p>
<p><code>ulimit</code> 명령으로 프로세스별 파일 디스크립터 개수의 제한 역시 조회할 수 있다.</p>
<p>이 명령은 또한 그 제한을 바꿀 수도 있는데, ulimit의 open files의 경우 65535까지 가능했다. (이를 초과해서는 root 권한으로도 할 수 없었다.)</p>
<p><img src="/images/linux-file-descriptor/ulimit-a.png"></p>
<hr>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-17T14:58:00.000Z" title="2021-07-17T14:58:00.000Z">21-07-17</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-17T14:58:53.820Z" title="2021-07-17T14:58:53.820Z">21-07-17</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">6분안에 읽기 (약 869 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-env-security/">환경 변수와 보안</a></h1><div class="content"><p>이 글은 리눅스의 환경 변수에 대해 설명하고, 환경 변수가 얼마나 안전한지 다룬다.</p>
<hr>
<h3 id="1-환경-변수의-종류"><a href="#1-환경-변수의-종류" class="headerlink" title="1. 환경 변수의 종류"></a><strong>1. 환경 변수의 종류</strong></h3><p>출처: <a target="_blank" rel="noopener" href="http://howtolamp.com/articles/difference-between-local-and-environment-variables/">howtolamp</a>, <a target="_blank" rel="noopener" href="https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-linux">digitalocean</a></p>
<p>환경 변수란 String Key-Value 쌍으로, 두 종류가 있다. Local Env와 Global Env가 있는데, Local Env는 셸에서 사용되는 변수를 의미하고, Global Env는 흔히 말하는 환경 변수를 의미한다. </p>
<h3 id="2-환경-변수의-조회와-변경"><a href="#2-환경-변수의-조회와-변경" class="headerlink" title="2. 환경 변수의 조회와 변경"></a><strong>2. 환경 변수의 조회와 변경</strong></h3><p>Local Env는 <code>set</code> 명령으로 조회할 수 있고, 환경 변수는 <code>env</code> 명령으로 조회할 수 있다.</p>
<p>Local Env를 <code>set</code>로 조회하는 경우, 셸 변수, 환경 변수, 로컬 변수, 셸 함수가 출력된다.</p>
<p>Local Env는 <code>&#123;KEY&#125;=&#123;VALUE&#125;</code> 형태로 등록할 수 있으며, <code>set | grep &#123;KEY&#125;=</code> 으로 반영됐는지 확인해볼 수도 있다. 단 이런 방식으로 등록한 경우 <code>printenv | grep &#123;KEY&#125;</code>로 확인하면 등록되지 않음을 확인할 수 있다.</p>
<blockquote>
<p>printenv는 환경 변수 출력 면에서 env와 같다. 자세한 내용은 <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/123473/what-is-the-difference-between-env-and-printenv">stackoverflow</a> 참고</p>
</blockquote>
<p>등록된 Local Env는 셸에서 <code>$&#123;KEY&#125;</code>로 참조할 수 있다. 즉, <code>echo $&#123;KEY&#125;</code>로 출력할 수 있다.</p>
<p>Global Env를 등록하려면 <code>export &#123;KEY&#125;=&#123;VALUE&#125;</code>를 사용한다.</p>
<h3 id="3-Local-Env의-범위"><a href="#3-Local-Env의-범위" class="headerlink" title="3. Local Env의 범위"></a><strong>3. Local Env의 범위</strong></h3><p>Local Env는 현재 셸 프로세스 및 자식 프로세스 범위에서만 존재한다. 즉, 새로운 터미널 등에서 실행한 셸 프로세스에서 <code>echo $&#123;KEY&#125;</code>를 수행하면 아무것도 나오지 않음을 확인할 수 있다.</p>
<h3 id="4-Global-Env의-범위"><a href="#4-Global-Env의-범위" class="headerlink" title="4. Global Env의 범위"></a><strong>4. Global Env의 범위</strong></h3><p>Global Env의 경우 모든 프로세스에서 접근이 가능하다. </p>
<h3 id="5-Process-별-Env"><a href="#5-Process-별-Env" class="headerlink" title="5. Process 별 Env"></a><strong>5. Process 별 Env</strong></h3><p><code>/proc/&#123;pid&#125;/environ</code>로 프로세스에서 사용되는 환경 변수를 조회할 수 있다. 이 경우 프로세스에 접근할 수 있는 권한이 필요하다.</p>
<blockquote>
<p>정확히 무슨 권한이 필요한지는 더 공부가 필요하다.</p>
</blockquote>
<h3 id="6-환경변수의-안전성-secureness"><a href="#6-환경변수의-안전성-secureness" class="headerlink" title="6. 환경변수의 안전성(secureness)"></a><strong>6. 환경변수의 안전성(secureness)</strong></h3><p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12461484/is-it-secure-to-store-passwords-as-environment-variables-rather-than-as-plain-t">stackoverflow</a></p>
<p>환경 변수에 중요 정보를 저장하는 것은 안전하지 않다. 보통 환경 변수가 사용되는 경우는 Credential을 배포할 때인데, 패스워드 등을 저장한 파일과 비교했을 때 더 안전하지는 않다고 한다.</p>
<p>그럼에도 환경 변수를 쓰는 이유가 뭘까?</p>
<blockquote>
<p>As mentioned before, both methods do not provide any layer of additional “security” once your system is compromised. I believe that one of the strongest reasons to favor environment variables is version control: I’ve seen way too many database configurations etc. being accidentially stored in the version control system like GIT for every other developer to see (and whoops! it happened to me as well …).</p>
<p>Not storing your passwords in files makes it impossible for them to be stored in the version control system.</p>
</blockquote>
<p>즉, Git 등으로 관리하면 실수할 여지가 크기 때문에 환경 변수를 사용한다고 한다.</p>
<p>배포 측면에선 환경 변수가 편리하지만 둘 다 안 좋은 방법이다.</p>
<blockquote>
<p>a library author could email stack traces plus the ENV variables to themselves for debugging</p>
</blockquote>
<p>즉 라이브러리 등에서도 모두 접근이 가능하기 때문에 (ex: NodeJs의 경우 <code>process.env</code>) 디버깅 혹은 스택 트레이스가 서버로 전송될 수도 있어서, 이런 경우 훨씬 위험할 수 있다.</p>
<hr>
<h3 id="7-환경변수는-안전한가"><a href="#7-환경변수는-안전한가" class="headerlink" title="7. 환경변수는 안전한가?"></a><strong>7. 환경변수는 안전한가?</strong></h3><p>그렇지 않다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-04T14:55:00.000Z" title="2021-07-04T14:55:00.000Z">21-07-04</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-03T08:24:28.238Z" title="2021-07-03T08:24:28.238Z">21-07-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">4분안에 읽기 (약 571 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-virtualization-1/">리눅스에서의 가상화 솔루션의 종류와 특성 (1)</a></h1><div class="content"><blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64)</p>
</blockquote>
<p>이 글은 가상화에 대해 간략히 소개한다. 다음 글에서 리눅스에서의 가상화에 대해 조금 더 깊게 다룰 예정이다.</p>
<hr>
<h3 id="가상화란"><a href="#가상화란" class="headerlink" title="가상화란"></a><strong>가상화란</strong></h3><p>물리 자원을 추상화하는 방법 중 하나로, 하나의 물리 자원을 여러 개의 논리적 자원으로 나누거나, 여러 물리 자원을 하나의 논리적 자원으로 다루는 것을 말한다.</p>
<ul>
<li><p>각 자원이 서로에게 영향을 끼치지 못하므로, 장애 전파가 되지 않는다.</p>
</li>
<li><p>논리적인 자원을 유지하면서, 물리적인 자원을 교체할 수 있다.</p>
</li>
<li><p>물리적 자원간의 약간의 차이를 무시하기 위해 일반 사양으로 논리적 자원을 구성할 수 있다.</p>
</li>
</ul>
<hr>
<h3 id="가상화의-원리와-Linux에서의-가상화"><a href="#가상화의-원리와-Linux에서의-가상화" class="headerlink" title="가상화의 원리와 Linux에서의 가상화"></a><strong>가상화의 원리와 Linux에서의 가상화</strong></h3><p>기본적으로 가상화는 HW에서 지원해줘야 한다. 실제 CPU에 Guest OS를 실행했을 때, Guest OS가 제어권을 Host OS로 반환할 지 알 수 없기 때문이다. 따라서, HW는 Host OS가 관리할 수 있는 방식의 규칙과 제약을 제공한다. <a target="_blank" rel="noopener" href="https://superuser.com/questions/758018/how-does-virtualizing-differ-from-emulation-in-terms-of-structure">출처</a></p>
<p>가상화 방식은 크게 Type 1 (= Full Virtualization), Type 2(= Para Virtualization) 가 있는데, 리눅스에서는 KVM, XEN이 주요 가상화 솔루션이다. </p>
<ul>
<li><p>Type 1의 경우 OS 레벨 아래에 Virtual Machine Monitor(Hypervisor)가 HW Layer 사이에 낀 Layer로 하드웨어를 가상화한다. KVM이 Type 1이며, Windows Hyper-V도 Type 1이다.</p>
</li>
<li><p>Type 2의 경우 Host OS와 Guest OS 사이에 Hypervisor가 위치한다. VirtualBox, VMWare 등이 Type 2이다. Mac의 경우 Parallels가 Type 2이다.</p>
</li>
<li><p>Type 2의 경우 상대적으로 높은 성능을 제공한다고 알려져 있다. </p>
</li>
<li><p>다만 Type 2 방식은 기존 OS에 수정을 해서 Guest OS를 만들어야 한다는 단점이 있다. </p>
</li>
<li><p>리눅스는 Type 2 방식의 Guest OS를 잘 지원한다.</p>
</li>
<li><p>Docker의 경우 컨테이너 기술이 커널 위에서 지원되므로 Hypervisor가 필요 없으나, Windows 및 Mac에서는 Linux Kernel이 필요하므로 리눅스 OS를 가상화로 띄워야 하므로 Hypervisor가 필요하다.</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-27T14:55:00.000Z" title="2021-06-27T14:55:00.000Z">21-06-27</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-27T14:59:23.390Z" title="2021-06-27T14:59:23.390Z">21-06-27</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">4분안에 읽기 (약 606 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-sshd-security/">리눅스 - ssh/sshd의 보안에 대해 (2/2)</a></h1><div class="content"><p>이 글은 <a href="https://jsqna.com/linux-sshd-logs">1편</a>에 이어 SSHD의 보안 설정을 다룬다. SSHD의 설정 파일은 <code>/etc/ssh/sshd_config</code> 인데 아래의 내용은 해당 파일의 설정을 다룬다. 설정을 변경한 경우 <code>sudo systemctl restart sshd</code>로 SSHD를 재시작해줘야 한다. (WSL의 경우 systemctl이 지원되지 않는데, 단순히 <code>sudo service ssh --full-restart</code>를 실행하면 된다.)</p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64)<br>OpenSSH_8.2p1 Ubuntu-4ubuntu0.2, OpenSSL 1.1.1f  31 Mar 2020</p>
</blockquote>
<hr>
<h3 id="SSH-비밀번호-시도-횟수-제한"><a href="#SSH-비밀번호-시도-횟수-제한" class="headerlink" title="SSH 비밀번호 시도 횟수 제한"></a><strong>SSH 비밀번호 시도 횟수 제한</strong></h3><p>기본 설정은 사용자의 비밀번호 입력 오류가 아무리 많아도 접속을 끊지 않는데, 이 횟수를 제한하고 횟수를 넘으면 접속을 끊을 수 (<em>Too many authentication failures</em>) 있다. <code>#MaxAuthTries 6</code> 으로 적혀있는 주석(<code>#</code>)을 제거하면 된다. </p>
<hr>
<h3 id="SSH-포트-변경"><a href="#SSH-포트-변경" class="headerlink" title="SSH 포트 변경"></a><strong>SSH 포트 변경</strong></h3><p><code>#Port 22</code> 에서 <code>Port 2222</code> 등으로 변경해 포트를 변경할 수 있다. 변경된 포트로의 접속은 <code>ssh -p2222 sb@localhost</code> 로 포트를 옵션으로 제공해 접속할 수 있다.</p>
<hr>
<h3 id="프로토콜-버전-2-사용-1-사용-금지"><a href="#프로토콜-버전-2-사용-1-사용-금지" class="headerlink" title="프로토콜 버전 2 사용 (1 사용 금지)"></a><strong>프로토콜 버전 2 사용 (1 사용 금지)</strong></h3><p><code>Protocol 2</code> 라고 명시하므로써 SSH 프로토콜 1을 사용할 수 없게할 수 있다. (버전 2는 2006년에 나왔으므로, 버전 1이 얼마나 예전 버전인지 가늠할 수 있다… 1-&gt;2는 보안 위주의 개선이 있었다고 한다.)</p>
<blockquote>
<p>OpenSSH_8.2p1 Ubuntu-4ubuntu0.2, OpenSSL 1.1.1f  31 Mar 2020</p>
</blockquote>
<p>Ubuntu 20.04에서의 SSHD (8.2p1) 에서는 이미 해당 옵션이 기본이고, 설정 파일에 존재하지 않는다.</p>
<p>Protocol 2가 활성화된 경우, <code>ssh -1 sb@localhost</code>로 접속을 시도하는 경우 <code>SSH protocol v.1 is no longer supported</code>가 표시되며 접속이 거부된다.</p>
<hr>
<h3 id="비밀번호-기반-접속-방식-미사용"><a href="#비밀번호-기반-접속-방식-미사용" class="headerlink" title="비밀번호 기반 접속 방식 미사용"></a><strong>비밀번호 기반 접속 방식 미사용</strong></h3><p>비밀번호로 접속하는 방식은 브루트 포스 공격의 여지를 주게 되고, SSH Key 기반의 접속이 보편화된 요즘 필요성 또한 낮다.</p>
<p><code>PasswordAuthentication no</code> 옵션을 주면 비밀번호로는 접속할 수 없게 된다. (이 글에서의 openssh server는 기본 설정으로 no이다.)</p>
<hr>
<h3 id="루트-계정으로의-접속-금지"><a href="#루트-계정으로의-접속-금지" class="headerlink" title="루트 계정으로의 접속 금지"></a><strong>루트 계정으로의 접속 금지</strong></h3><p>루트 계정으로의 접속은 차단하는 것이 좋다. 애초에 루트 계정으로 접속할 수 있더라도, 접속하지 않는 것이 좋으므로 차단하도록 한다.</p>
<p><code>PermitRootLogin no</code> 옵션을 주면 된다. (신기하게도 기본 옵션이 아니다.)</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-20T14:00:00.000Z" title="2021-06-20T14:00:00.000Z">21-06-20</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-20T13:56:51.790Z" title="2021-06-20T13:56:51.790Z">21-06-20</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">6분안에 읽기 (약 973 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-system-log-1/">리눅스 - 시스템 로그와 로그인 로그</a></h1><div class="content"><p>이 글은 리눅스에서 기본으로 작성되는 로그 파일에 대해 간단하게 소개한다. 로그 파일의 내용, 작성되는 구조와 그 활용 방법까지 알아보려고 했으나, 범위가 너무 커지는 것 같아 이후 글의 주제로 남겨두려 한다.</p>
<hr>
<h2 id="rsyslogd와-var-log-디렉토리"><a href="#rsyslogd와-var-log-디렉토리" class="headerlink" title="rsyslogd와 /var/log 디렉토리"></a><strong>rsyslogd와 /var/log 디렉토리</strong></h2><p>rsyslog란 rocket-fast system for log processing의 약자로, 기존의 syslog 라는 로깅 데몬을 대체하는 시스템 로깅 데몬이다.</p>
<p><code>/var/log</code> 디렉토리에 생성된 로그 파일은 rsyslog에 의해 작성된 것들이다. 시스템 데몬이, 시스템 서비스의 로그를 수집한 것이기 때문에 애플리케이션 로그는 포함되지 않는다.</p>
<p>아래는 syslog 파일 내용 중 일부이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Jun 20 11:52:14 instance-01 kernel: [    0.000000] On node 0 totalpages: 523966</span><br><span class="line">Jun 20 11:52:14 instance-01 kernel: [    0.000000]   DMA zone: 64 pages used <span class="keyword">for</span> memmap</span><br><span class="line">Jun 20 11:52:14 instance-01 systemd[1]: Starting SSHGuard...</span><br><span class="line">Jun 20 11:52:15 instance-01 ntp[1577]:  * Starting NTP server ntpd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{ 출력 시간, 호스트명, 프로세스명, PID, 로그 내용 }</p>
</blockquote>
<p>위의 로그를 보면 특정 형식으로 작성되어있고, 여러 프로세스에서 출력이 됨을 알 수 있다. </p>
<p>굳이 호스트명이 포함된 이유는 로그를 중앙 집중식으로 저장하고 분석, 시각화하는 로그 서버로의 전송을 고려했다고 한다. (참고로 syslog의 설정을 통해 원격 서버로 파일을 전송할 수 있다. 그리고, 여러 서버의 로그를 중앙에서 저장하는 경우 ntpdate 등의 유틸을 사용한 시간 동기화가 필수라고 한다.)</p>
<p>로그 내용은 아는 만큼 보이기 때문에, 또 리눅스의 자체 기능의 로그만이 들어있기 때문에 특정 metric을 잡고 이게 이런 의미이다.와 같은 판단을 내리기가 어려운 듯하다. 이건 로그를 공부할 게 아니라, 리눅스 자체의 기능을 공부해야 이해할 수 있는 부분으로 보인다.</p>
<hr>
<h2 id="로그인과-관련된-로그-모음"><a href="#로그인과-관련된-로그-모음" class="headerlink" title="로그인과 관련된 로그 모음"></a><strong>로그인과 관련된 로그 모음</strong></h2><h4 id="auth-log"><a href="#auth-log" class="headerlink" title="auth.log"></a><strong>auth.log</strong></h4><p>인증 관련해선 (즉, SSH 위주) 로그 파일이 이 파일에 작성된다. 아마 단일 파일로는 auth.log가 제일 크지 않을까 싶은데, 대략 btmp(아래에서 소개)의 2배 정도의 파일 크기를 갖는 듯하다. (아무래도 SSH 접속 시도가 잦기 때문이다.)</p>
<hr>
<h4 id="로그인-성공-기록"><a href="#로그인-성공-기록" class="headerlink" title="로그인 성공 기록"></a><strong>로그인 성공 기록</strong></h4><p>last는 사용자 로그인 현황을 반환하는 명령어이다(성공한 로그인만 기록한다). wtmp 파일은 로그인, 로그아웃 기록이 저장되는 파일이다.</p>
<p><img src="/images/linux-system-log/last.png"></p>
<hr>
<h4 id="로그인-실패-기록"><a href="#로그인-실패-기록" class="headerlink" title="로그인 실패 기록"></a><strong>로그인 실패 기록</strong></h4><p>재밌는 점은 로그인 실패의 경우 <code>lastb</code>라는 별개의 명령어로 조회할 수 있다는 점이다. 또, 잘 보면 로그인 실패 기록이 매우 매우 많다. 얼마나 많냐면, wtmp 파일의 크기는 9.0K 인데, btmp는 576K 이다!</p>
<p><img src="/images/linux-system-log/lastb.png"></p>
<hr>
<h4 id="현재-로그인된-세션"><a href="#현재-로그인된-세션" class="headerlink" title="현재 로그인된 세션"></a><strong>현재 로그인된 세션</strong></h4><p>명령어 who를 입력하면 현재 로그인 세션 정보를 출력한다. 세션 정보는 utmp 파일에 저장된다. 다만 utmp파일은 /var/log 디렉토리에서 바로 보이진 않았다.</p>
<p><img src="/images/linux-system-log/who.png"></p>
<hr>
<h2 id="SEE-ALSO"><a href="#SEE-ALSO" class="headerlink" title="SEE ALSO"></a><strong>SEE ALSO</strong></h2><p>test/test 계정을 만들어 놓고 해커가 어떤 형태로 접속하고 무슨 일을 했는 지 분석한 글: <a target="_blank" rel="noopener" href="https://whackur.tistory.com/88">우분투 리눅스 침투 사후 로그보기</a>도 참고하면 재밌을 것 같다 :)</p>
<hr>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h2><ol>
<li><p>ELK 기반으로 로그를 중앙 집중식으로 받아와 질의와 시각화를 할 수 있을 것 같은데 나중에 다뤄보려고 한다.</p>
</li>
<li><p>sshd, common_auth 파일 무슨 PAM 개념이 나오던데, 잘 조사해서 SSH 보안 설정에 대해 다뤄보려고 한다.</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-13T14:55:00.000Z" title="2021-06-13T14:55:00.000Z">21-06-13</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-27T14:17:29.020Z" title="2021-06-27T14:17:29.020Z">21-06-27</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">4분안에 읽기 (약 609 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-sshd-logs/">리눅스 - ssh/sshd의 보안에 대해 (1/2)</a></h1><div class="content"><p>이 글은 리눅스의 RDP나 다름 없는 SSH에 대해 간략히 소개하고, 보안 측면에서의 기능을 일부 다룬다.</p>
<hr>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a><strong>SSH</strong></h3><p>SSH는 22번 포트를 사용하며 HTTPS와 같이 안전한 Layer를 감싼 Remote Shell이다. 접속 대상 Host는 SSH Daemon이 띄워져있어야 하며 OpenSSH(<code>openssh-server</code>)이 실질적 표준이다.</p>
<hr>
<h3 id="SSH-포트-변경"><a href="#SSH-포트-변경" class="headerlink" title="SSH 포트 변경"></a><strong>SSH 포트 변경</strong></h3><p>SSH를 인터넷 대상으로 Open(ALLOW 0.0.0.0)하는 경우 어떻게 알고 찾아왔는지, 아래와 같이 많은 곳에서 임의의 접근을 다수 받을 수 있다. 따라서 22번 포트에서 임의의 포트로 바꾸는 것이 기본이라고 할 수 있다. (물론 그래도 공격은 충분히 가능하다.)</p>
<hr>
<h3 id="SSH-로그-확인"><a href="#SSH-로그-확인" class="headerlink" title="SSH 로그 확인"></a><strong>SSH 로그 확인</strong></h3><p>SSH 로그는 sshd 접속 기록이 없는 경우 딱히 기록되지 않으니, 클라우드에서 SSH port를 Open해 놓고 하루 정도만 기다려도 로그가 많이 쌓이게 된다(ㅎㅎ..). 아래의 커맨드로 쉽게 확인할 수 있으며, <code>auth.log</code> 파일 자체는 다른 내용도 많이 담고 있으며, 파일이 커지면 <code>auth.log.1</code>과 같이 rolling 된다.</p>
<blockquote>
<p>$ cat /var/log/auth.log | grep sshd</p>
</blockquote>
<p><img src="/images/linux-sshd/sshd_log.png" alt="단순히 시도한 사용자명만 나열해도 이정도..."></p>
<hr>
<h3 id="Bation-Host-사용"><a href="#Bation-Host-사용" class="headerlink" title="Bation Host 사용"></a><strong>Bation Host 사용</strong></h3><p><img src="/images/linux-sshd/bastion_host.png" alt="로드밸런서, 배스쳔 호스트 예시"></p>
<hr>
<p>물론 접속 자체를 특정 네트워크 대역(고정 IP겠죠?)으로 제한하고, 특정 네트워크로 VPN을 사용해도 되겠지만, 그렇게 하기 어려운 경우라면 Bastion Host를 사용하는 것도 방법이다. 애플리케이션 서버 등은 보통 로드 밸런서 뒤에 숨기 때문에 굳이 외부로 노출되지 않는데 SSH 때문에 이를 Public Subnet으로 옮기는 것도 좋지 못하므로, 낮은 사양의 PC를 인터넷 대역에 오픈하고 해당 PC만이 내부망의 서버들과 통신할 수 있도록 하면 적절하다.</p>
<hr>
<p><img src="/images/linux-sshd/sshd_example_arch.png" alt="로드밸런서, 배스쳔 호스트 예시"></p>
<hr>
<p>SSH Proxy와 같은 여러 얘기가 있지만 간단하게 command를 실행시키는 형태로 쉽게 접속이 가능하다.</p>
<blockquote>
<p>$ ssh -t user@BASTION_HOST ssh user@INTERNAL_SERVER</p>
</blockquote>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>SSH의 많은 설정 중 보안에 관련된 설정을 더 알아보기</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-06T14:43:00.000Z" title="2021-06-06T14:43:00.000Z">21-06-06</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-06T14:43:18.680Z" title="2021-06-06T14:43:18.680Z">21-06-06</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">7분안에 읽기 (약 1118 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-ufw/">우분투의 SW 기반 방화벽 - UFW</a></h1><div class="content"><p>이 글은 데비안 계열(우분투 등)에서 사용되는 ufw에 대해 다룬다. ufw는 iptables라는 유틸을 활용하는 유틸이고, iptables는 리눅스 커널의 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netfilter">netfilter</a>라는 기능의 인터페이스(CLI)이다. 많은 사람들이 간단한 보안 수요에 대해서는 iptables의 복잡성 때문에 ufw를 사용하는 것을 권장한다.</p>
<blockquote>
<p>iptables is a command line interface of netfilter, which is the underlying mechanics in the kernel for all of the work related. It has been (mostly) replaced by nftables (netfilter-tables) which provides more (advanced) features and a unified interface for IPv4/IPv6/ARP/Ethernet Bridges. But both iptables and nftables requires manually writing rules since they are kind of low-level.</p>
<p>UFW wraps around nftables (used to be iptables&amp;ip6tables) and provides a much-easier-to-use command line interface for managing basic firewall functionalities, hence its name.</p>
<p>I personally recommend using UFW directly if all you want is a simple firewall. Otherwise you may use firewalld or write iptables/nftables rules directly.</p>
</blockquote>
<p>출처: <a target="_blank" rel="noopener" href="https://www.quora.com/What-is-the-difference-between-iptables-and-uncomplicated-firewall-UFW-in-Linux">Quora</a></p>
<hr>
<p>iptables는 아래 도표 중 hook API를 활용하는 인터페이스이다.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Netfilter-components.svg/2880px-Netfilter-components.svg.png" alt="img"></p>
<hr>
<p>아래는 Netfilter와 리눅스 내, 외부의 처리 흐름이라고 한다.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Netfilter-packet-flow.svg/2880px-Netfilter-packet-flow.svg.png" alt="img"></p>
<hr>
<p>Netfilter와 Iptables에 대해 더 자세히 알고 싶은 경우 <a target="_blank" rel="noopener" href="https://www.kangtaeho.com/66">iptables와 netfilter 정리 | 리눅스, 클라우드, IT 관련 기술 블로그</a>를 참고하기 바란다.</p>
<hr>
<h3 id="1-사용해야-할-때"><a href="#1-사용해야-할-때" class="headerlink" title="1. 사용해야 할 때"></a><strong>1. 사용해야 할 때</strong></h3><p>ufw를 언제 써야 할까? 해당 Host의 앞 단에 보안 장비가 없고, 포트 접근 제어가 필요할 때이다. 리눅스를 클라이언트로 사용하는 경우 열린 포트가 없어 비교적 안전하지만 서버 단의 경우 그렇지 않다.</p>
<hr>
<h3 id="2-간단한-사용법"><a href="#2-간단한-사용법" class="headerlink" title="2. 간단한 사용법"></a><strong>2. 간단한 사용법</strong></h3><p>ufw는 기본적으로 비활성화돼있는데, <code>sudo ufw enable</code> 로 활성화할 수 있다. 활성화 시 기본 설정만으로도 iptables의 NAT Table 설정이 자동 생성된다. 이는 ufw가 iptables의 wrapper이자 간단한 설정을 상세한 설정으로 변환시키는 역할을 담당함을 보여준다. (출처: <a target="_blank" rel="noopener" href="https://thebook.io/006718/part02/ch05/06/">초보 시스템 관리자의 일기 | 우분투 방화벽 ufw로 시스템 보호하기</a>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">administrator@test02:~$ sudo iptables -L</span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target prot opt <span class="built_in">source</span>                    destination</span><br><span class="line">ufw-before-logging-input all -- anywhere                anywhere</span><br><span class="line">ufw-before-input all -- anywhere                 anywhere</span><br><span class="line">ufw-after-input all -- anywhere                 anywhere</span><br><span class="line">ufw-after-logging-input all -- anywhere                anywhere</span><br><span class="line">ufw-reject-input all -- anywhere                 anywhere</span><br><span class="line">ufw-track-input all -- anywhere                 anywhere</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target prot opt <span class="built_in">source</span>                    destination</span><br><span class="line">ufw-before-logging-forward all -- anywhere                anywhere</span><br><span class="line">ufw-before-forward all -- anywhere                anywhere</span><br><span class="line">ufw-after-forward all -- anywhere                anywhere</span><br><span class="line">ufw-after-logging-forward all -- anywhere                anywhere</span><br><span class="line">ufw-reject-forward all -- anywhere                anywhere</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target prot opt <span class="built_in">source</span>                    destination</span><br><span class="line">ufw-before-logging-output all -- anywhere                anywhere</span><br><span class="line">ufw-before-output all -- anywhere                anywhere</span><br><span class="line">ufw-after-output all -- anywhere                anywhere</span><br><span class="line">ufw-after-logging-output all -- anywhere                anywhere</span><br><span class="line">ufw-reject-output all -- anywhere                anywhere</span><br><span class="line">ufw-track-output all -- anywhere                anywhere</span><br><span class="line"></span><br><span class="line">Chain ufw-after-forward (1 references)</span><br><span class="line">...</span><br><span class="line">Chain ufw-after-input (1 references)</span><br><span class="line">...</span><br><span class="line">Chain ufw-after-logging-forward (1 references)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<hr>
<p>ufw의 사용법은 매우 간단하다. <code>ufw &#123;action&#125; &#123;port | serviceName&#125;</code>를 입력하면 된다. 이 때 서비스의 목록은 <code>cat /etc/services</code>로 확인할 수 있고, <code>ufw deny ssh</code>와 같이 사용할 수 있다. 아래와 같이 ufw도 status 명령을 지원한다. (<code>iptables -L</code>에 비해 가독성이 훨씬 낫다.)</p>
<p><img src="/images/linux-ufw/ufw_deny_status.png" alt="ufw_deny_status"></p>
<hr>
<p>ufw는 기본적으로 whitelisting이지만, <code>ufw default allow</code>를 실행하면 blacklisting으로 전환할 수 있다.</p>
<hr>
<p>ufw의 규칙을 제거하려면 <code>ufw delete &#123;규칙 내용&#125;</code> 으로 가능하다.</p>
<p><img src="/images/linux-ufw/ufw_delete_deny.png" alt="ufw_delete_deny"></p>
<hr>
<h3 id="3-‘우선-규칙’-적용하기"><a href="#3-‘우선-규칙’-적용하기" class="headerlink" title="3. ‘우선 규칙’ 적용하기"></a><strong>3. ‘우선 규칙’ 적용하기</strong></h3><p>보안 설정의 경우 우선 정의한 규칙이 적용된다고 한다. 즉, 순차적으로 ALLOW를 check하고, ALLOW되는 경우 통과하는 것이다. 이 경우 넓은 범위의 규칙은 뒤에 놓고, 좁은 범위의 (IP 차단 등) 규칙은 앞에 놓는 게 맞다.</p>
<p>‘우선 규칙’은 <code>sudo nano /etc/ufw/before.rules</code>에서 작성할 수 있다. <code>End required lines</code> 주석 아래에 <code>-A ufw-before-input -s &#123;Target_IP_Address, ...&#125; -j DROP</code> 을 추가하면 해당 IP를 모든 포트에 대해 접근 제한할 수 있다. (<a target="_blank" rel="noopener" href="https://happist.com/561474/%EC%9A%B0%EB%B6%84%ED%88%AC-18-04%EB%A1%9C-%EC%84%9C%EB%B2%84-%EC%9A%B4%EC%98%81-ufw%EB%A1%9C-%EB%B0%A9%ED%99%94%EB%B2%BD-%EC%84%A4%EC%A0%95">출처</a>)</p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>Logging에 대해 더 알아보기. (리눅스 로깅은 분량이 많고 어려운 것 같다.)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://serverfault.com/questions/516838/where-are-the-logs-for-ufw-located-on-ubuntu-server">https://serverfault.com/questions/516838/where-are-the-logs-for-ufw-located-on-ubuntu-server</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rsyslog.com/">https://www.rsyslog.com/</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-30T14:35:00.000Z" title="2021-05-30T14:35:00.000Z">21-05-30</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-30T14:34:58.590Z" title="2021-05-30T14:34:58.590Z">21-05-30</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">5분안에 읽기 (약 751 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-filesystem-ext/">리눅스 파일 시스템의 구조 - ext 계열</a></h1><div class="content"><p>이 글은 리눅스에서의 파일 시스템 중 ext 계열에 대해 설명한다.</p>
<hr>
<h3 id="1-ext2"><a href="#1-ext2" class="headerlink" title="1. ext2"></a><strong>1. ext2</strong></h3><p>ext2는 (ext를 개선한) 리눅스의 초기 파일 시스템이다. 개선된 버전인 ext3, ext4도 있으나, 많은 자료에서 ext2를 비중 있게 다루므로 이 글에서도 동일한 형태로 ext2를 위주로 서술한다.</p>
<hr>
<p><img src="https://i.stack.imgur.com/cP4XD.png" alt="ext disk layout"></p>
<hr>
<p>ext2는 디스크를 부트 섹터와 <strong>블록 그룹</strong>으로 분할한다. 블록 그룹이란, 일정한 크기의 블록의 집합을 의미한다. (정확히는 마지막 블록은 크기 제한에서 자유롭다.)</p>
<ul>
<li><p>파일 저장 시 동일한 블록 그룹 내에 저장하도록 스케줄링한다.</p>
</li>
<li><p>블록 그룹은 아래의 필드를 갖는다. 아래의 필드 중 Super Block, Group Descriptor Table은 하나만 있어도 충분하나 백업 용도로 각 블록 그룹에 사본으로 저장된다(일관성 유지에 대한 내용은 잘 모르겠다.)</p>
<table>
<thead>
<tr>
<th>필드명</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Super Block</td>
<td>1KB의 크기의 자료구조로, 블록의 크기, 총 블록의 개수, 블록 그룹의 개수, i-node의 개수, 그룹 내 블록의 개수, 그룹 내 i-node의 개수 등의 정보를 저장한다.</td>
</tr>
<tr>
<td>Group Descriptor Table</td>
<td>Group Descriptor의 <strong>테이블</strong>이다. 각 Descriptor는 Block Bitmap(아래 필드)의 블록 번호, 그룹 내의 빈 블록 개수, 그룹 내의 i-node 개수, 그룹 안의 빈 디렉토리 개수를 저장한다.</td>
</tr>
<tr>
<td>Block Bitmap</td>
<td>각 블록의 할당 여부를 bit(0,1)로 표시한다.</td>
</tr>
<tr>
<td>i-node Bitmap</td>
<td>i-node의 할당 여부를 bit로 표시한다.</td>
</tr>
<tr>
<td>i-node Table</td>
<td>아래의 i-node를 테이블 형태로 저장한다.</td>
</tr>
<tr>
<td>(actual) i-nodes</td>
<td>(위의 테이블 형태로 저장된 것이다.) 128Byte의 크기를 가지며, 실제 파일/디렉토리의 위치를 저장한다. 파일의 메타 데이터를 보관한다. 각 파일/디렉토리는 i-node와 1:1로 대응되며 i-node를 알고 있다면 i-node에 저장된 블록 그룹을 확인할 수 있다. (자세한 필드는 아래 표에서 확인바란다.)</td>
</tr>
<tr>
<td>(actual) blocks</td>
<td>실제로 데이터가 저장되는 블록이다.</td>
</tr>
</tbody></table>
</li>
<li><p>i-node를 구성하는 필드는 아래와 같다.</p>
<table>
<thead>
<tr>
<th>필드명</th>
</tr>
</thead>
<tbody><tr>
<td>Inode Number</td>
</tr>
<tr>
<td>파일 모드</td>
</tr>
<tr>
<td>하드 링크 개수</td>
</tr>
<tr>
<td>소유자 정보</td>
</tr>
<tr>
<td>파일 크기</td>
</tr>
<tr>
<td>마지막 접근/수정 시각</td>
</tr>
<tr>
<td>데이터 블록의 개수</td>
</tr>
<tr>
<td>직접 블록 (대부분의 작은 파일은 직접 블록으로도 커버가 충분히 된다.)</td>
</tr>
<tr>
<td>간접 블록 / 이중 간접 블록 / 삼중 간접 블록 (linked list 개념)</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="2-ext-2-vs-3-4"><a href="#2-ext-2-vs-3-4" class="headerlink" title="2. ext 2 vs 3,4"></a><strong>2. ext 2 vs 3,4</strong></h3><p>구조적으로 큰 차이보단 성능 개선 등에 초점이 맞춰져 있다.</p>
<table>
<thead>
<tr>
<th>features</th>
<th>ext2</th>
<th>ext3</th>
<th>ext4</th>
</tr>
</thead>
<tbody><tr>
<td>전원 문제 시 데이터 저장 손실 (저널링 파일 시스템 지원 여부)</td>
<td>문제 발생</td>
<td>저널링 지원됨</td>
<td>저널링 지원됨</td>
</tr>
<tr>
<td>파일 최대 크기</td>
<td>2TiB</td>
<td>2TiB</td>
<td>16TiB</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">이전</a></div><div class="pagination-next"><a href="/page/2/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">47</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/NCloud/"><span class="level-start"><span class="level-item">NCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/RabbitMQ/"><span class="level-start"><span class="level-item">RabbitMQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-22T09:20:00.000Z">21-08-22</time></p><p class="title"><a href="/linux-rmq-monitoring-easy/">리눅스에서 tmux와 rabbitmqctl을 이용한 Queue 잔여 메시지 모니터링하기</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/RabbitMQ/">RabbitMQ</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-15T10:10:00.000Z">21-08-15</time></p><p class="title"><a href="/linux-new-machine-settings/">리눅스 - 클라우드 머신 세팅하기 (Naver Cloud)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/NCloud/">NCloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-25T14:55:00.000Z">21-07-25</time></p><p class="title"><a href="/linux-file-descriptor/">리눅스에서의 파일 디스크립터와 리다이렉션</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-17T14:58:00.000Z">21-07-17</time></p><p class="title"><a href="/linux-env-security/">환경 변수와 보안</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-04T14:55:00.000Z">21-07-04</time></p><p class="title"><a href="/linux-virtualization-1/">리눅스에서의 가상화 솔루션의 종류와 특성 (1)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NCloud/"><span class="tag">NCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RabbitMQ/"><span class="tag">RabbitMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
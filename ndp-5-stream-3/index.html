<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>5장 Stream API (3/3) - Stream을 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행 구현하기 - JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="이 글은 Stream 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행에 대해 다룬다. 또한 독자가 Node.js Stream에 대한 기초 지식이 있음을 전제로 작성되었음을 밝힌다. 참고 자료:  Node.js에서의 스트림 자체에 대해서는 5장 Stream API (1&amp;#x2F;3) - 스트림 개요 및 Readable Stream Stream의 종류 4가지에"><meta property="og:type" content="blog"><meta property="og:title" content="5장 Stream API (3/3) - Stream을 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행 구현하기"><meta property="og:url" content="https://jsqna.com/ndp-5-stream-3/"><meta property="og:site_name" content="JS QnA"><meta property="og:description" content="이 글은 Stream 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행에 대해 다룬다. 또한 독자가 Node.js Stream에 대한 기초 지식이 있음을 전제로 작성되었음을 밝힌다. 참고 자료:  Node.js에서의 스트림 자체에 대해서는 5장 Stream API (1&amp;#x2F;3) - 스트림 개요 및 Readable Stream Stream의 종류 4가지에"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:published_time" content="2021-03-12T09:40:00.000Z"><meta property="article:modified_time" content="2021-03-12T09:31:53.220Z"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="Node.js 디자인 패턴"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com/ndp-5-stream-3/"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"datePublished":"2021-03-12T09:40:00.000Z","dateModified":"2021-03-12T09:31:53.220Z","author":{"@type":"Person","name":"Seongbin Kim"},"description":"이 글은 Stream 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행에 대해 다룬다. 또한 독자가 Node.js Stream에 대한 기초 지식이 있음을 전제로 작성되었음을 밝힌다. 참고 자료:  Node.js에서의 스트림 자체에 대해서는 5장 Stream API (1&#x2F;3) - 스트림 개요 및 Readable Stream Stream의 종류 4가지에"}</script><link rel="canonical" href="https://jsqna.com/ndp-5-stream-3/"><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-12T09:40:00.000Z" title="2021-03-12T09:40:00.000Z">21-03-12</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-12T09:31:53.220Z" title="2021-03-12T09:31:53.220Z">21-03-12</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">14분안에 읽기 (약 2100 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">5장 Stream API (3/3) - Stream을 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행 구현하기</h1><div class="content"><p>이 글은 Stream 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행에 대해 다룬다. 또한 독자가 Node.js Stream에 대한 기초 지식이 있음을 전제로 작성되었음을 밝힌다.</p>
<p>참고 자료:</p>
<ul>
<li>Node.js에서의 스트림 자체에 대해서는 <a href="https://jsqna.com/ndp-5-stream-1/">5장 Stream API (1/3) - 스트림 개요 및 Readable Stream</a></li>
<li>Stream의 종류 4가지에 대해서는 <a href="https://jsqna.com/ndp-5-stream-2/">5장 Stream API (2/3) - Node.js의 4가지 스트림 소개와 사용법</a></li>
</ul>
<hr>
<h3 id="1-여러-파일을-하나의-파일로-순차적으로-병합하는-방법"><a href="#1-여러-파일을-하나의-파일로-순차적으로-병합하는-방법" class="headerlink" title="1. 여러 파일을 하나의 파일로 순차적으로 병합하는 방법"></a><strong>1. 여러 파일을 하나의 파일로 순차적으로 병합하는 방법</strong></h3><p>스트림은 당연하게도 비동기로 작동한다. 여러 개의 Redable Stream이 있고 하나의 Writable Stream이 있을 때,  각 작업들을 <strong>순차적으로 수행</strong>하는 방법이 있을까? 가능하다. 여러 개의 Readable 을 각각 Writable로 연결하고, Redable에 순서를 지정하면 된다. 아래 코드에 대한 설명은 주석으로 나타나 있으니 주석을 따라가기 바란다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fromArray = <span class="built_in">require</span>(<span class="string">&#x27;from2-array&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> through = <span class="built_in">require</span>(<span class="string">&#x27;through2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatFiles</span>(<span class="params">destination, files, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> destStream = fs.createWriteStream(destination);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fromArray.obj: readableStream of param array.</span></span><br><span class="line">  fromArray.obj(files) </span><br><span class="line">  <span class="comment">// readable 끼리 pipe 수행</span></span><br><span class="line">  <span class="comment">// through.obj(fn) == through(&#123; objectMode: true &#125;, fn) =&gt; Transform 스트림 반환</span></span><br><span class="line">  <span class="comment">// 현재는 through를 많이 사용하지 않아도 괜찮음. </span></span><br><span class="line">    .pipe(through.obj(<span class="function">(<span class="params">file, enc, done</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> src = fs.createReadStream(file);</span><br><span class="line">      <span class="comment">// 파일명을 file로 입력 받음</span></span><br><span class="line">      <span class="comment">// src1 =&gt; dest 로 pipe 연결 (pipe 사용 시 자동으로 백 프래셔 수행. src에서 데이터 생산만 하면 됨.)</span></span><br><span class="line">      <span class="comment">// src1.end</span></span><br><span class="line">      <span class="comment">// src2 =&gt; dest 로 pipe 연결</span></span><br><span class="line">      <span class="comment">// src2.end</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// dest.end</span></span><br><span class="line">      <span class="comment">// [끝]</span></span><br><span class="line">      <span class="comment">// ---</span></span><br><span class="line">      <span class="comment">// 연결을 요청함. 이벤트 핸들러 등록과 같은 느낌. 실제 스트림 간의 통신은 비동기로 수행됨.</span></span><br><span class="line">      src.pipe(destStream, &#123;<span class="attr">end</span>: <span class="literal">false</span>&#125;); </span><br><span class="line">      <span class="comment">// 이후 src에서 dest로 연결하려면, dest는 종료되지 않아야 함</span></span><br><span class="line">      <span class="comment">// ---</span></span><br><span class="line">      <span class="comment">// 이 파일에 대한 Read Stream이 끝나면, through.obj로 생성하는 Trasnform 스트림의</span></span><br><span class="line">      <span class="comment">// callback인 &#x27;done&#x27; 함수를 호출하게 함. (단순히 params 이름만 바꾼 것임.)</span></span><br><span class="line">      src.on(<span class="string">&#x27;end&#x27;</span>, done);</span><br><span class="line">    &#125;))</span><br><span class="line">    .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// WritableStream을 종료함.</span></span><br><span class="line">      destStream.end();</span><br><span class="line">      <span class="comment">// concatFiles 호출자에게 종료를 알림.</span></span><br><span class="line">      callback();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-순서에-상관-없이-결과를-비동기로-병렬적으로-한-파일에-출력하는-방법"><a href="#2-순서에-상관-없이-결과를-비동기로-병렬적으로-한-파일에-출력하는-방법" class="headerlink" title="2. 순서에 상관 없이 결과를 비동기로, 병렬적으로 한 파일에 출력하는 방법"></a><strong>2. 순서에 상관 없이 결과를 비동기로, 병렬적으로 한 파일에 출력하는 방법</strong></h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://thiswillbedownforsure.com/">http://thiswillbedownforsure.com</a> is down<br><a target="_blank" rel="noopener" href="https://www.naver.com/">https://www.naver.com</a> is up<br><a target="_blank" rel="noopener" href="https://www.google.com/">https://www.google.com</a> is up</p>
</blockquote>
<p>위와 같이 특정 사이트 목록들에 대해 health check를 하고 그 결과를 파일로 출력하는 프로그램을 만든다고 하자. 굳이 Stream으로 만들 필요는 없겠지만 그렇게 해본다면 다음과 같은 코드를 생각해볼 수 있다.</p>
<p>일단 Transform 기반의 스트림을 하나 정의한다. 이 스트림은 <code>request</code>의 콜백으로 스트림의 기능을 빌려주는 형태로 작동한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transform 스트림을 하나 정의한다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParallelStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">userTransform</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(&#123;<span class="attr">objectMode</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">    <span class="built_in">this</span>.userTransform = userTransform;</span><br><span class="line">    <span class="comment">// const userTransform = (chunk, enc, done, pushFn) =&gt; &#123; ... &#125;</span></span><br><span class="line">    <span class="built_in">this</span>.running = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.terminateCallback = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_transform</span>(<span class="params">chunk, enc, done</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.running++;</span><br><span class="line">    <span class="built_in">this</span>.userTransform(chunk, enc, <span class="built_in">this</span>._onComplete.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.push.bind(<span class="built_in">this</span>));</span><br><span class="line">    done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush는 스트림 종료 직전에 호출되며 즉 done() 의 호출 여부를 결정할 수 있다.</span></span><br><span class="line">  <span class="function"><span class="title">_flush</span>(<span class="params">done</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 작업이 모두 종료되기 전에 스트림이 종료되려고 하는 경우 done()을 호출하지 않는다.</span></span><br><span class="line">    <span class="comment">// 그 대신 onComplete에서 곧바로 종료할 수 있도록 done 함수를 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.running &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.terminateCallback = done;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      done();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// userTransform에서 done이라는 이름으로 호출되는 함수. 이 때의 done은 각 단위 작업의 완료를 의미한다.</span></span><br><span class="line">  <span class="function"><span class="title">_onComplete</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.running--;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.emit(<span class="string">&#x27;error&#x27;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 실행 중인 작업이 모두 종료되었고 스트림 종류가 한 번 이상 보류된 경우 직접 스트림을 종료한다.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.running === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.terminateCallback &amp;&amp; <span class="built_in">this</span>.terminateCallback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>위에서 정의한 스트림을 사용해 구현한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(ex)</span></span><br><span class="line"><span class="comment">1. process.argv[2]: urls.txt</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. urls.txt:</span></span><br><span class="line"><span class="comment">http://thiswillbedownforsure.com</span></span><br><span class="line"><span class="comment">https://www.naver.com</span></span><br><span class="line"><span class="comment">https://www.google.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fs.createReadStream(process.argv[<span class="number">2</span>]) <span class="comment">//[1] 파일로 readable 스트림 생성</span></span><br><span class="line">  .pipe(split()) <span class="comment">//[2] 파일의 라인 단위로 chunk를 잡아 출력하는 Transform 스트림 생성 (파일 내용은 url 단위로 줄바꿈 돼있음)</span></span><br><span class="line">  .pipe(</span><br><span class="line">    <span class="comment">//[3] pipe로 전달되는 데이터(각 URL) 마다 Transform Stream의 _transform 함수에서 아래의 콜백 함수가 호출된다.</span></span><br><span class="line">    <span class="comment">// 생성자로 이 콜백(userTransform이라고 불리는)을 등록한다.</span></span><br><span class="line">    <span class="keyword">new</span> ParallelStream(<span class="function">(<span class="params">url, enc, done, push</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!url) <span class="keyword">return</span> done(); <span class="comment">// 더 이상 데이터가 없는 경우 (null인 경우) 스트림 종료하도록 (this.running == 0)</span></span><br><span class="line">      request.head(url, <span class="function">(<span class="params">err, response</span>) =&gt;</span> &#123;</span><br><span class="line">        push(url + <span class="string">&quot; is &quot;</span> + (err ? <span class="string">&quot;down&quot;</span> : <span class="string">&quot;up&quot;</span>) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        done();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">&quot;results.txt&quot;</span>)) </span><br><span class="line">  .on(<span class="string">&quot;finish&quot;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;All urls were checked&quot;</span>));</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  result:</span></span><br><span class="line"><span class="comment">  http://thiswillbedownforsure.com is down</span></span><br><span class="line"><span class="comment">  https://www.naver.com is up</span></span><br><span class="line"><span class="comment">  https://www.google.com is up</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-의-동시-실행-수를-제한하는-방법"><a href="#3-2-의-동시-실행-수를-제한하는-방법" class="headerlink" title="3. (2)의 동시 실행 수를 제한하는 방법"></a><strong>3. (2)의 동시 실행 수를 제한하는 방법</strong></h3><p>비동기 요청 여러 개를 처리하는 일은 Node.js에선 매우 간단하다. Run to Completion이기 때문에 변수 하나로 비동기 작업의 개수를 정확히 세고 이 값에 기반해 의사 결정을 할 수 있다. </p>
<p>따라서 <code>this.running</code>의 개수가 동시 실행 제한 개수에 도달한 경우 처리하지 않으면 된다. 좀 더 정확하게는, <code>_transform</code> 함수에서 해당 chunk의 처리가 완료됐음을 알리는 콜백을 호출하지 않고 보류하면 된다. </p>
<p>이 경우 해당 chunk를 처리한 결과는 다음 스트림으로 넘어가지 않으며 현재 chunk가 처리되지 않았기 때문에 추가적인 chunk가 스트림으로 전달되지도 않는다(스트림 내부 버퍼에 쌓인다).</p>
<p>만약 ReadableStream이 chunk를 생성하고 내보내는 속도가 우리의 스트림의 처리 속도보다 빠르다면 처리되지 않는 chunk는 Transform의 버퍼에 쌓이며 이내 백 프레셔가 발동되고 알아서 처리될 것이다. - <code>pipe</code>로 연결하면 Node.js에서 자동으로 처리한다. 백 프래셔에 대해선 <a href="https://jsqna.com/ndp-5-stream-2/">5장 Stream API (2/3) - Node.js의 4가지 스트림 소개와 사용법</a>을 참고하라.</p>
<p>따라서 추가적으로 신경써야 하는 부분은 <strong>출력을 할 지 여부를 결정</strong>하는 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">concurrency, userTransform</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// ... 아래 두 멤버 필드만 추가된다.</span></span><br><span class="line">  <span class="built_in">this</span>.concurrency = concurrency;</span><br><span class="line">  <span class="built_in">this</span>.continueCallback = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 입력은 직접 제한하지 않고 계속 받는다.</span></span><br><span class="line"><span class="comment">// 완료를 의미하는 콜백을 호출해서 다음 chunk를 처리하지 않으면, 스트림 내부의 버퍼에 쌓이게 된다.</span></span><br><span class="line"><span class="comment">// 그러면 Node.js 런타임이 자동으로 백 프레셔를 수행한다.</span></span><br><span class="line"><span class="function"><span class="title">_transform</span>(<span class="params">chunk, enc, done</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.running++;</span><br><span class="line">  <span class="built_in">this</span>.userTransform(chunk, enc, <span class="built_in">this</span>.push.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._onComplete.bind(<span class="built_in">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.running &lt; <span class="built_in">this</span>.concurrency) &#123;</span><br><span class="line">    done();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 만약 현재 running의 최대치에 도달한 경우 완료 콜백을 수행하지 않는다. 이는 자연스럽게 백 프래셔 발동으로 이어진다.</span></span><br><span class="line">    <span class="built_in">this</span>.continueCallback = done;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">_onComplete</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.running--;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.emit(<span class="string">&quot;error&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// continueCallback이 할당되어 있으면 호출한다.</span></span><br><span class="line">  <span class="comment">// 이 시점에서 앞 chunk들은 모두 처리됐음이 보장된다.</span></span><br><span class="line">  <span class="comment">// 왜냐하면 입력이 출력보다 충분히 빨라 버퍼링이 되는 시점에서는 항상 continueCallback으로 done()이 호출되게 된다.</span></span><br><span class="line">  <span class="comment">// 항상 this.running == this.concurrency여서 꽉 차 있는 상태이기 때문이다.</span></span><br><span class="line">  <span class="comment">// (설명이 부드럽지 못한데 실행 흐름을 보고 설명을 다시 읽어보면 이해가 될 것이다.)</span></span><br><span class="line">  <span class="keyword">const</span> tmpCallback = <span class="built_in">this</span>.continueCallback;</span><br><span class="line">  <span class="built_in">this</span>.continueCallback = <span class="literal">null</span>;</span><br><span class="line">  tmpCallback &amp;&amp; tmpCallback();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.running === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.terminateCallback &amp;&amp; <span class="built_in">this</span>.terminateCallback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>참고 자료 (이번 글만 특별히 도움이 됐는지와는 별개로 읽은 몇 개의 글을 링크한다.):</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20769132/whats-the-proper-way-to-handle-back-pressure-in-a-node-js-transform-stream">What’s the proper way to handle back-pressure in a node.js Transform stream?</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/sindresorhus/awesome-nodejs#streams">Awesome Nodejs#Streams (Github Repo)</a></p>
<hr>
<p>TODO:</p>
<ol>
<li>Stream 관련해서 자세한 자료보단 내부 구조를 코드 수준에서 확인하는 게 가장 좋을 것 같다.</li>
<li>Back Pressure의 효과를 제대로 확인하기 위해선 디버거를 키고 스트림 객체를 살펴봐야 할 것 같다.</li>
<li>Stream의 추상하된 구현체들을 가져다 쓸 수록 더욱 더 이해하기 어려워지는 것 같다.</li>
<li>Stream을 3부작으로 나누어 작성하려고 했는데 한 10부작 까지는 나올 수도 있을 것 같다. 그만큼 부족하고, 글 쓰는 데도 매우 오래 걸린다.</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>5장 Stream API (3/3) - Stream을 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행 구현하기</p><p><a href="https://jsqna.com/ndp-5-stream-3/">https://jsqna.com/ndp-5-stream-3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Seongbin Kim</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>21-03-12</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>21-03-12</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/linux-dir/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">리눅스 주요 디렉토리의 이름과 의미 정리 (계속 업데이트 예정)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/ndp-5-stream-2/"><span class="level-item">5장 Stream API (2/3) - Node.js의 4가지 스트림 소개와 사용법</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://jsqna.com/ndp-5-stream-3/';
            this.page.identifier = 'ndp-5-stream-3/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'jsqna' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">30</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-21T13:00:00.000Z">21-03-21</time></p><p class="title"><a href="/linux-shell-1/">리눅스 셸(bash) 기본 기능 소개</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-14T05:00:00.000Z">21-03-14</time></p><p class="title"><a href="/linux-dir/">리눅스 주요 디렉토리의 이름과 의미 정리 (계속 업데이트 예정)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-12T09:40:00.000Z">21-03-12</time></p><p class="title"><a href="/ndp-5-stream-3/">5장 Stream API (3/3) - Stream을 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행 구현하기</a></p><p class="categories"><a href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-05T10:50:00.000Z">21-03-05</time></p><p class="title"><a href="/ndp-5-stream-2/">5장 Stream API (2/3) - Node.js의 4가지 스트림 소개와 사용법</a></p><p class="categories"><a href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-03T12:00:00.000Z">21-03-03</time></p><p class="title"><a href="/ndp-7-dependency-injection-2/">7장 의존성 주입 (2/2) - 간단한 Javascript DI 컨테이너 구현체</a></p><p class="categories"><a href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"a5b0a2c99ffc3e96272db5353f20f4e3","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-25T06:00:00.000Z" title="2021-03-25T06:00:00.000Z">21-03-25</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-25T05:57:50.270Z" title="2021-03-25T05:57:50.270Z">21-03-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">11분안에 읽기 (약 1664 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-5-stream-4/">5장 Stream API 디자인 패턴 - Pipe, Fork, Merge, Mux/Demux</a></h1><div class="content"><p>이 글은 Stream에서의 Pipe, Fork, Merge, Mux/Demux 패턴에 대해 소개하고 Mux/Demux는 예를 제공한다.</p>
<p>참고 자료:</p>
<ul>
<li>Node.js의 Buffer API에 대해서는 <a target="_blank" rel="noopener" href="https://tk-one.github.io/2018/08/28/nodejs-buffer/">Node.js의 Buffer를 제대로 이해해보자</a></li>
<li>Node.js에서의 스트림 자체에 대해서는 <a href="https://jsqna.com/ndp-5-stream-1/">5장 Stream API (1/3) - 스트림 개요 및 Readable Stream</a></li>
<li>Stream의 종류 4가지에 대해서는 <a href="https://jsqna.com/ndp-5-stream-2/">5장 Stream API (2/3) - Node.js의 4가지 스트림 소개와 사용법</a></li>
<li>Stream 기반의 순차 실행, 병렬 실행 구현에 대해서는 <a href="https://jsqna.com/ndp-5-stream-3/">5장 Stream API (3/3) - Stream을 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행 구현하기</a></li>
</ul>
<hr>
<h3 id="1-Pipe-패턴"><a href="#1-Pipe-패턴" class="headerlink" title="1. Pipe 패턴"></a><strong>1. Pipe 패턴</strong></h3><p>여기서 말하는 Pipe 패턴이란 스트림의 조합으로 이루어진 하나의 파이프라인을 모듈화하고 재사용하는 방법을 말한다. </p>
<p>Pipe 패턴 구현 시 주의할 점</p>
<ul>
<li>첫 Stream에 Write하고, 마지막 Stream에서 Read해야 한다.</li>
<li>내부의 모든 Stream에서 발생하는 오류를 포착할 수 있어야 한다. Error Listener 하나로 Pipeline에서 발생하는 모든 오류를 구독할 수 있도록 한다.</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/felixge/node-combined-stream">Combined-Stream</a> 패키지를 이용한다. (사용량은 압도적이나 Stream v1 - Flowing 모드만 지원한다.)</p>
<p>(<a target="_blank" rel="noopener" href="https://github.com/mafintosh/pumpify">Pumpify</a>가 더 좋은 것 같은데 사용법을 잘 모르겠다.)</p>
<hr>
<h3 id="2-Fork-패턴"><a href="#2-Fork-패턴" class="headerlink" title="2. Fork 패턴"></a><strong>2. Fork 패턴</strong></h3><p>서로 다른 대상에 동일한 데이터를 보내는 경우, 즉 하나의 Readable에 2개 이상의 스트림을 연결하는 패턴이다. </p>
<p>Fork 패턴 구현 시 주의할 점</p>
<ul>
<li><code>.pipe</code> 사용 시 <code>&#123;end: false&#125;</code> 옵션이 필수가 된다. 한 쪽의 작업이 끝나는 경우 다른 쪽도 닫히기 때문</li>
<li>백 프레셔 때문에 제일 느린 스트림에 속도가 맞춰지게 된다.</li>
<li>같은 프로세스 내에 두 스트림이 있는 경우 chunk가 공유되므로 한 쪽의 스트림에서 해당 chunk의 내용을 직접 수정하게 되면 다른 스트림도 그 영향을 받게 된다.</li>
</ul>
<hr>
<h3 id="3-Merge-패턴"><a href="#3-Merge-패턴" class="headerlink" title="3. Merge 패턴"></a><strong>3. Merge 패턴</strong></h3><p>일련의 Readable을 하나의 스트림으로 연결하는 패턴이다. <code>.pipe(&#123;end: false&#125;)</code>로 연결해야 한다. Auto End 옵션은 하나의 Redable만 종료되더라도 연결된 스트림까지 종료시키기 때문이다.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/grncdr/merge-stream">Merge-Stream</a> 패키지를 사용한다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/feross/multistream">multistream</a> 패키지보다 훨씬 사용량이 많다.</li>
</ul>
<hr>
<h3 id="4-Mux-Demux-패턴"><a href="#4-Mux-Demux-패턴" class="headerlink" title="4. Mux/Demux 패턴"></a><strong>4. Mux/Demux 패턴</strong></h3><p>(직접 구현한다.) 여러 스트림에서 들어오는 데이터를 한 스트림(이 예에서는 <code>net</code> 패키지의 도움을 받아 TCP Socket을 사용한다.)으로 내보내고, 같은 방식으로 데이터를 받아들인 후 여러 스트림으로 다시 분류하는 멀티플렉싱/디멀티플렉싱을 스트림 수준에서 구현한다.</p>
<p><img src="/images/ndp-stream/MuxDemux.png" alt="아키텍처 요약"></p>
<p>긴 설명은 하지 않고, 코드에 주석을 달아 놓았으니 흐름을 따라가면 쉽게 이해할 수 있을 것이다.</p>
<p><strong>generateData.js</strong></p>
<p>표준 출력, 오류 스트림에서 데이터를 생성하기 위한 코드이다. Client에서 실행하게 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;out1&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;out2&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">&quot;err1&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;out3&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">&quot;err2&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Client.js</strong></p>
<p>generateData로 생성된 데이터가 표준 출력, 오류 스트림으로 들어오게 되고, 아래 코드에서 헤더로 포장한 후 Socket으로 Server에 전송한다. (참고로 Client 코드가 이 case에서 가장 어렵다. 이 코드만 이해하면 다 했다고 볼 수 있다.)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplexChannels</span>(<span class="params">sources, destination</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalChannels = sources.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sources.length; i++) &#123;</span><br><span class="line">    sources[i]</span><br><span class="line">      .on(<span class="string">&quot;readable&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> chunk;</span><br><span class="line">        <span class="keyword">while</span> ((chunk = <span class="built_in">this</span>.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 5+chunk byte (Node.js는 바이트 스트림(Octet Stream)만 지원하는건지, Buffer도 최소 단위가 bit이 아니라 byte이다.)</span></span><br><span class="line">          <span class="keyword">const</span> outBuff = Buffer.alloc(<span class="number">1</span> + <span class="number">4</span> + chunk.length); <span class="comment">// Buffer.alloc(size); === new Buffer(size);</span></span><br><span class="line">          outBuff.writeUInt8(i, <span class="number">0</span>); <span class="comment">// write(data, idx) - 이 경우에는 idx=0</span></span><br><span class="line">          outBuff.writeUInt32BE(chunk.length, <span class="number">1</span>); <span class="comment">// write (data, idx) 이 경우에는 idx=1 (앞 데이터는 8bit 이므로, 한 칸만 사용)</span></span><br><span class="line">          chunk.copy(outBuff, <span class="number">5</span>); <span class="comment">// 앞에서 40bit를 사용해서 다음 데이터의 offset=5</span></span><br><span class="line">          <span class="comment">// chunk가 무슨 타입인지 모르겠지만 Readable이 제공하는 chunk는 copy 메소드가 있는 듯.</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;Sending packet to channel: &quot;</span> + i);</span><br><span class="line">          destination.write(outBuff); <span class="comment">// 대상 스트림으로 쓰기</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 모든 Readable이 닫힌 후 대상 스트림 종료</span></span><br><span class="line">        <span class="keyword">if</span> (--totalChannels === <span class="number">0</span>) &#123;</span><br><span class="line">          destination.end();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net.connect: (port, host?, callback)</span></span><br><span class="line"><span class="keyword">const</span> socket = net.connect(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//현재 프로세스는 소켓을 열고 끝. net.connect는 Non-blocking call 이다.</span></span><br><span class="line">  <span class="keyword">const</span> child = child_process.fork(</span><br><span class="line">    <span class="comment">// child_process.fork로 새 프로세스에서 JS 파일을 실행한다. (이 경우 generateData.js)</span></span><br><span class="line">    process.argv[<span class="number">2</span>],</span><br><span class="line">    process.argv.slice(<span class="number">3</span>), <span class="comment">// fork로 실행할 JS파일</span></span><br><span class="line">    &#123; <span class="attr">silent</span>: <span class="literal">true</span> &#125; <span class="comment">// silent 옵션: Child 프로세스가 독립적인 표준 스트림을 갖도록 (상속받지 않도록)</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  multiplexChannels([child.stdout, child.stderr], socket); <span class="comment">// 대상 스트림으로 Socket 생성해 전달</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Server.js</strong></p>
<p>클라이언트로부터 데이터를 파싱한 후 각 스트림에 대응되는 파일에 내용을 쓴다. 헤더 격인 앞 1바이트를 읽어 채널을 구분한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 소켓마다 한 번 호출됨 (상태 관리 필요)</span></span><br><span class="line"><span class="comment">// 디멀티플렉싱 수행</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demultiplexChannel</span>(<span class="params">source, destinations</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 상태 관리 필드</span></span><br><span class="line">  <span class="keyword">let</span> currentChannel = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> currentLength = <span class="literal">null</span>;</span><br><span class="line">  source</span><br><span class="line">    .on(<span class="string">&quot;readable&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 1. 표준 입력/오류 구분</span></span><br><span class="line">      <span class="keyword">let</span> chunk;</span><br><span class="line">      <span class="keyword">if</span> (currentChannel === <span class="literal">null</span>) &#123;</span><br><span class="line">        chunk = source.read(<span class="number">1</span>);</span><br><span class="line">        currentChannel = chunk &amp;&amp; chunk.readUInt8(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 데이터 길이 파싱</span></span><br><span class="line">      <span class="keyword">if</span> (currentLength === <span class="literal">null</span>) &#123;</span><br><span class="line">        chunk = source.read(<span class="number">4</span>);</span><br><span class="line">        currentLength = chunk &amp;&amp; chunk.readUInt32BE(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (currentLength === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 데이터 길이만큼 읽기</span></span><br><span class="line">      chunk = source.read(currentLength);</span><br><span class="line">      <span class="keyword">if</span> (chunk === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 읽은 데이터(chunk)를 대상 스트림에 작성</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Received packet from: &quot;</span> + currentChannel);</span><br><span class="line">      destinations[currentChannel].write(chunk);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// chunk 순서대로 호출되므로 여기서 다시 null을 할당하면 됨 :)</span></span><br><span class="line">      currentChannel = <span class="literal">null</span>;</span><br><span class="line">      currentLength = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 소켓에서 받은 데이터가 끝난 경우 대상 스트림 모두 종료</span></span><br><span class="line">      destinations.forEach(<span class="function">(<span class="params">destination</span>) =&gt;</span> destination.end());</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Source channel closed&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 소켓 3000번으로 서버 열기</span></span><br><span class="line">net</span><br><span class="line">  .createServer(<span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 연결 수립 시 수행할 Callback</span></span><br><span class="line">    <span class="keyword">const</span> stdoutStream = fs.createWriteStream(<span class="string">&quot;stdout.log&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> stderrStream = fs.createWriteStream(<span class="string">&quot;stderr.log&quot;</span>);</span><br><span class="line">    <span class="comment">// Source: 소켓을 통해 전달된 octet-stream, 대상 스트림 2개: 표준 출력, 표준 오류</span></span><br><span class="line">    demultiplexChannel(socket, [stdoutStream, stderrStream]);</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Server started&quot;</span>));</span><br></pre></td></tr></table></figure>
<hr>
<p>TODO:</p>
<ol>
<li>스트림을 제대로 써봐야 제대로 이해할 수 있을 것 같다.</li>
<li>스트림 생태계가 좀 엉망인데 직접 사용해보고 정리하는 기회가 필요할 것 같다.</li>
<li>이 글도 예제를 제대로 추가해 영양가 있는 글로 만들어야 한다.</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-21T13:00:00.000Z" title="2021-03-21T13:00:00.000Z">21-03-21</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-20T13:07:43.260Z" title="2021-06-20T13:07:43.260Z">21-06-20</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">15분안에 읽기 (약 2224 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-shell-1/">리눅스 셸(bash) 기본 기능 소개</a></h1><div class="content"><p>이 글에서 소개할 내용은 굉장히 유용한 기능이라고 생각하며, 셸의 역할인 코드 실행 시의 입/출력에 대한 Proxy, Middleware 역할을 잘 활용하는 기능들이라고 생각한다. 이 글은 리눅스 핵심 레퍼런스의 일부를 참고해 작성하였다. </p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (GCP Compute Engine)</p>
</blockquote>
<hr>
<blockquote>
<p>셸은 단순한 호출보다 훨씬 많은 것을 할 수 있다.</p>
</blockquote>
<hr>
<h3 id="1-wildcard-정규표현식과-유사한-검색을-수행한-결과를-명령의-입력으로-사용"><a href="#1-wildcard-정규표현식과-유사한-검색을-수행한-결과를-명령의-입력으로-사용" class="headerlink" title="1. wildcard: 정규표현식과 유사한 검색을 수행한 결과를 명령의 입력으로 사용"></a><strong>1. wildcard: 정규표현식과 유사한 검색을 수행한 결과를 명령의 입력으로 사용</strong></h3><hr>
<h4 id="1-가장-기본이-되는-예제"><a href="#1-가장-기본이-되는-예제" class="headerlink" title="1. 가장 기본이 되는 예제"></a>1. 가장 기본이 되는 예제</h4><p>이름에 wildcard 검색을 수행해 결과를 명령의 입력으로 사용할 수 있다. 이름 일치 기준은 디렉토리이다. 즉 <code>a*</code>를 셸 명령어에 입력하게 되면, <code>./a</code>로 시작하는 파일/디렉토리를 반환한다. 특정 상위 폴더나 하위 폴더를 대상으로 검색하고 싶은 경우 그에 맞는 상대 경로를 입력하면 된다.  </p>
<hr>
<p>(ex 1) <code>ls a*</code> == <code>ls aardvark adamantium apple</code>  </p>
<p>(ex 2) <code>ls githubblog/.*</code> == <code>ls githubblog/.git githubblog/.deploy_git, ...</code></p>
<p><img src="/images/linux-shell/a1.png" alt="기준 디렉토리 목록"></p>
<p>위 사진은 기준 디렉토리이다. 여기서 <code>g*</code> 인 파일/디렉토리를 <code>ls -alF</code>의 매개변수로 주려고 한다. </p>
<p><img src="/images/linux-shell/a2.png" alt="g*에 해당하는 목록을 wildcard를 통해 입력으로 사용"></p>
<p>위 사진은 명령의 결과물로, 실제로 잘 수행됨을 확인할 수 있다.</p>
<hr>
<h4 id="2-추가-옵션"><a href="#2-추가-옵션" class="headerlink" title="2.추가 옵션"></a>2.추가 옵션</h4><p><code>[문자들...]</code> : 문자들 중 하나와 일치하는 경우. </p>
<ul>
<li><code>[aieou]</code> : 모음 중 하나. 단 이렇게 찾으려면 파일/디렉토리 이름이 a, i, e, o, u 중 하나여야 한다. (즉 한 글자)</li>
</ul>
<hr>
<p><code>[^문자들...]</code>, <code>[!문자들...]</code> : 명시된 문자 이외의 any 문자</p>
<ul>
<li><code>[^aieou]</code> : 자음 중 하나. 단 이렇게 찾으려면 파일/디렉토리 이름이 b, c, d, f, g, … 중 하나여야 한다. (즉 한 글자)</li>
</ul>
<hr>
<p><code>?</code> : 임의의 한 문자. character 하나의 placeholder라고 생각하면 편리하다.</p>
<ul>
<li><code>[githubblo?]</code> : <code>githubblog</code>가 있다면 일치한다.</li>
</ul>
<hr>
<p><code>*</code> : asterisk의 일반적인 의미처럼 아무거나. <u>empty를 포함한</u> 모든 string을 의미. 보통 조합할 때 필수적으로 사용된다.</p>
<ul>
<li><code>*[aioeu]</code> : 모음으로 끝나는 경우</li>
<li><code>*[aioeu]*</code> : 모음이 포함된 경우</li>
<li><code>[aioeu]*</code> : 모음으로 시작하는 경우</li>
</ul>
<hr>
<h3 id="2-중괄호-확장-단순히-가능한-모든-경우의-수를-입력으로-사용"><a href="#2-중괄호-확장-단순히-가능한-모든-경우의-수를-입력으로-사용" class="headerlink" title="2. 중괄호 확장: 단순히 가능한 모든 경우의 수를 입력으로 사용"></a><strong>2. 중괄호 확장: 단순히 가능한 모든 경우의 수를 입력으로 사용</strong></h3><p>문자열 중간에서 사용되며 가능한 모든 경우의 수로 치환된 후 입력으로 사용된다.</p>
<p><img src="/images/linux-shell/b1.png" alt="echo a{b,c,d}e{f,g,h} 결과"></p>
<p>(ex) <code>echo a&#123;b,c,d&#125;e&#123;f,g,h&#125;</code> == <code>echo abef abeg abeh acef aceg aceh adef adeg adeh</code></p>
<hr>
<h3 id="3-변수-String-타입의-환경-변수"><a href="#3-변수-String-타입의-환경-변수" class="headerlink" title="3. 변수: String 타입의 환경 변수"></a><strong>3. 변수: String 타입의 환경 변수</strong></h3><blockquote>
<p>bash 프로파일 관리에 대해선 좀 더 나중에 다루려고 한다.</p>
</blockquote>
<p>Windows의 환경 변수와 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/ko-kr/windows-server/administration/windows-commands/set_1">cmd 환경 변수</a>와 같은 2가지 변수가 있다. 모두 환경 변수이지만 그 범위가 다른데, <u>cmd 환경 변수에 대응</u>되는 Linux에서의 개념이 셸 변수이다. 단 아래의 방법으로 하면 해당 세션(셸)에서만 사용할 수 있으므로 일회성 변수로 생각하면 좋다.</p>
<p><strong>쓰기</strong> : <code>MYVAR=string_value</code></p>
<p><strong>읽기</strong> : <code>$MYVAR</code></p>
<p>만약 환경 변수로 저장하고 싶다면, <code>export MYVAR=string_value</code>와 같이 사용하면 된다. 환경 변수는 <code>printenv</code> 혹은 <code>env</code> 명령으로 확인할 수 있다.</p>
<hr>
<h4 id="기본으로-제공되는-환경-변수"><a href="#기본으로-제공되는-환경-변수" class="headerlink" title="기본으로 제공되는 환경 변수"></a><strong>기본으로 제공되는 환경 변수</strong></h4><p><code>PATH</code> : 바이너리 검색 경로의 목록. 콜론으로 구분.</p>
<p><code>PWD</code> :  현재 디렉토리 ( <code>OLDPWD</code> : 마지막으로 방문한 디렉토리 )</p>
<p><code>HOME</code> : 홈 디렉토리 ( ex : <code>/home/sb</code> )</p>
<p><code>USER</code> : 로그인명 ( <code>sb</code> )</p>
<hr>
<h3 id="4-alias"><a href="#4-alias" class="headerlink" title="4. alias"></a><strong>4. alias</strong></h3><p>단순한 String 치환이다.</p>
<p><strong>지정</strong> :  <code>alias ll = &quot;ls -lG&quot;</code>를 입력하면, 이후 셸에서 <code>ll</code>을 입력하면 <code>ls -lG</code>가 입력된다.</p>
<p><strong>목록 확인</strong> : <code>alias</code>만 입력하면 된다.</p>
<p><img src="/images/linux-shell/c1.png" alt="alias 입력 시의 결과"></p>
<hr>
<h3 id="5-입출력-redirection"><a href="#5-입출력-redirection" class="headerlink" title="5. 입출력 redirection"></a><strong>5. 입출력 redirection</strong></h3><blockquote>
<p>아직 입출력을 파일을 통해 수행해본 적이 없어서 추후 적절한 예시를 추가하려고 한다. 이번 글에서는 개념적으로 그 사용법만 다룬다.</p>
</blockquote>
<p>표준 입출력의 지점을 임의의 파일에 수행하게 한다.</p>
<p><strong>입력을 파일의 내용으로</strong> : <code>command &lt; input_file</code></p>
<ul>
<li>재미있게도 <code>echo &lt; sample.txt</code> 와 같이, <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/63658/redirecting-the-content-of-a-file-to-the-command-echo">echo 명령은 임의의 input 파일의 내용을 출력할 수 없는데</a>, 표준 입출력에서 내용을 읽지 않기 때문이다.</li>
</ul>
<p><strong>출력을 파일로</strong> : </p>
<ol>
<li><p>새로운 파일로 작성 :  <code>command &gt; output_file</code></p>
</li>
<li><p>기존 파일에 이어 쓰기 : <code>command &gt;&gt; output_file</code></p>
</li>
<li><p>오류의 경우 : <code>command 2&gt; error_file</code></p>
</li>
<li><p>출력, 오류 모두 : <code>command &gt;&amp; output_file</code> 혹은 <code>command &amp;&gt; output_file</code></p>
</li>
<li><p>출력, 오류 각각 : <code>command &gt; output_file 2&gt; error_file</code></p>
</li>
</ol>
<blockquote>
<p>리눅스에서 표준 스트림은 3가지이며 자세한 내용은 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%ED%91%9C%EC%A4%80_%EC%8A%A4%ED%8A%B8%EB%A6%BC">위키 백과 (표준 스트림)</a> 참고</p>
</blockquote>
<hr>
<h3 id="6-Pipe"><a href="#6-Pipe" class="headerlink" title="6. Pipe"></a><strong>6. Pipe</strong></h3><blockquote>
<ol>
<li>각 프로그램이 하나의 일을 잘 할 수 있게 만들 것. 새로운 일을 하려면, 새로운 기능들을 추가하기 위해 오래된 프로그램을 복잡하게 만들지 말고 새로 만들 것.</li>
<li>모든 프로그램 출력이 아직 잘 알려지지 않은 프로그램이라고 할지라도 다른 프로그램에 대한 입력이 될 수 있게 할 것. 무관한 정보로 출력을 채우지 말 것. 까다롭게 세로로 구분되거나 바이너리로 된 입력 형식은 피할 것. 대화식 입력을 고집하지 말 것.</li>
<li>소프트웨어를, 심지어는 운영 체제일지라도 이른 시기에 수주에 걸쳐 이상적으로 시도해가며 설계하고 만들 것. 어설픈 부분을 버리고 다시 만드는 것을 주저하지 말 것.</li>
<li>프로그래밍 작업을 가볍게 하기 위해, 심지어 우회하는 방법으로 도구를 만들고 바로 버릴지라도 어설픈 도움 보다는 도구 사용을 선호할 것.</li>
</ol>
<p>출처: <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%B2%A0%ED%95%99">위키 백과 (유닉스 철학)</a></p>
</blockquote>
<p>Pipe 연산자는 유닉스 철학을 구현하는 도구 중 하나로, 이 중 2번 규칙을 지키는 도구로 사용된다.</p>
<p>(ex) <code>who | sort | awk &#39;&#123;print $1&#125;&#39; | less</code></p>
<blockquote>
<p>pipe 연산자의 효과를 제대로 소개하는 예제를 만들기엔 아직 아는 명령어가 극히 적어서 추후 제대로 소개하고자 한다. 해당 소개 글이 작성될 경우 이 글에서 링크를 제공하도록 하겠다.</p>
</blockquote>
<hr>
<h3 id="7-평가식"><a href="#7-평가식" class="headerlink" title="7. 평가식"></a><strong>7. 평가식</strong></h3><p>평가식이란 그 내용이 코드로 해석되는 영역을 말한다. 셸에서의 평가식은 해당 평가식을 셸에서 따로 실행시켰을 때의 결과를 반환하는 형태를 갖는다. 이 평가식의 문법은 크게 두 가지가 있는데,</p>
<ol>
<li>backtick : <code>echo This year is ``date +%Y\`` </code><ul>
<li>This year is 2021</li>
</ul>
</li>
<li>$() : <code>echo Next year is $(expr $(date +%Y) + 1)</code><ul>
<li>Next year is 2022</li>
</ul>
</li>
</ol>
<p>평가식으로 (5)에서 실패했던 <code>echo &lt; sample.txt</code>를 평가식으로는 실행할 수 있다: <code>echo $(cat sample.txt)</code> (`을 사용해도 된다.)</p>
<hr>
<h3 id="8-작업-제어"><a href="#8-작업-제어" class="headerlink" title="8. 작업 제어"></a><strong>8. 작업 제어</strong></h3><p>셸에서 수행되는 프로그램은 대개 포그라운드로 실행된다. 즉 사용자와의 인터렉션이 블로킹되는데 셸에서 프로그램을 실행할 때 백그라운드로도 실행시킬 수 있다. 또한 포그라운드와 백그라운드를 넘나들 수 있으며 작업을 정지하고 다시 실행할 수도 있으며 셸 마저 정지할 수도 있다.</p>
<p><strong>백그라운드로 작업 실행</strong> : <code>command ... &amp;</code> (<code>&amp;</code>가 핵심이다.)</p>
<p><strong>포그라운드 작업 정지</strong> : <code>Ctrl + Z</code></p>
<p><strong>백그라운드에서 작업 재개</strong> : `bg {id}``</p>
<p><strong>포그라운드로 작업을 가져와 실행</strong> : <code>fg &#123;id&#125;</code></p>
<p><strong>현재 수행 중인 작업의 목록 조회</strong> : <code>jobs</code></p>
<p><strong>현재 셸 정지</strong> : <code>suspend</code> (현재 실행 중인 셸이 2개 이상이어야 호출 가능하다.)</p>
<hr>
<h3 id="9-여러-셸-동시-사용"><a href="#9-여러-셸-동시-사용" class="headerlink" title="9. 여러 셸 동시 사용"></a><strong>9. 여러 셸 동시 사용</strong></h3><p><code>screen</code>은 내장 기능이어서 dependency가 추가로 필요하지 않아 사용에 제약이 없지만 그 기능이 적고 불편하다. <code>tmux</code>가 많이 사용되며 기본으로 설치되는 경우도 있으나(WSL Ubuntu에는 기본으로 설치돼있다.) 둘 모두 사용해본 적이 없어 추후에 다루도록 한다.</p>
<hr>
<p><strong>TODO</strong> :</p>
<p>입출력 Redirection 적극적으로 활용해보기 (특히 알고리즘 테스트 케이스 수행 시)</p>
<p>screen/tmux 모두 사용해보고 비교하기</p>
<p>리눅스 명령어 더 공부하고, pipe로 효과적인 예 만들기</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-14T05:00:00.000Z" title="2021-03-14T05:00:00.000Z">21-03-14</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-14T04:58:49.669Z" title="2021-03-14T04:58:49.669Z">21-03-14</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">7분안에 읽기 (약 999 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-dir/">리눅스 주요 디렉토리의 이름과 의미 정리 (계속 업데이트 예정)</a></h1><div class="content"><p>이 글은 리눅스를 처음 시작하는 경우 다른 OS의 디렉토리 구성과의 큰 차이로 인한 불편함을 줄이기 위한 큰 지도이다.</p>
<hr>
<h3 id="1-Home-디렉토리"><a href="#1-Home-디렉토리" class="headerlink" title="1. Home 디렉토리"></a><strong>1. Home 디렉토리</strong></h3><p>크게 2가지 Home 디렉토리가 있다. 이는 사용자에 따라 구분되는데,</p>
<ul>
<li>일반 사용자: <code>/home/&#123;USER_NAME&#125;</code> </li>
<li>루트 사용자: <code>/root</code></li>
</ul>
<p>형태로 사용한다.</p>
<hr>
<h3 id="2-시스템-디렉토리"><a href="#2-시스템-디렉토리" class="headerlink" title="2. 시스템 디렉토리"></a><strong>2. 시스템 디렉토리</strong></h3><p>시스템 디렉토리란 사용자 디렉토리를 제외한 (거의) 모든 디렉토리를 말한다. 윈도우에서 <code>Program Files</code> 폴더가 시스템 디렉토리에 포함된다고 생각하면 이 정의에 동의할 수 있을 것이고, <code>Windows</code>, <code>AppData</code> 등의 폴더만 시스템 디렉토리라고 생각한다면 이 정의에 동의하긴 어려울 듯 하다.</p>
<hr>
<h4 id="일반적인-경로-구성"><a href="#일반적인-경로-구성" class="headerlink" title="일반적인 경로 구성"></a><strong>일반적인 경로 구성</strong></h4><p><img src="/images/linux-dir/sysdir.png" alt="시스템 디렉토리의 경로 구성"></p>
<hr>
<p>(ex) <code>/usr/local/share/emacs</code></p>
<ul>
<li><code>/usr/local</code> : 스코프</li>
<li><code>/share</code> : 카테고리</li>
<li><code>/emacs</code> : 응용 프로그램</li>
</ul>
<h4 id="경로-구성-요소-스코프"><a href="#경로-구성-요소-스코프" class="headerlink" title="경로 구성 요소 - 스코프"></a><strong>경로 구성 요소 - 스코프</strong></h4><p>스코프는 가장 상위 디렉토리로서 하위 디렉토리인 카테고리나 응용 프로그램이 실행되는 범위를 나타낸다. 다만 구분에 사용되는 명확한 기준은 없고 단지 <code>/</code>가 <code>/usr</code>보다 좀 더 운영 체제에 가까운 근본적인 수준이라는 느낌이라고 한다(출처: 리눅스 핵심 레퍼런스).</p>
<p><strong>스코프의 종류</strong>:</p>
<ol>
<li><p><code>/</code> : 리눅스 시스템 파일</p>
</li>
<li><p><code>/usr</code> : <em>또 다른</em> 리눅스 시스템 파일</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/308045/differences-between-bin-sbin-usr-bin-usr-sbin-usr-local-bin-usr-local">Differences between /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin</a> 참고</li>
</ul>
</li>
<li><p><code>/usr/local</code> : 개인 컴퓨터에서 지역적으로 생성되는 시스템 파일</p>
<p>(ex) <code>/usr/local/bin</code> : 기본 프로그램이 아닌 경우 주로 여기에 설치된다.</p>
</li>
</ol>
<hr>
<h4 id="경로-구성-요소-카테고리"><a href="#경로-구성-요소-카테고리" class="headerlink" title="경로 구성 요소 - 카테고리"></a><strong>경로 구성 요소 - 카테고리</strong></h4><p>카테고리는 하위 디렉토리인 응용 프로그램의 목적을 나타낸다.</p>
<ol>
<li><p>실행 파일:   </p>
<ul>
<li><code>bin</code> : 바이너리</li>
<li><code>sbin</code> : 바이너리 (root 사용자 용이어서 root 권한이 필요하다.)</li>
<li><code>lib</code> : 바이너리에서 사용되는 라이브러리</li>
<li>Ubuntu 20.04의 경우 <code>/</code> 스코프의 <code>bin, sbin, lib</code>이 <code>/usr</code> 스코프로의 심볼릭 링크로 돼 있음 (어떤 배포판들이 또 이렇게 돼있는지는 확인 x)</li>
<li><img src="/images/linux-dir/link.png"></li>
</ul>
</li>
<li><p>설정 파일:</p>
<ul>
<li><code>etc</code> : 시스템 설정 파일</li>
<li><code>init.d</code>, <code>rc.d</code> : 부팅 설정 파일</li>
</ul>
</li>
<li><p>문서: <code>doc</code>, <code>info</code>, <code>man</code>, <code>share</code></p>
</li>
<li><p>HW 관련:</p>
<ul>
<li><code>dev</code> : Linux에서는 장치를 파일로 표현한다.</li>
<li><code>media</code>, <code>mnt</code> : Disk 마운트 지점<ul>
<li>리눅스는 디렉토리 트리가 하나여야 하므로 mount를 통해 트리를 병합해야 함</li>
<li><a target="_blank" rel="noopener" href="https://blog.naver.com/PostView.nhn?blogId=lunarispars&logNo=221462605068">[ 리눅스 마스터 ] 리눅스 디스크관리 - 마운트 (+실습, 명령어정리 )</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Runtime:</p>
<ul>
<li><code>var</code> : 클라이언트마다 다른 파일을 저장<ul>
<li><a target="_blank" rel="noopener" href="https://jadehan.tistory.com/11">Linux 기본 - /var 디렉토리의 이해</a></li>
</ul>
</li>
<li><code>run</code> : 실행 중인 프로세스의 ID를 담고 있는 PID 파일</li>
</ul>
</li>
<li><p>운영체제 관련:</p>
<ul>
<li><code>boot</code> ( <code>/boot/vmlinuz</code> ): 커널, 부팅 관련 파일</li>
<li><code>lost+found</code> : 손상된 파일 등 추후 복구를 위한 임시 저장 경로<ul>
<li><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/18154/what-is-the-purpose-of-the-lostfound-folder-in-linux-and-unix">What is the purpose of the lost+found folder in Linux and Unix?</a></li>
</ul>
</li>
<li><code>proc</code> : 현재 실행 중인 프로세스 정보. 저용량이며 실시간으로 반영한다.<ul>
<li><code>cat /proc/ioports</code> : I/O HW 목록 표시</li>
<li><code>cat /proc/cpuinfo</code> : 프로세서 정보. 코어 단위로 상세 정보를 출력</li>
<li><code>cat /proc/version</code> : OS 버전 정보 표시 (ex: <code>Linux version 4.19.128-microsoft-standard</code>)</li>
<li><code>cat /proc/uptime</code> : ms 단위로 uptime 출력. (<code>uptime</code> 명령어가 더 낫다)</li>
<li><code>ll /proc/&#123;PID&#125;</code> : PID에 대응되는 프로세스의 정보. (많은데 잘 모르겠다)</li>
<li><code>ll /proc/self</code> : 현재 실행중인 프로세스로의 심볼릭 링크 (ex) 1261</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p>이 글은 꾸준히 계속 업데이트될 예정입니다!</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-12T09:40:00.000Z" title="2021-03-12T09:40:00.000Z">21-03-12</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-25T01:46:12.580Z" title="2021-03-25T01:46:12.580Z">21-03-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">14분안에 읽기 (약 2101 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-5-stream-3/">5장 Stream API (3/3) - Stream을 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행 구현하기</a></h1><div class="content"><p>이 글은 Stream을 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행에 대해 다룬다. 또한 독자가 Node.js Stream에 대한 기초 지식이 있음을 전제로 작성되었음을 밝힌다.</p>
<p>참고 자료:</p>
<ul>
<li>Node.js에서의 스트림 자체에 대해서는 <a href="https://jsqna.com/ndp-5-stream-1/">5장 Stream API (1/3) - 스트림 개요 및 Readable Stream</a></li>
<li>Stream의 종류 4가지에 대해서는 <a href="https://jsqna.com/ndp-5-stream-2/">5장 Stream API (2/3) - Node.js의 4가지 스트림 소개와 사용법</a></li>
</ul>
<hr>
<h3 id="1-여러-파일을-하나의-파일로-순차적으로-병합하는-방법"><a href="#1-여러-파일을-하나의-파일로-순차적으로-병합하는-방법" class="headerlink" title="1. 여러 파일을 하나의 파일로 순차적으로 병합하는 방법"></a><strong>1. 여러 파일을 하나의 파일로 순차적으로 병합하는 방법</strong></h3><p>스트림은 당연하게도 비동기로 작동한다. 여러 개의 Redable Stream이 있고 하나의 Writable Stream이 있을 때,  각 작업들을 <strong>순차적으로 수행</strong>하는 방법이 있을까? 가능하다. 여러 개의 Readable 을 각각 Writable로 연결하고, Redable에 순서를 지정하면 된다. 아래 코드에 대한 설명은 주석으로 나타나 있으니 주석을 따라가기 바란다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fromArray = <span class="built_in">require</span>(<span class="string">&#x27;from2-array&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> through = <span class="built_in">require</span>(<span class="string">&#x27;through2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatFiles</span>(<span class="params">destination, files, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> destStream = fs.createWriteStream(destination);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fromArray.obj: readableStream of param array.</span></span><br><span class="line">  fromArray.obj(files) </span><br><span class="line">  <span class="comment">// readable 끼리 pipe 수행</span></span><br><span class="line">  <span class="comment">// through.obj(fn) == through(&#123; objectMode: true &#125;, fn) =&gt; Transform 스트림 반환</span></span><br><span class="line">  <span class="comment">// 현재는 through를 많이 사용하지 않아도 괜찮음. </span></span><br><span class="line">    .pipe(through.obj(<span class="function">(<span class="params">file, enc, done</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> src = fs.createReadStream(file);</span><br><span class="line">      <span class="comment">// 파일명을 file로 입력 받음</span></span><br><span class="line">      <span class="comment">// src1 =&gt; dest 로 pipe 연결 (pipe 사용 시 자동으로 백 프래셔 수행. src에서 데이터 생산만 하면 됨.)</span></span><br><span class="line">      <span class="comment">// src1.end</span></span><br><span class="line">      <span class="comment">// src2 =&gt; dest 로 pipe 연결</span></span><br><span class="line">      <span class="comment">// src2.end</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// dest.end</span></span><br><span class="line">      <span class="comment">// [끝]</span></span><br><span class="line">      <span class="comment">// ---</span></span><br><span class="line">      <span class="comment">// 연결을 요청함. 이벤트 핸들러 등록과 같은 느낌. 실제 스트림 간의 통신은 비동기로 수행됨.</span></span><br><span class="line">      src.pipe(destStream, &#123;<span class="attr">end</span>: <span class="literal">false</span>&#125;); </span><br><span class="line">      <span class="comment">// 이후 src에서 dest로 연결하려면, dest는 종료되지 않아야 함</span></span><br><span class="line">      <span class="comment">// ---</span></span><br><span class="line">      <span class="comment">// 이 파일에 대한 Read Stream이 끝나면, through.obj로 생성하는 Trasnform 스트림의</span></span><br><span class="line">      <span class="comment">// callback인 &#x27;done&#x27; 함수를 호출하게 함. (단순히 params 이름만 바꾼 것임.)</span></span><br><span class="line">      src.on(<span class="string">&#x27;end&#x27;</span>, done);</span><br><span class="line">    &#125;))</span><br><span class="line">    .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// WritableStream을 종료함.</span></span><br><span class="line">      destStream.end();</span><br><span class="line">      <span class="comment">// concatFiles 호출자에게 종료를 알림.</span></span><br><span class="line">      callback();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-순서에-상관-없이-결과를-비동기로-병렬적으로-한-파일에-출력하는-방법"><a href="#2-순서에-상관-없이-결과를-비동기로-병렬적으로-한-파일에-출력하는-방법" class="headerlink" title="2. 순서에 상관 없이 결과를 비동기로, 병렬적으로 한 파일에 출력하는 방법"></a><strong>2. 순서에 상관 없이 결과를 비동기로, 병렬적으로 한 파일에 출력하는 방법</strong></h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://thiswillbedownforsure.com/">http://thiswillbedownforsure.com</a> is down<br><a target="_blank" rel="noopener" href="https://www.naver.com/">https://www.naver.com</a> is up<br><a target="_blank" rel="noopener" href="https://www.google.com/">https://www.google.com</a> is up</p>
</blockquote>
<p>위와 같이 특정 사이트 목록들에 대해 health check를 하고 그 결과를 파일로 출력하는 프로그램을 만든다고 하자. 굳이 Stream으로 만들 필요는 없겠지만 그렇게 해본다면 다음과 같은 코드를 생각해볼 수 있다.</p>
<p>일단 Transform 기반의 스트림을 하나 정의한다. 이 스트림은 <code>request</code>의 콜백으로 스트림의 기능을 빌려주는 형태로 작동한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transform 스트림을 하나 정의한다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParallelStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">userTransform</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(&#123;<span class="attr">objectMode</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">    <span class="built_in">this</span>.userTransform = userTransform;</span><br><span class="line">    <span class="comment">// const userTransform = (chunk, enc, done, pushFn) =&gt; &#123; ... &#125;</span></span><br><span class="line">    <span class="built_in">this</span>.running = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.terminateCallback = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_transform</span>(<span class="params">chunk, enc, done</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.running++;</span><br><span class="line">    <span class="built_in">this</span>.userTransform(chunk, enc, <span class="built_in">this</span>._onComplete.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.push.bind(<span class="built_in">this</span>));</span><br><span class="line">    done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush는 스트림 종료 직전에 호출되며 즉 done() 의 호출 여부를 결정할 수 있다.</span></span><br><span class="line">  <span class="function"><span class="title">_flush</span>(<span class="params">done</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 작업이 모두 종료되기 전에 스트림이 종료되려고 하는 경우 done()을 호출하지 않는다.</span></span><br><span class="line">    <span class="comment">// 그 대신 onComplete에서 곧바로 종료할 수 있도록 done 함수를 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.running &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.terminateCallback = done;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      done();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// userTransform에서 done이라는 이름으로 호출되는 함수. 이 때의 done은 각 단위 작업의 완료를 의미한다.</span></span><br><span class="line">  <span class="function"><span class="title">_onComplete</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.running--;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.emit(<span class="string">&#x27;error&#x27;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 실행 중인 작업이 모두 종료되었고 스트림 종류가 한 번 이상 보류된 경우 직접 스트림을 종료한다.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.running === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.terminateCallback &amp;&amp; <span class="built_in">this</span>.terminateCallback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>위에서 정의한 스트림을 사용해 구현한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(ex)</span></span><br><span class="line"><span class="comment">1. process.argv[2]: urls.txt</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. urls.txt:</span></span><br><span class="line"><span class="comment">http://thiswillbedownforsure.com</span></span><br><span class="line"><span class="comment">https://www.naver.com</span></span><br><span class="line"><span class="comment">https://www.google.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fs.createReadStream(process.argv[<span class="number">2</span>]) <span class="comment">//[1] 파일로 readable 스트림 생성</span></span><br><span class="line">  .pipe(split()) <span class="comment">//[2] 파일의 라인 단위로 chunk를 잡아 출력하는 Transform 스트림 생성 (파일 내용은 url 단위로 줄바꿈 돼있음)</span></span><br><span class="line">  .pipe(</span><br><span class="line">    <span class="comment">//[3] pipe로 전달되는 데이터(각 URL) 마다 Transform Stream의 _transform 함수에서 아래의 콜백 함수가 호출된다.</span></span><br><span class="line">    <span class="comment">// 생성자로 이 콜백(userTransform이라고 불리는)을 등록한다.</span></span><br><span class="line">    <span class="keyword">new</span> ParallelStream(<span class="function">(<span class="params">url, enc, done, push</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!url) <span class="keyword">return</span> done(); <span class="comment">// 더 이상 데이터가 없는 경우 (null인 경우) 스트림 종료하도록 (this.running == 0)</span></span><br><span class="line">      request.head(url, <span class="function">(<span class="params">err, response</span>) =&gt;</span> &#123;</span><br><span class="line">        push(url + <span class="string">&quot; is &quot;</span> + (err ? <span class="string">&quot;down&quot;</span> : <span class="string">&quot;up&quot;</span>) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        done();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">&quot;results.txt&quot;</span>)) </span><br><span class="line">  .on(<span class="string">&quot;finish&quot;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;All urls were checked&quot;</span>));</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  result:</span></span><br><span class="line"><span class="comment">  http://thiswillbedownforsure.com is down</span></span><br><span class="line"><span class="comment">  https://www.naver.com is up</span></span><br><span class="line"><span class="comment">  https://www.google.com is up</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-의-동시-실행-수를-제한하는-방법"><a href="#3-2-의-동시-실행-수를-제한하는-방법" class="headerlink" title="3. (2)의 동시 실행 수를 제한하는 방법"></a><strong>3. (2)의 동시 실행 수를 제한하는 방법</strong></h3><p>비동기 요청 여러 개를 처리하는 일은 Node.js에선 매우 간단하다. Run to Completion이기 때문에 변수 하나로 비동기 작업의 개수를 정확히 세고 이 값에 기반해 의사 결정을 할 수 있다. </p>
<p>따라서 <code>this.running</code>의 개수가 동시 실행 제한 개수에 도달한 경우 처리하지 않으면 된다. 좀 더 정확하게는, <code>_transform</code> 함수에서 해당 chunk의 처리가 완료됐음을 알리는 콜백을 호출하지 않고 보류하면 된다. </p>
<p>이 경우 해당 chunk를 처리한 결과는 다음 스트림으로 넘어가지 않으며 현재 chunk가 처리되지 않았기 때문에 추가적인 chunk가 스트림으로 전달되지도 않는다(스트림 내부 버퍼에 쌓인다).</p>
<p>만약 ReadableStream이 chunk를 생성하고 내보내는 속도가 우리의 스트림의 처리 속도보다 빠르다면 처리되지 않는 chunk는 Transform의 버퍼에 쌓이며 이내 백 프레셔가 발동되고 알아서 처리될 것이다. - <code>pipe</code>로 연결하면 Node.js에서 자동으로 처리한다. 백 프래셔에 대해선 <a href="https://jsqna.com/ndp-5-stream-2/">5장 Stream API (2/3) - Node.js의 4가지 스트림 소개와 사용법</a>을 참고하라.</p>
<p>따라서 추가적으로 신경써야 하는 부분은 <strong>출력을 할 지 여부를 결정</strong>하는 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">concurrency, userTransform</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// ... 아래 두 멤버 필드만 추가된다.</span></span><br><span class="line">  <span class="built_in">this</span>.concurrency = concurrency;</span><br><span class="line">  <span class="built_in">this</span>.continueCallback = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 입력은 직접 제한하지 않고 계속 받는다.</span></span><br><span class="line"><span class="comment">// 완료를 의미하는 콜백을 호출해서 다음 chunk를 처리하지 않으면, 스트림 내부의 버퍼에 쌓이게 된다.</span></span><br><span class="line"><span class="comment">// 그러면 Node.js 런타임이 자동으로 백 프레셔를 수행한다.</span></span><br><span class="line"><span class="function"><span class="title">_transform</span>(<span class="params">chunk, enc, done</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.running++;</span><br><span class="line">  <span class="built_in">this</span>.userTransform(chunk, enc, <span class="built_in">this</span>.push.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._onComplete.bind(<span class="built_in">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.running &lt; <span class="built_in">this</span>.concurrency) &#123;</span><br><span class="line">    done();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 만약 현재 running의 최대치에 도달한 경우 완료 콜백을 수행하지 않는다. 이는 자연스럽게 백 프래셔 발동으로 이어진다.</span></span><br><span class="line">    <span class="built_in">this</span>.continueCallback = done;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">_onComplete</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.running--;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.emit(<span class="string">&quot;error&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// continueCallback이 할당되어 있으면 호출한다.</span></span><br><span class="line">  <span class="comment">// 이 시점에서 앞 chunk들은 모두 처리됐음이 보장된다.</span></span><br><span class="line">  <span class="comment">// 왜냐하면 입력이 출력보다 충분히 빨라 버퍼링이 되는 시점에서는 항상 continueCallback으로 done()이 호출되게 된다.</span></span><br><span class="line">  <span class="comment">// 항상 this.running == this.concurrency여서 꽉 차 있는 상태이기 때문이다.</span></span><br><span class="line">  <span class="comment">// (설명이 부드럽지 못한데 실행 흐름을 보고 설명을 다시 읽어보면 이해가 될 것이다.)</span></span><br><span class="line">  <span class="keyword">const</span> tmpCallback = <span class="built_in">this</span>.continueCallback;</span><br><span class="line">  <span class="built_in">this</span>.continueCallback = <span class="literal">null</span>;</span><br><span class="line">  tmpCallback &amp;&amp; tmpCallback();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.running === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.terminateCallback &amp;&amp; <span class="built_in">this</span>.terminateCallback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>참고 자료 (이번 글만 특별히 도움이 됐는지와는 별개로 읽은 몇 개의 글을 링크한다.):</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20769132/whats-the-proper-way-to-handle-back-pressure-in-a-node-js-transform-stream">What’s the proper way to handle back-pressure in a node.js Transform stream?</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/sindresorhus/awesome-nodejs#streams">Awesome Nodejs#Streams (Github Repo)</a></p>
<hr>
<p>TODO:</p>
<ol>
<li>Stream 관련해서 자세한 자료보단 내부 구조를 코드 수준에서 확인하는 게 가장 좋을 것 같다.</li>
<li>Back Pressure의 효과를 제대로 확인하기 위해선 디버거를 키고 스트림 객체를 살펴봐야 할 것 같다.</li>
<li>Stream의 추상하된 구현체들을 가져다 쓸 수록 더욱 더 이해하기 어려워지는 것 같다.</li>
<li>Stream을 3부작으로 나누어 작성하려고 했는데 한 10부작 까지는 나올 수도 있을 것 같다. 그만큼 부족하고, 글 쓰는 데도 매우 오래 걸린다.</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-05T10:50:00.000Z" title="2021-03-05T10:50:00.000Z">21-03-05</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-12T06:30:30.460Z" title="2021-03-12T06:30:30.460Z">21-03-12</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">12분안에 읽기 (약 1732 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-5-stream-2/">5장 Stream API (2/3) - Node.js의 4가지 스트림 소개와 사용법</a></h1><div class="content"><p>이 글은 Node.js 디자인 패턴 CH 05 스트림 코딩의 일부를 참고해서 작성하였으며, Node.js에서 코어 모듈로 제공하는 Stream 4종류를 다룬다. Node.js에서의 스트림 자체에 대해서는 <a href="https://jsqna.com/ndp-5-stream-1/">5장 Stream API (1/3) - 스트림 개요 및 Readable Stream</a>를 참고하라.</p>
<hr>
<h3 id="Node-js-스트림-객체"><a href="#Node-js-스트림-객체" class="headerlink" title="Node.js 스트림 객체"></a><strong>Node.js 스트림 객체</strong></h3><p>Node.js에서는 4가지의 추상 스트림 클래스를 제공하여 쉽게 스트림을 구현할 수 있게 한다. 이 클래스들은 core 모듈에서 제공하므로 추가 의존성이 필요하지 않다.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>목적</th>
<th>dataSource 가능</th>
</tr>
</thead>
<tbody><tr>
<td>stream.Readable</td>
<td>외부 데이터 읽기 (dataSource에서 꺼내는 형태)</td>
<td>True</td>
</tr>
<tr>
<td>stream.Writable</td>
<td>내부 데이터 외부로 전송하기 (dataSource로 써주는 형태)</td>
<td>False</td>
</tr>
<tr>
<td>stream.Duplex</td>
<td>Readable + Writable 스트림.</td>
<td>True</td>
</tr>
<tr>
<td>stream.Transform</td>
<td>외부 데이터 읽기 =&gt; 데이터 변조하기 =&gt; 외부로 전송하기</td>
<td>True</td>
</tr>
</tbody></table>
<hr>
<h3 id="Node-js의-두-버전의-스트림-API"><a href="#Node-js의-두-버전의-스트림-API" class="headerlink" title="Node.js의 두 버전의 스트림 API"></a><strong>Node.js의 두 버전의 스트림 API</strong></h3><p>Node.js에는 두 가지의 Stream API가 있다.</p>
<table>
<thead>
<tr>
<th>API Version</th>
<th>Name</th>
<th>Event Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Stream v1</td>
<td>Flowing Mode</td>
<td><code>on(&#39;data&#39;)</code></td>
<td>무조건 해당 데이터를 처리해야 함. 버퍼 크기 등의 문제로 처리하지 못 하는 경우 해당 데이터를 되살릴 방법이 없음.</td>
</tr>
<tr>
<td>Stream v2</td>
<td>Non-Flowing Mode</td>
<td><code>on(&#39;readable&#39;)</code></td>
<td>곧바로 데이터를 처리하지 않아도 됨. <u>백 프래셔</u>를 지원함.</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Back Pressure</strong>: Event 송신자의 처리량이 Event를 수신하는 측의 처리량을 넘기는 경우 송신자의 전송 속도를 줄여야 하는 경우가 생기는 데 이를 해결하는 메커니즘을 Back Pressure라고 한다.</p>
<table>
<thead>
<tr>
<th>송신자-수신자 처리량 차이</th>
<th>발생 오류</th>
<th>백프래셔 필요</th>
</tr>
</thead>
<tbody><tr>
<td>송신자 전송량 &lt; 수신자 처리량</td>
<td>없음</td>
<td>False</td>
</tr>
<tr>
<td>송신자 전송량 &gt; 수신자 처리량</td>
<td>처리하지 못하는 데이터에 대한 정의되지 않은 동작 등 손실 발생 가능</td>
<td>True</td>
</tr>
</tbody></table>
<p><strong>Stream v2의 백 프래셔</strong>:<br>Node.js의 버퍼가 알아서 버퍼링을 해주며, 버퍼 한계치를 넘으면 OS에서 패킷을 drop시켜 sender 입장에서 전송 속도를 늦추게 함. 이 기능을 자동으로 지원. (v1도 가능하다고 함. 다만 더 어렵다고 함.)</p>
<p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26174308/what-are-the-differences-between-readable-and-data-event-of-process-stdin-stream">What are the differences between readable and data event of process.stdin stream?</a></p>
<p>추가 참고:</p>
<p><a target="_blank" rel="noopener" href="https://javaexpert.tistory.com/811?category=678737">[RxJava2]Flowable에서의 Backpressure</a></p>
<p><a target="_blank" rel="noopener" href="https://javaexpert.tistory.com/811?category=678737">[RxJava2]Backpressure와 함께 Flowable를 만들어 보자</a></p>
</blockquote>
<h3 id="1-Readable-스트림"><a href="#1-Readable-스트림" class="headerlink" title="1. Readable 스트림"></a><strong>1. Readable 스트림</strong></h3><p>Readable 스트림은 데이터를 읽어들이는 게 목적이다.</p>
<h4 id="1-1-사용-예시"><a href="#1-1-사용-예시" class="headerlink" title="1-1. 사용 예시:"></a><strong>1-1. 사용 예시</strong>:</h4><p><code>stream.read()</code> 함수를 사용하면 chunk를 반환한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RandomStream = <span class="built_in">require</span>(<span class="string">&quot;./randomStream&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> RandomStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// readable 스트림:</span></span><br><span class="line"><span class="comment">// stream.read() 로 내용을 읽는 것을 의미한다.</span></span><br><span class="line">randomStream.on(<span class="string">&quot;readable&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> chunk;</span><br><span class="line">  <span class="keyword">while</span> ((chunk = randomStream.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received: <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-2-Readable-구현-코드"><a href="#1-2-Readable-구현-코드" class="headerlink" title="1-2. Readable 구현 코드"></a><strong>1-2. Readable 구현 코드</strong></h4><p>Readable Stream은 <code>_read</code> 함수를 구현하면 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>); <span class="comment">// 코어 모듈 (stream)</span></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> <span class="built_in">require</span>(<span class="string">&#x27;chance&#x27;</span>)(); <span class="comment">// 랜덤 (외부 의존성)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [1] Readable 구현체</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Readable에서 구현해야 하는 함수는 _read 하나임</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="function"><span class="title">_read</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string();        <span class="comment">//[1] 랜덤값 생성</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Pushing chunk of size: <span class="subst">$&#123;chunk.length&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">this</span>.push(chunk, <span class="string">&#x27;utf8&#x27;</span>);             <span class="comment">//[2] Encoding을 설정하면 String으로 읽음</span></span><br><span class="line">    <span class="keyword">if</span>(chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123;    <span class="comment">//[3] null을 보내면 종료하기로 약속함</span></span><br><span class="line">      <span class="built_in">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2] 스트림 사용</span></span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> RandomStream();</span><br><span class="line"></span><br><span class="line">randomStream.on(<span class="string">&#x27;readable&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> chunk;</span><br><span class="line">  <span class="keyword">while</span>((chunk = randomStream.read()) !== <span class="literal">null</span>) &#123; <span class="comment">// [1] 약속한대로 null 이면 읽기 종료</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received: <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-Writable-스트림"><a href="#2-Writable-스트림" class="headerlink" title="2. Writable 스트림"></a><strong>2. Writable 스트림</strong></h3><p>Writable 스트림은 데이터를 생성하는 게 목적이다. (ex) HTTP response 생성</p>
<h4 id="2-1-사용-예시"><a href="#2-1-사용-예시" class="headerlink" title="2-1. 사용 예시"></a><strong>2-1. 사용 예시</strong></h4><p><code>stream.write</code> 함수를 사용하면 스트림에 내용을 쓸 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// res가 Writable Stream 이다 :)</span></span><br><span class="line"><span class="comment">// &quot;Writable Stream은 데이터의 목적지를 나타낸다&quot;는 뜻은</span></span><br><span class="line"><span class="comment">// stream.write(내용) 을 쓰면 해당 stream으로 전달된다는 뜻이다.</span></span><br><span class="line"><span class="comment">// 전송하는 입장에선 writable이지만, 받는 입장에선 readable로 취급하면 쓰기, 읽기가 각각 되는 것이다.</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>)</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;); </span><br><span class="line">    <span class="keyword">while</span> (chance.bool(&#123; <span class="attr">likelihood</span>: <span class="number">95</span> &#125;)) &#123; <span class="comment">// 5% 확률로 루프 빠져나오는 코드.</span></span><br><span class="line">      res.write(chance.string() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end(<span class="string">&quot;\nThe end...\n&quot;</span>);</span><br><span class="line">    res.on(<span class="string">&quot;finish&quot;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;All data was sent&quot;</span>)); <span class="comment">// 스트림에 finish 이벤트 리스너 등록 후 종료</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Listening on http://localhost:8080&quot;</span>));</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-2-Writable-구현-코드"><a href="#2-2-Writable-구현-코드" class="headerlink" title="2-2. Writable 구현 코드"></a><strong>2-2. Writable 구현 코드</strong></h4><p>(윗 코드와는 상관 없음.) Writable Stream은 <code>_write</code> 함수를 구현하면 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToFileStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Writable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(&#123;<span class="attr">objectMode</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _write (chunk, encoding, callback) &#123;</span><br><span class="line">    mkdirp(path.dirname(chunk.path), <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(err);</span><br><span class="line">      &#125;</span><br><span class="line">      fs.writeFile(chunk.path, chunk.content, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-3-백-프래셔-예제"><a href="#2-3-백-프래셔-예제" class="headerlink" title="2-3. 백 프래셔 예제"></a><strong>2-3. 백 프래셔 예제</strong></h4><p>백 프래셔란 Read보다 Write가 빠를 때 병목이 생기는 것을 방지하는 메커니즘이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>)</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateMore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (chance.bool(&#123; <span class="attr">likelihood</span>: <span class="number">95</span> &#125;)) &#123;</span><br><span class="line">        <span class="keyword">const</span> shouldContinue = res.write(</span><br><span class="line">          <span class="comment">// res.write가 Falsy를 반환하면 내부 버퍼를 다 사용한 것</span></span><br><span class="line">          <span class="comment">// (자세한 내용은 나중에 포스팅할 예정)</span></span><br><span class="line">          chance.string(&#123; <span class="attr">length</span>: <span class="number">16</span> * <span class="number">1024</span> - <span class="number">1</span> &#125;)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!shouldContinue) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;Backpressure&quot;</span>); <span class="comment">// 백 프래셔를 수행해야 하는 시점</span></span><br><span class="line">          <span class="keyword">return</span> res.once(<span class="string">&quot;drain&quot;</span>, generateMore); <span class="comment">// once로 drain 이벤트 핸들러를 등록해 재시작 대기</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.end(<span class="string">&quot;\nThe end...\n&quot;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;All data was sent&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    generateMore();</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Listening on http://localhost:8080&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-Duplex-Stream"><a href="#3-Duplex-Stream" class="headerlink" title="3. Duplex Stream"></a><strong>3. Duplex Stream</strong></h3><p>Duplex Stream은 Readable + Writable 그 이상 그 이하도 아니며 따라서 설명을 생략한다.</p>
<hr>
<h3 id="4-Transform-Stream"><a href="#4-Transform-Stream" class="headerlink" title="4. Transform Stream"></a><strong>4. Transform Stream</strong></h3><p>Transform 스트림은 읽어들인 데이터를 변조해 내보내는 스트림이다. 스트림이니만큼 chunk 단위로 데이터가 오므로 변환에 유의해야 한다.</p>
<h4 id="4-1-사용-예시"><a href="#4-1-사용-예시" class="headerlink" title="4-1. 사용 예시"></a><strong>4-1. 사용 예시</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReplaceStream = <span class="built_in">require</span>(<span class="string">&quot;./replaceStream&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = <span class="keyword">new</span> ReplaceStream(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;Node.js&quot;</span>);</span><br><span class="line">rs.on(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> <span class="built_in">console</span>.log(chunk.toString()));</span><br><span class="line"></span><br><span class="line">rs.write(<span class="string">&quot;Hello W&quot;</span>);</span><br><span class="line">rs.write(<span class="string">&quot;orld!&quot;</span>);</span><br><span class="line">rs.end();</span><br><span class="line"><span class="comment">// Hello Node.js</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="4-2-Transform-구현-코드"><a href="#4-2-Transform-구현-코드" class="headerlink" title="4-2. Transform 구현 코드"></a><strong>4-2. Transform 구현 코드</strong></h4><p>스트림 상에서 문자열 일부를 치환하는 코드이다. (어렵다.)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">searchString, replaceString</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.searchString = searchString;</span><br><span class="line">    <span class="built_in">this</span>.replaceString = replaceString;</span><br><span class="line">    <span class="built_in">this</span>.tailPiece = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_transform</span>(<span class="params">chunk, encoding, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pieces = (<span class="built_in">this</span>.tailPiece + chunk)</span><br><span class="line">      .split(<span class="built_in">this</span>.searchString);</span><br><span class="line">    <span class="keyword">const</span> lastPiece = pieces[pieces.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> tailPieceLen = <span class="built_in">this</span>.searchString.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.tailPiece = lastPiece.slice(-tailPieceLen); </span><br><span class="line">    pieces[pieces.length - <span class="number">1</span>] = lastPiece.slice(<span class="number">0</span>,-tailPieceLen);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.push(pieces.join(<span class="built_in">this</span>.replaceString));</span><br><span class="line">    <span class="comment">// 여기서의 callback은 각 chunk의 처리가 완료됐음을 알리는 함수이다.</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 여기서의 callback은 스트림을 종료시키는 함수이다.</span></span><br><span class="line">  <span class="function"><span class="title">_flush</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// flush라는 이름 답게 출력되지 않은 데이터의 출력을 수행한다.</span></span><br><span class="line">    <span class="built_in">this</span>.push(<span class="built_in">this</span>.tailPiece);</span><br><span class="line">    <span class="comment">// 스트림을 종료한다.</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>TODO</strong>: (전부 다 책에서 나온 내용)</p>
<p>스트림 간의 Pipelining(조합) 소개</p>
<p>스트림 기반 비동기 제어 소개 (순차/비순차/제한된 비순차)</p>
<p>스트림 fork, merge</p>
<p>스트림 멀티플렉싱, 디멀티플렉싱</p>
<hr>
<p>소스 코드 출처: Node.js 디자인 패턴</p>
<p>스트림 파트는 내가 스트림에 대한 경험도 거의 없고 책에서 설명하는 내용이 어려워서 내 생각을 넣어 포스팅하기가 매우 어려웠다. 내용을 간략히 정리하는 선에서 마쳐야 할 것 같아 아쉽다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-03T12:00:00.000Z" title="2021-03-03T12:00:00.000Z">21-03-03</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-03T11:53:28.360Z" title="2021-03-03T11:53:28.360Z">21-03-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">8분안에 읽기 (약 1126 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-7-dependency-injection-2/">7장 의존성 주입 (2/2) - 간단한 Javascript DI 컨테이너 구현체</a></h1><div class="content"><p>이 글은 <a href="https://jsqna.com/ndp-7-dependency-injection-1/">7장 의존성 주입 (1/2)</a>에서 설명한 DI 컨테이너의 간단한 구현체를 제시한다. Javascript이기 때문에 타입 정보를 얻을 수 없어 String으로 의존성을 판단하는 부분을 참고하기 바란다. </p>
<hr>
<p>이 글의 코드는 <a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code">출처</a>에서 배포된 코드를 가져왔음을 밝힌다.</p>
<hr>
<h2 id="1-DI-컨테이너-구현"><a href="#1-DI-컨테이너-구현" class="headerlink" title="1. DI 컨테이너 구현"></a><strong>1. DI 컨테이너 구현</strong></h2><h3 id="diContainer-js"><a href="#diContainer-js" class="headerlink" title="diContainer.js"></a><strong>diContainer.js</strong></h3><p>아쉽게도 패키지 전체를 미리 스캔하여 자동으로 의존 관계를 파악하고 의존성 주입을 수행하지는 않는다. 기능은 크게 <code>get</code>, <code>factory</code>, <code>register</code>가 있다. 자세한 설명은 주석을 참고하라.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fnArgs는 함수의 인자 목록을 String 배열로 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> fnArgs = <span class="built_in">require</span>(<span class="string">&quot;parse-fn-args&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dependencies = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> factories = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> diContainer = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// factory, register 둘 다 단순 등록 기능이다.</span></span><br><span class="line">  <span class="comment">// factory 메소드의 경우 의존성 주입이 필요한 객체인 경우 사용한다.</span></span><br><span class="line">  diContainer.factory = <span class="function">(<span class="params">name, factory</span>) =&gt;</span> &#123;</span><br><span class="line">    factories[name] = factory;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register 메소드의 경우 의존성 주입이 필요 없는 객체(상수 등)를 등록할 때 사용한다.</span></span><br><span class="line">  diContainer.register = <span class="function">(<span class="params">name, dep</span>) =&gt;</span> &#123;</span><br><span class="line">    dependencies[name] = dep;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. get은 dependencies에 없는 경우 factory로 간주하고 가져옴</span></span><br><span class="line"><span class="comment">  2. 만약 가져오려 했던 객체가 존재하면 해당 객체로 inject를 호출함 (inject를 통해 재귀적으로 의존성을 resolve.)</span></span><br><span class="line"><span class="comment">  3. (2)의 결과를 dependencies에 저장</span></span><br><span class="line"><span class="comment">  4. 만약 그래도 dependencies에 없는 경우 모듈을 찾을 수 없는 것.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  diContainer.get = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dependencies[name]) &#123;</span><br><span class="line">      <span class="keyword">const</span> factory = factories[name];</span><br><span class="line">      dependencies[name] = factory &amp;&amp; diContainer.inject(factory);</span><br><span class="line">      <span class="keyword">if</span> (!dependencies[name]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Cannot find module: &quot;</span> + name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dependencies[name];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. factory로 등록된 객체를 전달받음</span></span><br><span class="line"><span class="comment">  2. fnArgs는 함수(factory의 경우, 의존성을 명시한 함수를 export 함.)의 인자를 가져옴</span></span><br><span class="line"><span class="comment">  3. 인자에 대해 map으로 get을 수행한 배열을 args 변수에 저장함</span></span><br><span class="line"><span class="comment">  4. factory(생성자)를 resolved 된 dependencies로 호출함</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  diContainer.inject = <span class="function">(<span class="params">factory</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> args = fnArgs(factory).map(<span class="function"><span class="keyword">function</span> (<span class="params">dependency</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> diContainer.get(dependency);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> factory.apply(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> diContainer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-컨테이너-사용"><a href="#2-컨테이너-사용" class="headerlink" title="2. 컨테이너 사용"></a><strong>2. 컨테이너 사용</strong></h2><h3 id="1-app-js"><a href="#1-app-js" class="headerlink" title="1. app.js"></a><strong>1. app.js</strong></h3><p>DI 컨테이너에 각 객체를 등록하는 과정을 이 파일을 진입점 삼아 수행하였다. 좀 더 좋은 DI 컨테이너라면 Reflection 등을 이용해 자동으로 mark된 객체를 등록하고 의존성 주입을 진행할 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> diContainer = <span class="built_in">require</span>(<span class="string">&quot;./lib/diContainer&quot;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// register는 추가적으로 의존성 주입이 필요 없는 객체를 등록한다. (상수 등)</span></span><br><span class="line">diContainer.register(<span class="string">&quot;dbName&quot;</span>, <span class="string">&quot;example-db&quot;</span>);</span><br><span class="line">diContainer.register(<span class="string">&quot;tokenSecret&quot;</span>, <span class="string">&quot;SHHH!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// factory는 의존성 주입이 필요한 객체를 등록한다.</span></span><br><span class="line">diContainer.factory(<span class="string">&quot;db&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;./lib/db&quot;</span>));</span><br><span class="line"><span class="comment">// Service 객체 등록 (의존성 주입 필요한 상태)</span></span><br><span class="line">diContainer.factory(<span class="string">&quot;authService&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;./lib/authService&quot;</span>));</span><br><span class="line"><span class="comment">// Controller 객체 등록 (의존성 주입 필요한 상태)</span></span><br><span class="line">diContainer.factory(<span class="string">&quot;authController&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;./lib/authController&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// get은 의존성을 반환한다. (재귀적으로 의존성 주입이 된 채로 반환된다.)</span></span><br><span class="line"><span class="keyword">const</span> authController = diContainer.get(<span class="string">&quot;authController&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Express에 Controller 등록</span></span><br><span class="line">app.post(<span class="string">&quot;/login&quot;</span>, authController.login);</span><br><span class="line">app.get(<span class="string">&quot;/checkToken&quot;</span>, authController.checkToken);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-authController-js"><a href="#2-authController-js" class="headerlink" title="2. authController.js"></a><strong>2. authController.js</strong></h3><p>의존성 주입이 적용되는 객체 1이다. 주석 참고.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Express에서 일반적으로 사용되는 Controller 예제이다.</span></span><br><span class="line"><span class="comment">// 모듈 차원에서 함수로 내보내며(DI 컨테이너 작동 방식에 맞춤), 인자에 이름으로 의존성을 명시한다.</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">authService</span>) =&gt;</span> &#123; <span class="comment">// DI 컨테이너에 의해 authService 의존성을 주입 받게 된다.</span></span><br><span class="line">  <span class="keyword">const</span> authController = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  authController.login = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    authService.login(req.body.username, req.body.password,</span><br><span class="line">      (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> res.status(<span class="number">401</span>).send(&#123;</span><br><span class="line">            ok: <span class="literal">false</span>,</span><br><span class="line">            error: <span class="string">&#x27;Invalid username/password&#x27;</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.status(<span class="number">200</span>).send(&#123;<span class="attr">ok</span>: <span class="literal">true</span>, <span class="attr">token</span>: result&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  authController.checkToken = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    authService.checkToken(req.query.token,</span><br><span class="line">      (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> res.status(<span class="number">401</span>).send(&#123;</span><br><span class="line">            ok: <span class="literal">false</span>,</span><br><span class="line">            error: <span class="string">&#x27;Token is invalid or expired&#x27;</span>  </span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.status(<span class="number">200</span>).send(&#123;<span class="attr">ok</span>: <span class="string">&#x27;true&#x27;</span>, <span class="attr">user</span>: result&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> authController;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="3-appService-js"><a href="#3-appService-js" class="headerlink" title="3. appService.js"></a><strong>3. appService.js</strong></h3><p>의존성 주입이 적용되는 객체 2이다. 주석 참고.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jwt-simple&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">&#x27;bcrypt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 역시 모듈을 함수로 내보내며 의존성을 명시했다.</span></span><br><span class="line"><span class="comment">// 이 예제에서는 db 객체에 대해선 생략하였다. (DI 설명에서 의미 없는 구성 요소)</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">db, tokenSecret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> users = db.(...);</span><br><span class="line">  <span class="keyword">const</span> authService = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  authService.login = <span class="function">(<span class="params">username, password, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    users.get(username, <span class="function">(<span class="params">err, user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      </span><br><span class="line">      bcrypt.compare(password, user.hash, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">        <span class="keyword">if</span> (!res) <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid password&#x27;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> token = jwt.encode(&#123;</span><br><span class="line">          username: username,</span><br><span class="line">          expire: <span class="built_in">Date</span>.now() + (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>) <span class="comment">//1 hour</span></span><br><span class="line">        &#125;, tokenSecret);</span><br><span class="line">        </span><br><span class="line">        callback(<span class="literal">null</span>, token);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  authService.checkToken = <span class="function">(<span class="params">token, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> userData;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      userData = jwt.decode(token, tokenSecret);</span><br><span class="line">      <span class="keyword">if</span> (userData.expire &lt;= <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Token expired&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      <span class="keyword">return</span> process.nextTick(callback.bind(<span class="literal">null</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    users.get(userData.username, <span class="function">(<span class="params">err, user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      callback(<span class="literal">null</span>, &#123;<span class="attr">username</span>: userData.username&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> authService;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>TODO:</strong></p>
<p>Node.js 스트림 이어서 포스팅하기</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-23T12:20:00.000Z" title="2021-02-23T12:20:00.000Z">21-02-23</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-03T11:50:32.780Z" title="2021-03-03T11:50:32.780Z">21-03-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">11분안에 읽기 (약 1690 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-7-dependency-injection-1/">7장 의존성 주입 (1/2) - Node.js/Javascript 환경에서의 한 패키지 내의 의존성 관리</a></h1><div class="content"><p>이 글은 Node.js/Javascript 환경에서의 <u><strong>한 패키지(App) 내의</strong></u> 모듈 간의 의존성을 관리하는 방법에 대해 다룬다. 명시하지 않은 경우 Javascript 환경임을 미리 밝힌다.</p>
<blockquote>
<p>Typescript는 지금까지 많이 활용돼왔고 생태계가 성숙한 상태이므로, OOP 방식으로 문제 해결을 하려는 경우 Typescript가 적정 기술이라고 생각한다.</p>
</blockquote>
<hr>
<p><img src="/images/ndp-7/hardcoded-import.png" alt="흔한 하드코딩 의존성(구현체 직접 import)의 예"></p>
<hr>
<h3 id="1-유독-언급이-적은-Node-js에서의-의존성-관리-왜"><a href="#1-유독-언급이-적은-Node-js에서의-의존성-관리-왜" class="headerlink" title="1. 유독 언급이 적은 Node.js에서의 의존성 관리, 왜?"></a><strong>1. 유독 언급이 적은 Node.js에서의 의존성 관리, 왜?</strong></h3><p>백엔드와 같이 쉽고 빠르게 규모가 커지고 기능 변경이 잦은 코드 베이스인 경우 설계가 중요한 경우가 많을 것이다. 설계는 의존성 관리가 기본이며 Node.js 백엔드 또한 그 예외는 아닐 것인데 말이다.</p>
<p><strong>Q.</strong> 왜 Node.js에서는 <u>하드 코딩된 의존 관계</u>를 구축하는 코드를 찾기가 매우 쉬울까?</p>
<p><strong>A. 가설:</strong> 인터페이스와 상관 없이 임의의 객체를 집어 넣어 테스트를 할 수 있기 때문에 굳이 Interface가 필요하지 않다. <u>동적 타입 언어</u>이니까.</p>
<hr>
<h3 id="2-“동적-타입-언어”라는-특징"><a href="#2-“동적-타입-언어”라는-특징" class="headerlink" title="2. “동적 타입 언어”라는 특징"></a><strong>2. “동적 타입 언어”라는 특징</strong></h3><h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a><strong>장점</strong></h4><p>만약 Java 였다면 Interface를 아예 사용하지 않는 것은 설계에 큰 문제가 있음을 시사하는 것이겠지만 <u>Javascript는 동적 타입 언어</u>이다. 기능을 실행하는 객체의 타입이 중요하지 않은 언어이다. 인터페이스가 없는 만큼 규칙도 없지만 그만큼 유연해진 셈이다.</p>
<h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a><strong>단점</strong></h4><p>다만 동적 타입을 활용해 테스트가 가능하다고 해도 자연스럽게 생기는 강한 결합이 사라지는 것은 아니다. <u>구현체에 직접 의존하면 강한 결합이 발생</u>한다. 의존하는 객체의 구현 상세에 대한 아무런 격리 장치가 없으며 구현체에서 변경이 생겼을 때 해당 의존성을 사용하는 모든 객체에 그 여파가 전달되므로 다시 검증(테스트), 빌드해야만 한다. </p>
<hr>
<h3 id="3-OOP의-문제-해결-방식"><a href="#3-OOP의-문제-해결-방식" class="headerlink" title="3. OOP의 문제 해결 방식"></a><strong>3. OOP의 문제 해결 방식</strong></h3><p>OOP 에서는 인터페이스를 미리 정의하고 해당 인터페이스를 최대한 변경하지 않음(Open Close Principle)을 통해 문제를 해결한다. 인터페이스에 의존함을 통해 구현 상세와 사용 객체를 진정으로 격리시킬 수 있으며 이는 의존성 관리에 매우 큰 역할을 한다.</p>
<p>의존성에 의한 강한 결합을 막는 수단은 현재로썬 서비스 로케이터 패턴과 의존성 주입이 있다. </p>
<p>이제부터 이 글은 Javascript/Node.js 에서의 의존성 주입에 대해 다룬다.</p>
<hr>
<h3 id="4-서비스-로케이터-패턴"><a href="#4-서비스-로케이터-패턴" class="headerlink" title="4. 서비스 로케이터 패턴"></a><strong>4. 서비스 로케이터 패턴</strong></h3><p>서비스 로케이터 패턴이란 “<strong>의존성이 있는 각 객체가 서비스 로케이터 객체만을 직접 의존하고, 각 객체는 서비스 로케이터에 의존성을 명시해 구현체를 받아오는 것</strong>“을 말한다. (서비스 로케이터 패턴에 대해 더 자세히 알고 싶다면 <a target="_blank" rel="noopener" href="https://edykim.com/ko/post/the-service-locator-is-an-antipattern/#%EC%A0%95%EB%A6%AC">이 글</a>을 참고하라.)</p>
<p>아래 예는 AuthController가 AuthService에 의존하는 코드이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AuthController.js - AuthService에 의존한다.</span></span><br><span class="line"><span class="comment">// AuthController는 ServiceLocator에만 &#x27;직접&#x27; 의존한다.</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">serviceLocator</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> authService = serviceLocator.get(<span class="string">&#x27;authService&#x27;</span>); <span class="comment">// TS 등 정적 타입 언어에서는 타입으로 받아온다.</span></span><br><span class="line">  <span class="comment">// Javascript는 딱히 타입이 없으므로 String으로 의존성(객체)을 식별한다.</span></span><br><span class="line">  <span class="comment">// require()와 사용 방식이 매우 닮아있다. 차이가 있다면, require는 전체 경로를 명시한다는 점이다.</span></span><br><span class="line">  <span class="keyword">const</span> authController = &#123;&#125;;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="서비스-로케이터-패턴의-장점"><a href="#서비스-로케이터-패턴의-장점" class="headerlink" title="서비스 로케이터 패턴의 장점"></a><strong>서비스 로케이터 패턴의 장점</strong></h4><p>의존성의 구현체에 의존하지 않게 해준다. 이는 의존성 주입과 동일한 장점이며 아주 좋은 장점이다.</p>
<h4 id="서비스-로케이터-패턴의-단점"><a href="#서비스-로케이터-패턴의-단점" class="headerlink" title="서비스 로케이터 패턴의 단점"></a><strong>서비스 로케이터 패턴의 단점</strong></h4><p>객체의 구현 코드를 보지 않으면 곧바로 의존 관게를 파악할 수 없다. 생성자 등으로 명시하지 않기 때문에 - 생성자의 파라미터로 명시한다면 필수값이라는 문서화의 역할을 수행하게 되는데 비해 - 모든 객체에 대해 문서화가 필요하다.</p>
<hr>
<h3 id="5-의존성-주입"><a href="#5-의존성-주입" class="headerlink" title="5. 의존성 주입"></a><strong>5. 의존성 주입</strong></h3><p>의존 관계를 가장 잘 다루는 방법은 아마도 <u>DI</u>일 것이다. Javascript 진영에선 Angular가 최초로 의존성 주입을 도입한 것으로 안다(Typescript도 없던 시절이었는데!).</p>
<p>의존성 주입이란 “<strong>모듈의 의존성을 외부 개체에 의해 입력으로 전달 받는 것</strong>“을 말한다.  의존성 주입의 개념 자체는 매우 간단하다. DI를 지원하기 위한 컨테이너와 지원 방식을 구현하는 게 어려울 뿐이다. </p>
<p>(ex) AuthController가 AuthService에 의존하는 경우의 예시를 확인하자.</p>
<p>Before DI: 구현체를 직접 가져오는 모듈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 직접 가져온다.</span></span><br><span class="line"><span class="keyword">const</span> authService = <span class="built_in">require</span>(<span class="string">&#x27;./authService&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.login = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  authService.login(...);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>After DI: 의존성을 받아오는 모듈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authService를 전달 받아서 사용한다. authService의 출처와 구현체에 대해 아는 것은 더 이상 이 객체의 책임이 아니다. 그냥 사용만 하면 된다.</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">authService</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> authController = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  authController.login = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    authService.login(req.body.username, req.body.password, ...);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> authController</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Service Locator / DI Container의 간략한 구현도 포함하려고 했으나 2편에서 다루도록 하겠다.</p>
</blockquote>
<hr>
<h3 id="6-Node-js의-DI-컨테이너-생태계"><a href="#6-Node-js의-DI-컨테이너-생태계" class="headerlink" title="6. Node.js의 DI 컨테이너 생태계"></a><strong>6. Node.js의 DI 컨테이너 생태계</strong></h3><p>약간의 짬을 내어 찾아보니 크게 4개의 오픈소스 컨테이너들이 있었다: <a target="_blank" rel="noopener" href="https://github.com/inversify/InversifyJS">InversifyJs</a>, <a target="_blank" rel="noopener" href="https://github.com/microsoft/tsyringe">tsyringe</a>, <a target="_blank" rel="noopener" href="https://github.com/typestack/typedi">typedi</a>, <a target="_blank" rel="noopener" href="https://github.com/jeffijoe/awilix">awilix</a> (점유율 순). </p>
<blockquote>
<p>tsyringe는 Microsoft에서 만들었다. 재밌는 점은 MS에서 inversifyjs를 사용한다고 나와있는 것이다. NestJs는 DI를 Core에 내장하여 차트에 포함시켰다.</p>
</blockquote>
<p><img src="/images/ndp-7/di-container-comp-chart.png" alt="dif"></p>
<p>각 라이브러리의 자세한 비교는 기회가 된다면 추후 진행하려 한다.</p>
<hr>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><strong>TODO:</strong></h4><ol>
<li>Clean Architecture를 다시 읽는다. SOLID 원칙 조차 희미해진 듯하다.</li>
<li>DI와 DIP의 관계에 대해 다시 공부해야겠다.</li>
<li>양파 껍질 Architecture에 대해 제대로 이해해야겠다.</li>
<li><code>require</code>과 서비스 로케이터 패턴의 관계에 대해 이해해야겠다.</li>
</ol>
<p>CS에서 가장 자신있던 객체지향을 이렇게 모르게 됐다는 게 새삼 충격적이다 :(</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-02T12:20:00.000Z" title="2021-02-02T12:20:00.000Z">21-02-02</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-02-02T12:06:31.340Z" title="2021-02-02T12:06:31.340Z">21-02-02</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/ExpressJs/">ExpressJs</a></span><span class="level-item">14분안에 읽기 (약 2162 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ejs-1-why-express-2/">Express를 사용해야 할 이유 (2) - Microframework</a></h1><div class="content"><p>이 글은 microframework라는 개념과 express의 용도를 연관지어 <u>생각</u>해본다. 이 글은 기술적으로 사실이라고 검증되지 않은 내용이 포함되며 데이터에 근거한 결론보다 생각 위주로 작성됨을 미리 알린다.</p>
<hr>
<p>대략 2주 전 <a href="https://jsqna.com/ejs-1-why-express/">Express를 사용해야 할 이유 (1)</a>을 쓰면서 왜 Express를 많이 쓰는걸까? 생각을 많이 해봤지만 결론을 내리지 못 했다. 아래는 당시 글에 작성했던 intro이다.</p>
<blockquote>
<p>잠시나마 사용해본 Express는 내게 React 같았다. 무엇이든 할 수 있어 보였으나 직접 하기에는 매우 불편하고, 그러다보니 REST API를 작성할 때 이런 것까지 해야 돼? 혹은 이런 기능이 없어서 불편하네 등이 많았는데…</p>
</blockquote>
<p>오늘이 되어서야 왜 Express가 기능이 적은지 알게 되었는데, 그 마법의 키워드는 바로 <em>Microframework</em>이다. (진지하게 이 키워드에 대해 오늘 이전에 들어본 적이 단 한 번도 없었다.)</p>
<h3 id="Microframework란"><a href="#Microframework란" class="headerlink" title="Microframework란?"></a><strong>Microframework란?</strong></h3><p><strong>1. 정의</strong>: <u>최소 기능을 갖는</u> 웹 애플리케이션 프레임워크 &lt;-&gt; full-fledged framework (필요한 기능은 대부분 갖춘 프레임워크를 의미)</p>
<p><strong>2. 기능</strong>: Microframework는 서비스 개발 시 “<u>주로</u>“, “<u>일반적으로</u>“ 사용되는 공통적인 기능들을 제공하지 않는다. 제공하지 않는다는 그 기능들이란 대체로 아래와 같다.</p>
<ul>
<li>인증, 인가</li>
<li>ORM 혹은 DB 관련 기능</li>
<li>입력값 검증 / 보안 (Validation, Sanitation)</li>
<li>템플릿 엔진</li>
</ul>
<p><strong>3. 목적</strong>: Microframework는 작은 API 서버를 제작하는게 목적이다.</p>
<p>정리하자면 Microframework는 기능의 다양성이나 설계의 편리성보다 기능의 단순성이 더 우선된 프레임워크이다.</p>
<p>따라서 규모 있게 Monolith로 제작하는 경우 full-fledged framework를 사용하는 게 맞다고 본다. 실제로 Walamrt는 Node.js 기반으로 백엔드를 구성했지만 Commerce 기업이라 Hapi.js(full-fledged framework)를 직접 만들어서 사용하기도 하고 말이다. </p>
<hr>
<h4 id="Microframework의-종류"><a href="#Microframework의-종류" class="headerlink" title="Microframework의 종류"></a><strong>Microframework의 종류</strong></h4><p>아래는 주요 언어의 Microframework의 목록의 일부다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Express.js">Express.js</a> for Node.js</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Flask_(web_framework)">Flask</a> for Python</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sinatra_(software)">Sinatra</a> for Ruby</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spark_(software)">Spark</a> for Java (NOT Apache Spark)</li>
</ul>
<p>(더 많은 목록은 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microframework">위키 백과 Microframework 문서 (EN)</a>를 참고 바람.)</p>
<p>예상한 대로 <a target="_blank" rel="noopener" href="http://expressjs.com/">Express.js</a>도 microframework로 등재돼있다. Express 소개문에 “<em>Fast, unopinionated, <u>minimalist</u> web framework for Node.js</em>“ 라고 괜히 되어 있는 것이 아니다.</p>
<p>Netflix에서는 Restify라는 프레임워크를 예전부터 사용 중인데, <a target="_blank" rel="noopener" href="https://stackshare.io/restify">Restify도 Microframework이다</a>. Restify는 Semantically correct RESTful 을 지향한다. 온전히 REST API를 위한 기능만 제공하므로 Express 등에서 제공하는 템플릿 엔진 조차 없는데 기능의 단순함 측면에서 더 매력적이라고 할 수 있다. Restify는 또한 Connect 미들웨어를 지원하므로 Express 미들웨어와 호환된다.</p>
<p>아래는 <a target="_blank" rel="noopener" href="https://restify.com/">Restify 공식 홈페이지</a>에 나와있는 소개이다.</p>
<blockquote>
<p>Meet Restify - A Node.js web service framework optimized for building semantically correct RESTful web services ready for production use at scale. restify optimizes for introspection and performance, and is used in some of the largest Node.js deployments on Earth.</p>
</blockquote>
<hr>
<h3 id="Microframework가-Microservices에-좋을까"><a href="#Microframework가-Microservices에-좋을까" class="headerlink" title="Microframework가 Microservices에 좋을까?"></a><strong>Microframework가 Microservices에 좋을까?</strong></h3><blockquote>
<p> 아직 MSA에 대해 공부한 적 없기도 하고 이런 지식들이 쉬운 편이 아니라 좀 배워야 키워드 검색이 가능하기 때문에 Youtube와 여러 글들을 읽어보면서 느낀 점을 적으려 한다.</p>
</blockquote>
<p>왜 restify를 사용하는지 추측해보자면 굉장히 많은 컨테이너에서 돌아가는 MSA를 구축할 때 작은 서비스가 유리하기 때문이 아닐까?  Netflix는 (다른 기업들이 응당 그러하듯) MSA로 개발할 때 기능 단위로 분리하는데, Monolithic Service에 들어갈 많은 기능들이 기본 제공되지 않는 프레임워크가 <u>가벼워지는데</u> 유리한 것이다. (Netflix는 의사 결정 시 성능에 우선순위를 두는 듯 하다. 13년도에 Java에서 Node.js로의 이주를 시작한 것만 봐도.)</p>
<hr>
<h3 id="Node-js를-쓰는-대부분의-use-case가-microframework가-필요해서일까"><a href="#Node-js를-쓰는-대부분의-use-case가-microframework가-필요해서일까" class="headerlink" title="Node.js를 쓰는 대부분의 use case가 microframework가 필요해서일까?"></a><strong>Node.js를 쓰는 대부분의 use case가 microframework가 필요해서일까?</strong></h3><p><a href="https://jsqna.com/ejs-1-why-express/">이전 글</a> 내용 중 다운로드 수를 비교한 자료가 있었는데 Express가 압도적이었다. 같은 microframework이며 <a target="_blank" rel="noopener" href="https://www.fastify.io/benchmarks/">벤치마크(hello world)도 더 우수한</a> Koa가 그렇게 많이 사용되지 않는 점(약 21배 차이)은 이전 글에서도 다뤘듯 async/await 문법의 지원과 커뮤니티의 차이 때문임으로 보인다. </p>
<blockquote>
<p>다운로드 수에 대한 요즘 생각:</p>
<ol>
<li><p>러닝 커브. 많은 사람들이 Javascript가 배우기 쉽다고 말하며 그렇게 진입하는 사람이 적지 않다. 그저 React.js와 Express.js를 기초적인 수준에서 사용하는데 머무는 사람들이 정말 많다고 생각한다.</p>
</li>
<li><p>Netflix처럼 애초에 Managed로 환경 구성이 잘 된 경우라면 npm에서 다운로드 수 집계가 제대로 되지 않을 것 같다. (Proxy를 통한 캐싱 등) 즉 npm 다운로드가 현업 개발 시의 실제 사용 빈도를 정확히 나타내는 것도 아닐 수 있을 것이다.</p>
</li>
</ol>
<p>따라서 단순히 npm 다운로드 수로 비교하는 것보단 실제로 돈을 벌고 많은 트래픽을 처리하는 기업에서 무슨 스택을 사용하는지가 더 중요할 것으로 보인다.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Hapi</th>
<th align="left">Koa</th>
<th align="left">Nest</th>
<th align="left">Express</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://jsqna.com/images/ejs-1/hapi.png"><img src="https://jsqna.com/images/ejs-1/hapi.png" alt="img"></a></td>
<td align="left"><a href="https://jsqna.com/images/ejs-1/koa.png"><img src="https://jsqna.com/images/ejs-1/koa.png" alt="img"></a></td>
<td align="left"><a href="https://jsqna.com/images/ejs-1/nest.png"><img src="https://jsqna.com/images/ejs-1/nest.png" alt="img"></a></td>
<td align="left"><a href="https://jsqna.com/images/ejs-1/express.png"><img src="https://jsqna.com/images/ejs-1/express.png" alt="img"></a></td>
</tr>
</tbody></table>
<p>(참고로 restify는 12만, fastify는 19만 정도 된다. - fastify의 경우 Nest.js에서 사용되는 면이 있으니 참고)</p>
<hr>
<h4 id="다운로드-수를-유일한-척도로-삼고-맹신해서는-안-될-것-같다"><a href="#다운로드-수를-유일한-척도로-삼고-맹신해서는-안-될-것-같다" class="headerlink" title="다운로드 수를 유일한 척도로 삼고 맹신해서는 안 될 것 같다."></a><strong>다운로드 수를 유일한 척도로 삼고 맹신해서는 안 될 것 같다.</strong></h4><p>Express의 점유율이 매우 높다는 것을 microframework를 사용하는 숫자가 Node.js 백엔드 개발자 중에서 대다수라고 받아들이면 안 될 듯하다. Netflix의 경우는 MSA를 도입했기 때문이지만 트래픽이 많지 않은 기업들의 경우 아직 Monolithic이거나 작은 규모의 분산 시스템이면 충분할 거라고 생각하기 때문이다.</p>
<p>Node.js의 경우 … </p>
<ul>
<li>Javascript를 프론트엔드와의 공용어로 사용할 수 있다는 점</li>
<li>SSR 시 코드 재사용이 가능하다는 점</li>
<li>백엔드 언어와 Javascript 간의 Context Switching이 사라진다는 점</li>
<li>Interpreter 언어여서 Startup이 매우 빠르다는 점</li>
<li>모듈 생태계가 크다는 점이 장점</li>
</ul>
<p>이런 장점 속에서 굳이 프레임워크에서 가치를 찾지 않으려는 경우도 많지 않을까?</p>
<p>다운로드 수가 많다고 해서 Express를 사용할 이유는 없다. 1편에서도 밝혔듯이 Javascript와 Node.js의 장점 자체도 이미 많으며 Express에서 조금 고생하면서 Monolithic 서비스 개발하는 것은 점진적으로 러닝 커브가 올라가는 형태라고 생각하고, 딱 그 정도 수준이 필요한 기업도 많을 거라고 생각한다.</p>
<h3 id="아직-결론은-내릴-수-없을-것-같다"><a href="#아직-결론은-내릴-수-없을-것-같다" class="headerlink" title="아직 결론은 내릴 수 없을 것 같다."></a><strong>아직 결론은 내릴 수 없을 것 같다.</strong></h3><p>아직 Node.js의 정수를 다 배우지 못 했기 때문에, 아직 MSA를 배우지 못 했기 때문에 정확한 판단을 내릴 수가 없다. 이것들을 어느 정도 습득하고 나서 정말 왜 Express가, Express만이 이렇게 잘 팔리는 이유를 분석할 수 있으면 좋겠다.</p>
<hr>
<h3 id="What-I-Learned"><a href="#What-I-Learned" class="headerlink" title="What I Learned"></a><strong>What I Learned</strong></h3><ol>
<li><p>Netflix는 <a target="_blank" rel="noopener" href="https://netflixtechblog.com/">기술 블로그</a>와 컨퍼런스를 통해 정말 많은 기술적인 내용들을 공유한다는 걸 오늘 리서치하면서 배웠다. Youtube의 경우 여러 채널에 Video가 산재돼있는데 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=CZ3wIuvmHeM&list=PLqXBqaWzmb_c0d3jHhxk8cF0ldP6EGfvL">이 Playlist</a>가 좋은 것 같다.</p>
</li>
<li><p>아직도 Node.js 생태계에 대해 제대로 이해하지 못 하고 있다는 점을 또 알게됐다. 아직 해결되지 못한 질문들에 대해 데이터를 찾아서 반드시 답을 내리고 싶다.</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-01T09:00:00.000Z" title="2021-02-01T09:00:00.000Z">21-02-01</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-03T11:53:48.260Z" title="2021-03-03T11:53:48.260Z">21-03-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">12분안에 읽기 (약 1828 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-5-stream-1/">5장 Stream API (1/3) - 스트림 개요 및 Readable Stream</a></h1><div class="content"><p>이 글은 Node.js 디자인 패턴 CH 05 스트림 코딩의 일부를 참고해서 작성하였다. 이번 글은 Stream API에 대해 깊이 다루기보다 스트림 자체에 대해 다룬다.</p>
<hr>
<h3 id="스트림-개요"><a href="#스트림-개요" class="headerlink" title="스트림 개요"></a><strong>스트림 개요</strong></h3><p>스트림은 파일을 버퍼 단위로 옮겨서 전부 옮길 때까지 기다린 후 처리하기보다 매 버퍼 단위로 전송하는 방식이다.</p>
<p>스트림은 본질적으로 비동기 패러다임으로, <u>기다린 후</u> 처리하는 Sync 방식에 대비된다. 물론 <code>fs.readFile</code> 역시 Node.js 런타임에서 I/O를 처리해주니 스레드가 Block 되진 않겠지만, 애초에 <u>I/O 수준에서도 기다릴 일이 없게</u> 하는 것이 처리량에서 우위이지 않을까? </p>
<p>(처리량에서 정말 우위일지는 잘 모르겠다. 스트리밍 오버헤드에 대해 공부해본 적이 없기 때문.)</p>
<h3 id="스트림의-공간-효율성"><a href="#스트림의-공간-효율성" class="headerlink" title="스트림의 공간 효율성"></a><strong>스트림의 공간 효율성</strong></h3><p>스트림은 메모리에 파일의 전체 내용을 올리지 않고 버퍼의 크기만큼만 메모리를 할당하기 때문에 공간 효율적이다. 더 좋은 점은 <u>파일의 크기에 상관 없이</u> 일정한 양의 메모리를 점유한다는 점이다.</p>
<blockquote>
<p>이것과 별개로 V8 엔진은 32bit 기준 ~1GB, 64bit 기준 ~1.7GB 정도의 메모리만 사용하도록 설정돼있어(더 높이려면 빌드해야 함.) 파일이 큰 경우 전체 파일을 한 번에 메모리에 올릴 수 없음.</p>
</blockquote>
<hr>
<p>공간 비효율적인 파일 압축 코드 (ex: example.tar -&gt; example.tar.gz)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">fs.readFile(file, <span class="function">(<span class="params">err, buffer</span>) =&gt;</span> &#123;</span><br><span class="line">  zlib.gzip(buffer, <span class="function">(<span class="params">err, buffer</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.writeFile(file + <span class="string">&#x27;.gz&#x27;</span>, buffer, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;File successfully compressed&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>공간 효율적인 파일 압축 코드 (Stream API)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파일을 읽는데에 buffer 크기만큼만 메모리를 점유하기 때문에 공간 효율적</span></span><br><span class="line"><span class="comment">// pipe 체이닝으로 각 chunk에 대해 이런 저런 처리를 할 수 있음.</span></span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(fs.createWriteStream(file + <span class="string">&#x27;.gz&#x27;</span>))</span><br><span class="line">  .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;File successfully compressed&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>참고로 gzip이 어떻게 스트림에 대해 동작하는지 궁금하다면 아래 글들을 참고해보면 좋을 것 같다.</p>
<p><a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/393834/how-is-it-possible-to-gzip-a-stream-before-the-entire-contents-are-known">How is it possible to GZIP a stream before the entire contents are known? | StackOverFlow</a> </p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19700503/how-does-gzip-compression-rate-change-when-streaming-data">How does gzip compression rate change when streaming data? | StackOverFlow</a></p>
<hr>
<h3 id="스트림의-시간-효율성"><a href="#스트림의-시간-효율성" class="headerlink" title="스트림의 시간 효율성"></a><strong>스트림의 시간 효율성</strong></h3><p>Stream은 TTFB(Time to First Byte)에 강점이 있는데, TTFB는 파일의 크기에 비례하여 빠를 수 밖에 없다. 파일의 크기가 클 수록 읽는 데 대기시간이 필요하지만 Stream은 곧바로 응답을 보내기 시작하기 때문이다.</p>
<blockquote>
<p>웹에서 TTFB는 매우 중요하다.</p>
<p>자세한 건 <a target="_blank" rel="noopener" href="https://github.com/vercel/next.js/issues/1209">Next.js의 재밌는 이슈(Stream rendering to reduce TTFB and CPU load)</a> 참고.</p>
</blockquote>
<h4 id="파일을-단위로-전송하는-Server-Client-모델"><a href="#파일을-단위로-전송하는-Server-Client-모델" class="headerlink" title="파일을 단위로 전송하는 Server-Client 모델"></a><strong>파일을 단위로 전송하는 Server-Client 모델</strong></h4><p>다음의 사이클을 단 1회 거치게 된다: read &gt; compress &gt; send &gt; receive &gt; decompress &gt; write</p>
<hr>
<h4 id="chunk-단위로-전송하는-Server-Client-모델"><a href="#chunk-단위로-전송하는-Server-Client-모델" class="headerlink" title="chunk 단위로 전송하는 Server-Client 모델"></a><strong>chunk 단위로 전송하는 Server-Client 모델</strong></h4><p>위의 사이클을 매 chunk마다 거치게 되므로 파이프라이닝과 같은 형태로 병렬 처리가 가능하다. 물론 chunk의 크기마다 다르겠지만 각 단계를 거치는 만큼 오버헤드가 있을 것이다. (HTTP header 등. 이 부분에 대해선 잘 알지 못한다.)</p>
<blockquote>
<p> Node.js 동시성을 활용하는 것이므로 순서를 맞춰줘야 하는데 Stream API가 알아서 처리한다고 한다. </p>
</blockquote>
<hr>
<p>아래는 파일을 전송하는 스트림 예제 코드이다.</p>
<p><strong>client</strong>: 파일을 받아 디스크에 쓰는 역할</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = req.headers.filename;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;File request received: &#x27;</span> + filename);</span><br><span class="line">  req</span><br><span class="line">    .pipe(zlib.createGunzip())</span><br><span class="line">    .pipe(fs.createWriteStream(filename))</span><br><span class="line">    .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span> <span class="comment">/* CREATED */</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">      res.end(<span class="string">&#x27;That\&#x27;s it\n&#x27;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;filename&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Listening&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>server</strong>: 파일을 읽고 전송하는 역할</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> server = process.argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  hostname: server,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    filename: path.basename(file),</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/octet-stream&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Encoding&#x27;</span>: <span class="string">&#x27;gzip&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = http.request(options, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server response: &#x27;</span> + res.statusCode);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;File successfully sent&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="스트림의-문제-해결력"><a href="#스트림의-문제-해결력" class="headerlink" title="스트림의 문제 해결력"></a><strong>스트림의 문제 해결력</strong></h3><p>스트림은 Composition으로 문제 해결을 한다. Express Middleware와 같이 마음껏 파이프라인을 만들어낼 수 있다. </p>
<ul>
<li>파이프라인은 각 기능 간에 결합이 없기 때문에 항상 1차원으로 코드가 <u>표현</u>된다. (분기가 없다는 게 아니라 가독성이 좋다는 것.)</li>
<li>선언형으로 프로그래밍하기 수월하다. 선언형 패러다임은 코드를 요약해서 바라볼 수 있기 때문에 쉽게 이해하기 좋다.</li>
</ul>
<blockquote>
<p>스트림을 기반으로 비동기 이벤트를 처리하는 패러다임을 Reactive라고 하고 이를 위한 RxJS가 있다.</p>
</blockquote>
<p>(ex) 암호화 기능 추가</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 복호화</span></span><br><span class="line">.pipe(crypto.createDecipheriv(<span class="string">&quot;aes-192-gcm&quot;</span>, <span class="string">&quot;a_shared_secret&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 암호화</span></span><br><span class="line">.pipe(crypto.createCipheriv(<span class="string">&quot;aes-192-gcm&quot;</span>, <span class="string">&quot;a_shared_secret&quot;</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Node-js에서-지원하는-스트림"><a href="#Node-js에서-지원하는-스트림" class="headerlink" title="Node.js에서 지원하는 스트림"></a><strong>Node.js에서 지원하는 스트림</strong></h3><p>Node.js가 지원하는 스트림은 EventEmitter 객체를 상속하며 binary, 문자열 뿐만 아니라 거의 모든 Javascript의 값을 읽을 수 있다. 이러한 스트림에는 크게 네 종류가 있는데 이번 글에서는 (글이 길어지는 관계로) Readable만 다룬다.</p>
<ul>
<li>Readable, Writable, Duplex, Transform</li>
</ul>
<hr>
<h4 id="1-Readable"><a href="#1-Readable" class="headerlink" title="1. Readable"></a><strong>1. Readable</strong></h4><p>Readable 스트림은 외부에서 읽기 위한 스트림으로, 자신이 가진 값을 chunk로 써서 내보내는 역할이다. </p>
<blockquote>
<p>사용 예:</p>
<p><code>readable</code> 이벤트에 listener를 등록하고 이벤트 발생 시 버퍼에 있는 내용을 모두 읽기</p>
</blockquote>
<blockquote>
<p>API로는 아래의 함수가 있다.</p>
<p><code>readable.read([size]) // read는 동기 함수이다.</code></p>
</blockquote>
<p>(ex) 표준 입력(stdin) 받아서 표준 출력(<code>console.log</code>, <code>stdout.write</code>)하기</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">&#x27;readable&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;New data available&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Chunk read: (<span class="subst">$&#123;chunk.length&#125;</span>) &quot;<span class="subst">$&#123;chunk.toString()&#125;</span>&quot;`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> process.stdout.write(<span class="string">&#x27;End of stream&#x27;</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Stream v1, v2에 따라 non-flowing mode, flowing mode 로 나뉘는데 어차피 v1은 사용되지 않으므로 설명을 생략한다.</p>
</blockquote>
<hr>
<h4 id="ReadableStream을-하나-새로-만드는-예제"><a href="#ReadableStream을-하나-새로-만드는-예제" class="headerlink" title="ReadableStream을 하나 새로 만드는 예제"></a><strong>ReadableStream을 하나 새로 만드는 예제</strong></h4><p>지금까지는 <code>fs</code>, <code>http</code>의 스트림을 그대로 사용했지만 직접 ReadableStream을 만들어 활용할 수도 있다. </p>
<p><code>stream.Readable</code>을 상속해 abstract function인 <code>_read([size])</code>(public 인터페이스인 <code>read</code>와 헷갈리면 안 된다)를 구현하면 ReadableStream 객체를 하나 만들 수 있다.</p>
<p>구현을 위해 <code>push(data[, encoding])</code> 함수를 호출해 내부 버퍼에 값을 쓸 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Chance = <span class="built_in">require</span>(<span class="string">&#x27;chance&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1] 생성</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_read</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Pushing chunk of size: <span class="subst">$&#123;chunk.length&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">this</span>.push(chunk, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123; </span><br><span class="line">      <span class="built_in">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2] 사용</span></span><br><span class="line"><span class="keyword">const</span> RandomStream = <span class="built_in">require</span>(<span class="string">&#x27;./randomStream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> RandomStream();</span><br><span class="line"></span><br><span class="line">randomStream.on(<span class="string">&#x27;readable&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> chunk;</span><br><span class="line">  <span class="keyword">while</span>((chunk = randomStream.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received: <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>나머지 스트림 종류 다루기</p>
<p>백 프래셔</p>
<p>스트림 기반 비동기 제어</p>
<p>Pipe Composition</p>
<p>멀티 플렉싱, 디멀티 플렉싱</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-28T06:05:00.000Z" title="2021-01-28T06:05:00.000Z">21-01-28</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-28T06:06:43.740Z" title="2021-01-28T06:06:43.740Z">21-01-28</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a><span> / </span><a class="link-muted" href="/categories/Frontend/React-js/">React.js</a></span><span class="level-item">14분안에 읽기 (약 2159 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/atomic-design-1/">Atomic Design - 1 Intro</a></h1><div class="content"><p>이 글은 Atomic Design의 목적과 활용에 대해 간단하게 다룬다. 이후 시리즈에서는 실제 적용 예시를 다루고자 한다.</p>
<hr>
<h3 id="목적"><a href="#목적" class="headerlink" title="목적"></a><strong>목적</strong></h3><p>현대 프론트엔드는 두 가지 복잡성을 맞이했는데, Atomic Design은 이 문제를 해결하는데 효과적이다.</p>
<ul>
<li><p>이전에 비해 다양한 해상도를 지원해야 함.</p>
</li>
<li><p>UI 컴포넌트의 종류가 다양해지고 복잡해짐. 많은 상태를 갖게 됨.</p>
</li>
</ul>
<hr>
<p>즉 유지보수 비용이 크게 늘어난 상태이다. 소프트웨어 개발에서 복잡성을 낮추는 방식은 분할 정복과 의존성 격리를 통한 SRP 만족인데, Atomic Design은 프론트엔드의 구성 요소를 디자인 수준에서 분할하므로, 개발자는 이를 재사용하여 총 개발 비용을 낮출 수 있다.</p>
<p>기존에도 HTML, CSS 수준에서 컴포넌트 개발이 어느 정도 가능했으나 React.js의 등장 후 CSS-in-JS 라는 생태계가 조성된 덕분에 컴포넌트 개념의 완전한 구현이 가능해졌기 때문에 Atomic Design이 더 많이 언급되고 활용되는 듯하다.</p>
<hr>
<p>현대에는 <a target="_blank" rel="noopener" href="https://uxdesign.cc/everything-you-need-to-know-about-design-systems-54b109851969">디자인 시스템 (EN)</a>을 사용하는 것이 일반적인데, 디자인 시스템이란 브랜딩 디자인, 컴포넌트를 위한 스타일 가이드, 컴포넌트 등으로 구성된 디자인 &amp; 추상적인 개념의 집합이다. </p>
<p>이런 디자인 시스템의 Typo, Spacing 등을 포함해 컴포넌트를 라이브러리로 개발해놓으면, 전사적으로 디자인이 통일성을 갖게 되기도 하고 개발 측면에선 이미 개발된 디자인 요소를 빠르게 선언적으로 활용할 수 있기 때문에 생산성에 많이 유리하다. </p>
<ul>
<li>이미 널리 알려진 디자인 시스템의 라이브러리 또한 많다. 아무래도 Material Design의 구현체인 <a target="_blank" rel="noopener" href="https://material-ui.com/">Material-UI</a>가 가장 유명할 것이다.</li>
</ul>
<hr>
<p>Atomic Design의 접근 방식은 디자인 시스템을 구축하는 데 효과적이므로 많이 사용된다. 이후에 Atomic Design이 어떻게 개발 과정에서 유용하게 사용되는지 설명한다.</p>
<h3 id="이론"><a href="#이론" class="headerlink" title="이론"></a><strong>이론</strong></h3><p>가장 큰 개념으로 페이지, 컴포넌트가 있다. 컴포넌트가 조합돼 페이지를 구성하는 형태이다.</p>
<p>컴포넌트는 조합되므로 재사용된다. 즉 효율적이며 페이지 간 일관성 또한 보장된다.</p>
<p>컴포넌트는 아래의 4개의 하위 요소로 나뉜다. (작은 순으로 정렬)</p>
<ul>
<li>원자 (Atom)</li>
<li>분자 (Molecule)</li>
<li>유기체 (Organism)</li>
<li>템플릿 (Template)</li>
</ul>
<hr>
<h4 id="원자-Atom"><a href="#원자-Atom" class="headerlink" title="원자 (Atom)"></a><strong>원자 (Atom)</strong></h4><p>더 분해할 수 없는 가장 작은 요소이다. 아주 작은 기능도 Atom의 조합으로 만들어지는, 콘텐츠로서의 구체성은 없다.</p>
<p>(ex) 검색 폼: { <u>검색 Text, 검색 Input 바, 전송 버튼</u> } 이라는 Atom의 조합으로 생성 (여기서 어떻게 조합하는지는 또 별개의 정보.)</p>
<p>종류:</p>
<ul>
<li>버튼</li>
<li>텍스트 인풋, 색 팔레트, …</li>
<li>타이포그래피, 제목 (h1, h2, h3, …)</li>
<li>아이콘</li>
<li>체크박스, 라디오 버튼</li>
</ul>
<hr>
<h4 id="분자-Molecule"><a href="#분자-Molecule" class="headerlink" title="분자 (Molecule)"></a><strong>분자 (Molecule)</strong></h4><p>분자는 원자들의 조합을 그 단위로 한다. 분자부터 콘텐츠로서의 구체성이 있다.</p>
<p>(ex) <u>검색 폼</u>: { 검색 Text, 검색 Input 바, 전송 버튼 } 이라는 구체적인 목적이 있는 요소.</p>
<p>분자는 원자들의 조합이지만 계속해서 재사용성이 유지해야 한다.</p>
<p>(ex) 검색 폼은 여러 페이지에서 사용됨.</p>
<p>아무래도 재사용성 유지를 위해 적은 수의 Atom을 조합하여 그 범용성을 높인다.</p>
<hr>
<h4 id="유기체-Organism"><a href="#유기체-Organism" class="headerlink" title="유기체 (Organism)"></a><strong>유기체 (Organism)</strong></h4><p>유기체는 분자 뿐만 아니라 원자까지 조합해 만들어진다.</p>
<p>유기체부터는 재사용이 강제되지 않는다. 즉 분자와 유기체의 차이는 재사용성이라고 생각할 수 있다.</p>
<p>(ex) Header, Footer 컴포넌트</p>
<p>유기체는 Container의 형태를 띄기도 한다. (ex) ProductList (ProductListItem의 배치 역할)</p>
<p>아무래도 이런 List 컴포넌트는 재사용하기 어렵기 때문에 유기체로 분류되는 것이 일반적이다.</p>
<blockquote>
<p>몇 개의 Organism을 배치하면 하나의 페이지가 완성된다고 하는데 잘 모르겠다.</p>
</blockquote>
<hr>
<h4 id="템플릿-Template"><a href="#템플릿-Template" class="headerlink" title="템플릿 (Template)"></a><strong>템플릿 (Template)</strong></h4><p>하위 컴포넌트들의 배치가 목적인 컴포넌트로, 페이지 구조나 레이아웃 구성을 담당한다.</p>
<p>하위 컴포넌트는 자신의 형태만 다룰 뿐 자신이 어떻게 배치될 지에 대해 책임지지 않는데, 템플릿은 이러한 컴포넌트들을 어떻게 배치시키고 표현할 것인지 결정한다.</p>
<blockquote>
<p>약간 <code>UI = render(state)</code> 느낌이기도 하다.</p>
</blockquote>
<hr>
<h4 id="페이지-Page"><a href="#페이지-Page" class="headerlink" title="페이지 (Page)"></a><strong>페이지 (Page)</strong></h4><p>페이지는 템플릿에 예제/실제 데이터가 들어간 상태를 말한다. (ex) Mockup</p>
<p>템플릿에 데이터를 주고 초기화한 인스턴스라고 생각해도 좋다.</p>
<hr>
<h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a><strong>장점</strong></h3><p>Atomic Design은 디자이너도 함께 실행해야 하는 것이지만 개발자 측면에서의 장점만 나열하겠다.</p>
<h4 id="1-원활한-의사소통"><a href="#1-원활한-의사소통" class="headerlink" title="1. 원활한 의사소통"></a><strong>1. 원활한 의사소통</strong></h4><p>컴포넌트 단위로 나누는 것은 그 단위가 미리 정의가 돼야 하며 모두가 동의해야 한다. 그러한 단위를 굳이 Atomic Design이 주장하는 바대로 따를 필요는 없지만 의사 소통 이전에 미리 정의돼야함은 변함이 없다. 이 때 Atomic Design은 이런 단위를 미리 정의해서 제공한다.</p>
<p>충분히 납득할만한 수준으로 잘 정의됐으며 이미 널리 알려져 있기 때문에 사용할 가치가 높다고 생각한다.</p>
<h4 id="2-의존성-분리"><a href="#2-의존성-분리" class="headerlink" title="2. 의존성 분리"></a><strong>2. 의존성 분리</strong></h4><p>Atomic Design에 부합하도록 각 요소를 잘 분리한다면 아래와 같은 실익을 얻을 수 있다.</p>
<ul>
<li>개발 과정을 병렬로 진행할 수 있고</li>
<li>각 요소가 변경되더라도 변경되는 요소를 최소한으로 줄일 수 있음</li>
</ul>
<h4 id="3-작은-컴포넌트"><a href="#3-작은-컴포넌트" class="headerlink" title="3. 작은 컴포넌트"></a><strong>3. 작은 컴포넌트</strong></h4><p>Atomic Design의 각 단위에 맞게 하나의 역할을 하는 컴포넌트로 개발하면 각 컴포넌트를 작게 유지할 수 있다. 덕분에 그 개수가 늘어나도 변경에 의한 변경을 최소화할 수 있으며 따라서 복잡성이 지수적으로 올라가기보다 선형적으로 증가할 것이다. 뭐든 작게 유지하는 것은 key to computer science 이고 UNIX 철학에도 들어맞는다. </p>
<blockquote>
<p>Make each program do one thing well.</p>
</blockquote>
<hr>
<h3 id="주의점"><a href="#주의점" class="headerlink" title="주의점"></a><strong>주의점</strong></h3><h4 id="1-재사용을-위한-반응형-디자인"><a href="#1-재사용을-위한-반응형-디자인" class="headerlink" title="1. 재사용을 위한 반응형 디자인"></a><strong>1. 재사용을 위한 반응형 디자인</strong></h4><p>컴포넌트는 데이터에 따라 여러 상태를 가질 수 있고, 따라서 여러 해상도에서 표시될 수 있다. 컴포넌트가 여러 해상도를 지원하려면 가로 너비(width)가 변할 수 있게 개발해야 한다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* before */</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* after */</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-하위-컴포넌트에서-레이아웃-속성-최대한-피하기"><a href="#2-하위-컴포넌트에서-레이아웃-속성-최대한-피하기" class="headerlink" title="2. 하위 컴포넌트에서 레이아웃 속성 최대한 피하기"></a><strong>2. 하위 컴포넌트에서 레이아웃 속성 최대한 피하기</strong></h4><p>Atomic Design에서 컴포넌트를 배치하는 역할은 상위 컴포넌트의 역할이다. 배치란 위치를 결정하는 일이고 따라서 각 컴포넌트는 자신이 그려지는 바깥 범위의 레이아웃을 방해하면 안 된다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 여백은 배치(레이아웃) 속성이며 이렇게 스스로 값을 줘버리면 배치하는 입장에서 굳이 덮어써야 한다. */</span></span><br><span class="line"><span class="selector-class">.atom</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Atom을 조합하는 Molecule이 조합된 Atom을 알아서 배치하는 것이 적절하다. */</span></span><br><span class="line"><span class="selector-class">.molecule</span> <span class="selector-class">.atom</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-CSS3-Flexbox-GridBox-사용하기"><a href="#3-CSS3-Flexbox-GridBox-사용하기" class="headerlink" title="3. CSS3 Flexbox/GridBox 사용하기"></a><strong>3. CSS3 Flexbox/GridBox 사용하기</strong></h4><p>flex, grid 속성은 배치에 최적화된 속성이며 Organism의 경우 List 컴포넌트와 같이 Molecule을 배치하는 역할을 주로 하기 때문에 이 때 사용하는 것은 적절하다고 할 수 있다. </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.organism</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="실제-활용-예시"><a href="#실제-활용-예시" class="headerlink" title="실제 활용 예시"></a><strong>실제 활용 예시</strong></h3><p><a target="_blank" rel="noopener" href="https://velog.io/@thsoon/%EC%93%B8%EB%95%8C%EC%97%86%EC%9D%B4-%EA%B3%A0%ED%80%84%EC%9D%B8-%ED%88%AC%EB%91%90%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-FE-2.-%EB%B7%B0-%EC%84%A4%EA%B3%84">Atomic Design으로 Todo 만들기 (KR)</a></p>
<hr>
<p>출처: <a target="_blank" rel="noopener" href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=190038704">더 괜찮은 웹 개발자가 되기 위한 리액트 스타일 가이드 (Aladin)</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">이전</a></div><div class="pagination-next"><a href="/page/3/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-20T14:00:00.000Z">21-06-20</time></p><p class="title"><a href="/linux-system-log-1/">리눅스 - 시스템 로그와 로그인 로그</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-13T14:55:00.000Z">21-06-13</time></p><p class="title"><a href="/linux-sshd-logs/">리눅스 - ssh/sshd의 보안에 대해 (1/2)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-06T14:43:00.000Z">21-06-06</time></p><p class="title"><a href="/linux-ufw/">우분투의 SW 기반 방화벽 - UFW</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-30T14:35:00.000Z">21-05-30</time></p><p class="title"><a href="/linux-filesystem-ext/">리눅스 파일 시스템의 구조 - ext 계열</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-16T14:55:00.000Z">21-05-16</time></p><p class="title"><a href="/linux-namespaces-2/">Linux와 Docker의 기술적 관계 (2/3) - Network Namespace 기초</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
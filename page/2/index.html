<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-30T14:35:00.000Z" title="2021-05-30T14:35:00.000Z">21-05-30</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-30T14:34:58.590Z" title="2021-05-30T14:34:58.590Z">21-05-30</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">5분안에 읽기 (약 751 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-filesystem-ext/">리눅스 파일 시스템의 구조 - ext 계열</a></h1><div class="content"><p>이 글은 리눅스에서의 파일 시스템 중 ext 계열에 대해 설명한다.</p>
<hr>
<h3 id="1-ext2"><a href="#1-ext2" class="headerlink" title="1. ext2"></a><strong>1. ext2</strong></h3><p>ext2는 (ext를 개선한) 리눅스의 초기 파일 시스템이다. 개선된 버전인 ext3, ext4도 있으나, 많은 자료에서 ext2를 비중 있게 다루므로 이 글에서도 동일한 형태로 ext2를 위주로 서술한다.</p>
<hr>
<p><img src="https://i.stack.imgur.com/cP4XD.png" alt="ext disk layout"></p>
<hr>
<p>ext2는 디스크를 부트 섹터와 <strong>블록 그룹</strong>으로 분할한다. 블록 그룹이란, 일정한 크기의 블록의 집합을 의미한다. (정확히는 마지막 블록은 크기 제한에서 자유롭다.)</p>
<ul>
<li><p>파일 저장 시 동일한 블록 그룹 내에 저장하도록 스케줄링한다.</p>
</li>
<li><p>블록 그룹은 아래의 필드를 갖는다. 아래의 필드 중 Super Block, Group Descriptor Table은 하나만 있어도 충분하나 백업 용도로 각 블록 그룹에 사본으로 저장된다(일관성 유지에 대한 내용은 잘 모르겠다.)</p>
<table>
<thead>
<tr>
<th>필드명</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Super Block</td>
<td>1KB의 크기의 자료구조로, 블록의 크기, 총 블록의 개수, 블록 그룹의 개수, i-node의 개수, 그룹 내 블록의 개수, 그룹 내 i-node의 개수 등의 정보를 저장한다.</td>
</tr>
<tr>
<td>Group Descriptor Table</td>
<td>Group Descriptor의 <strong>테이블</strong>이다. 각 Descriptor는 Block Bitmap(아래 필드)의 블록 번호, 그룹 내의 빈 블록 개수, 그룹 내의 i-node 개수, 그룹 안의 빈 디렉토리 개수를 저장한다.</td>
</tr>
<tr>
<td>Block Bitmap</td>
<td>각 블록의 할당 여부를 bit(0,1)로 표시한다.</td>
</tr>
<tr>
<td>i-node Bitmap</td>
<td>i-node의 할당 여부를 bit로 표시한다.</td>
</tr>
<tr>
<td>i-node Table</td>
<td>아래의 i-node를 테이블 형태로 저장한다.</td>
</tr>
<tr>
<td>(actual) i-nodes</td>
<td>(위의 테이블 형태로 저장된 것이다.) 128Byte의 크기를 가지며, 실제 파일/디렉토리의 위치를 저장한다. 파일의 메타 데이터를 보관한다. 각 파일/디렉토리는 i-node와 1:1로 대응되며 i-node를 알고 있다면 i-node에 저장된 블록 그룹을 확인할 수 있다. (자세한 필드는 아래 표에서 확인바란다.)</td>
</tr>
<tr>
<td>(actual) blocks</td>
<td>실제로 데이터가 저장되는 블록이다.</td>
</tr>
</tbody></table>
</li>
<li><p>i-node를 구성하는 필드는 아래와 같다.</p>
<table>
<thead>
<tr>
<th>필드명</th>
</tr>
</thead>
<tbody><tr>
<td>Inode Number</td>
</tr>
<tr>
<td>파일 모드</td>
</tr>
<tr>
<td>하드 링크 개수</td>
</tr>
<tr>
<td>소유자 정보</td>
</tr>
<tr>
<td>파일 크기</td>
</tr>
<tr>
<td>마지막 접근/수정 시각</td>
</tr>
<tr>
<td>데이터 블록의 개수</td>
</tr>
<tr>
<td>직접 블록 (대부분의 작은 파일은 직접 블록으로도 커버가 충분히 된다.)</td>
</tr>
<tr>
<td>간접 블록 / 이중 간접 블록 / 삼중 간접 블록 (linked list 개념)</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="2-ext-2-vs-3-4"><a href="#2-ext-2-vs-3-4" class="headerlink" title="2. ext 2 vs 3,4"></a><strong>2. ext 2 vs 3,4</strong></h3><p>구조적으로 큰 차이보단 성능 개선 등에 초점이 맞춰져 있다.</p>
<table>
<thead>
<tr>
<th>features</th>
<th>ext2</th>
<th>ext3</th>
<th>ext4</th>
</tr>
</thead>
<tbody><tr>
<td>전원 문제 시 데이터 저장 손실 (저널링 파일 시스템 지원 여부)</td>
<td>문제 발생</td>
<td>저널링 지원됨</td>
<td>저널링 지원됨</td>
</tr>
<tr>
<td>파일 최대 크기</td>
<td>2TiB</td>
<td>2TiB</td>
<td>16TiB</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-16T14:55:00.000Z" title="2021-05-16T14:55:00.000Z">21-05-16</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-16T14:53:19.710Z" title="2021-05-16T14:53:19.710Z">21-05-16</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">6분안에 읽기 (약 841 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-namespaces-2/">Linux와 Docker의 기술적 관계 (2/3) - Network Namespace 기초</a></h1><div class="content"><p>출처: <a target="_blank" rel="noopener" href="https://www.44bits.io/ko/post/container-network-2-ip-command-and-network-namespace">ip로 직접 만들어보는 네트워크 네임스페이스와 브리지 네트워크</a></p>
<p>도커의 기반이 되는 네트워크 네임스페이스 기술에 대해 다룬다.</p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64) (Docker Desktop)</p>
<p>일부 기능은 Native Docker에서만 정상 작동하여 아래 환경도 활용하였다.<br>Ubuntu 20.04.1 LTS (GCP Compute Engine) (Native Docker)</p>
</blockquote>
<hr>
<h4 id="Network-Namepsace의-역할"><a href="#Network-Namepsace의-역할" class="headerlink" title="Network Namepsace의 역할"></a><strong>Network Namepsace의 역할</strong></h4><p>Network Namespace는 프로세스의 네트워크 환경을 분리한다. 기본적으로 프로세스의 네트워크 네임스페이스는 default 네임스페이스에 속한다.</p>
<hr>
<h4 id="Network-Namepsace-사용-방법"><a href="#Network-Namepsace-사용-방법" class="headerlink" title="Network Namepsace 사용 방법"></a><strong>Network Namepsace 사용 방법</strong></h4><p>아래에서 계속 사용하게 될 프로그램인 <strong>ip</strong>는 리눅스에서 네트워크를 관리하는 표준 유틸이며, 네트워크 네임스페이스 기능 또한 내장돼있다.</p>
<hr>
<p><code>ip link</code> : 네트워크 디바이스 목록 조회</p>
<p><img src="/images/linux-network-namespace/ip_link.png"></p>
<p>이 결과는 위에서 말했듯, default 네트워크 네임스페이스에 속한 네트워크 디바이스의 목록이 출력된 것이다.</p>
<hr>
<ol>
<li><p><code>ip netns add &#123;NAMESPACE_TITLE&#125;</code> : 새로운 네트워크 네임스페이스 생성</p>
</li>
<li><p><code>ip netns exec &#123;NAMESPACE_TITLE&#125; &#123;COMMAND&#125;</code> : 특정 네트워크 네임스페이스에서 특정 명렁 수행</p>
</li>
<li><p><code>ip link set dev ip netns exec &#123;DEVICE_TITLE&#125; &#123;up|down&#125;</code> : 특정 네트워크 디바이스를 Enable/Disable 하도록 설정</p>
</li>
</ol>
<hr>
<h4 id="Network-Namepsace의-독립성"><a href="#Network-Namepsace의-독립성" class="headerlink" title="Network Namepsace의 독립성"></a><strong>Network Namepsace의 독립성</strong></h4><p>위에서 소개한 명령으로 네트워크 네임스페이스(<code>direct_netns</code>라고 아래에선 사용했다.)를 하나 생성한 후, default 네임스페이스에서 접속을 시도하는 경우 잘 되지 않는다. 이는 네임스페이스 간의 연결이 격리돼있기 때문이다.</p>
<p>약간의 셋업 과정으로 네트워크 네임스페이스의 격리 기능을 체험할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns add direct_netns</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns ip link <span class="built_in">set</span> dev lo up</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns nginx -g <span class="string">&#x27;daemon off;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>위 커맨드를 통해 direct_netns 네임스페이스를 만들고, loopback 어댑터를 up 상태로 만들어주고, nginx를 실행하면 아래의 내용을 확인할 수 있다.</p>
<p>default 네트워크 네임스페이스에서는 curl 수행 시 접근할 수 없지만,</p>
<p><img src="/images/linux-network-namespace/ip_just_curl.png"></p>
<p>direct_netns 네트워크 네임스페이스에서는 curl 수행 시 정상 접근이 된다.</p>
<p><img src="/images/linux-network-namespace/ip_netns_curl.png"></p>
<p>당연히, <code>netstat -nat | grep LISTEN</code> 의 수행 결과도 다르다.</p>
<hr>
<h4 id="Network-Namepsace간의-연결"><a href="#Network-Namepsace간의-연결" class="headerlink" title="Network Namepsace간의 연결"></a><strong>Network Namepsace간의 연결</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># veth 생성 및 한 쪽(veth1)을 direct_netns로 이전</span></span><br><span class="line">ip link add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line">ip link <span class="built_in">set</span> veth1 netns direct_netns</span><br><span class="line"></span><br><span class="line"><span class="comment"># IP 할당</span></span><br><span class="line">ip a add 10.200.0.2/24 dev veth0</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns ip a add 10.200.0.3/24 dev veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Up 상태로 지정</span></span><br><span class="line">ip link <span class="built_in">set</span> dev veth0 up</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns ip link <span class="built_in">set</span> dev veth1 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping 수행 (정상 작동 확인)</span></span><br><span class="line">ping 10.200.0.3</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns ping 10.200.0.2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>veth(Virtual Ethernet Device)란 리눅스에서 사용하는 가상 네트워크 인터페이스를 의미하며, ip 명령어로 생성하는 것이 가능하다. 항상 쌍으로 만들어진다고 한다.</p>
</blockquote>
<p>위와 같은 형태로 두 네트워크를 이어 통신할 수 있게도 할 수 있다.</p>
<hr>
<p>TODO:</p>
<ul>
<li>브릿지 네트워크, NAT 등 소개</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-09T14:10:00.000Z" title="2021-05-09T14:10:00.000Z">21-05-09</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-09T14:02:32.368Z" title="2021-05-09T14:02:32.368Z">21-05-09</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">3분안에 읽기 (약 475 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-tmux/">tmux 사용법 정리</a></h1><div class="content"><p>tmux의 사용법을 알아본다. 그동안 너무 귀찮아서.. 여러 터미널이 필요할 때 그냥 여러 터미널을 사용했었는데, Ubuntu에 기본으로 내장돼있기도 하고 고수 분들이 기본으로 사용하시는 것들을 어깨 너머로 봤기 때문에 약간의 시간을 들여 학습했다. </p>
<hr>
<h4 id="1-네트워크-연결-보호-기능"><a href="#1-네트워크-연결-보호-기능" class="headerlink" title="1. 네트워크 연결 보호 기능"></a><strong>1. 네트워크 연결 보호 기능</strong></h4><p>ssh 연결과 터미널 화면의 생명주기가 별개이다.</p>
<p>터미널을 실수로 꺼도, ssh 연결은 백그라운드로 살아 있다.</p>
<ul>
<li>새 터미널을 열어서 <code>tmux at(tach)</code> 로 다시 세션에 붙을 수 있다.</li>
<li><code>tmux at -t 세션넘버</code>로 특정 세션을 종료할 수 있다.</li>
</ul>
<hr>
<h4 id="2-다중-화면-기능"><a href="#2-다중-화면-기능" class="headerlink" title="2. 다중 화면 기능"></a><strong>2. 다중 화면 기능</strong></h4><ul>
<li><p>Ctrl + b 를 통해 명령어 모드 활성</p>
</li>
<li><p>Ctrl + b 후 <code>&quot;</code>를 누르면 새 <strong>가로</strong> 패널 생성 (<code>%</code>를 누르면 <strong>세로</strong> 패널 생성)</p>
</li>
<li><p>Ctrl + b + <code>방향키</code>를 누르면 각 패널 전환</p>
</li>
<li><p>Ctrl + b + <code>z</code>를 누르면 현재 활성 패널을 전체화면으로 전환 (toggle)</p>
</li>
<li><p>Ctrl + b + <code>Alt + 방향키</code>를 누르면 현재 패널의 크기를 조절</p>
</li>
<li><p>Ctrl + b + <code>space</code>를 누르면 preset 패널 구성으로 배열함</p>
</li>
<li><p>Ctrl + b + <code>d</code>를 누르면 tmux에서 원래 터미널로 돌아옴. (<code>tmux ls</code>로 각 세션 넘버 확인을, <code>tmux</code>로 새 세션을 생성할 수도 있다.)</p>
</li>
<li><p>새 세션인지는 tmux의 상태바에서 <code>[0]</code>의 숫자를 확인하면 된다. (이 경우 0).</p>
</li>
<li><p>Ctrl + b + <code>x</code>로 현재 패널을 제거할 수 있다. (마지막 패널 제거 시 현재 tmux 세션이 종료된다.)</p>
</li>
</ul>
<hr>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h4><ol>
<li>셸 프로그래밍 기초 학습하기</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/zx">google/zx</a> 써보고 가이드 작성하기<ul>
<li>너무 좋은 것 같다. async/await에 딱 맞는 자체 선언형 API에 nodejs를 그대로 사용할 수 있다는 점이 너무 좋다.</li>
</ul>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-11T14:55:00.000Z" title="2021-04-11T14:55:00.000Z">21-04-11</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-16T12:05:12.880Z" title="2021-05-16T12:05:12.880Z">21-05-16</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">8분안에 읽기 (약 1220 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-namespaces-1/">Linux와 Docker의 기술적 관계 (1/3) - Namespace</a></h1><div class="content"><p>이 글은 리눅스의 Namespace 기능의 일부를 다룬다. 도커의 내용도 포함되겠으나 리눅스 자체의 기능에 주안점을 둔다. 우선 PID, UTS를 다루고, chroot에 대해서도 소개한다.</p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64) (Docker Desktop)</p>
<p>일부 기능은 Native Docker에서만 정상 작동하여 아래 환경도 활용하였다.<br>Ubuntu 20.04.1 LTS (GCP Compute Engine) (Native Docker)</p>
</blockquote>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.44bits.io/ko/keyword/linux-container">리눅스 컨테이너</a>는 리눅스 <strong>네임스페이스</strong>와 루트 파일 시스템 격리 등의 기능을 사용해 격리시킨 프로세스를 의미한다.</p>
</blockquote>
<h3 id="namespace라는-기술에-대해"><a href="#namespace라는-기술에-대해" class="headerlink" title="namespace라는 기술에 대해"></a><strong>namespace라는 기술에 대해</strong></h3><p><a target="_blank" rel="noopener" href="https://www.44bits.io/ko/keyword/linux-namespace">리눅스 네임스페이스(Linux Namespace)란?</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_namespaces">Namespace</a>는 한 개의 특정 프로세스에 대해 시스템 리소스를 논리적으로 격리하는 기능이다. 아래와 같이 여러 가지의 Namespace가 존재한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 cgroup -&gt; <span class="string">&#x27;cgroup:[4026531835]&#x27;</span> <span class="comment"># cgroup = control group = CPU,RAM,NET 할당</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 ipc -&gt; <span class="string">&#x27;ipc:[4026532188]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 06:41 mnt -&gt; <span class="string">&#x27;mnt:[4026532186]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 net -&gt; <span class="string">&#x27;net:[4026531992]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 pid -&gt; <span class="string">&#x27;pid:[4026532189]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 08:35 pid_for_children -&gt; <span class="string">&#x27;pid:[4026532189]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 user -&gt; <span class="string">&#x27;user:[4026531837]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 uts -&gt; <span class="string">&#x27;uts:[4026532187]&#x27;</span> <span class="comment"># uts=Unix Time-Sharing / Host, Domain name 할당</span></span><br></pre></td></tr></table></figure>
<p>Docker에서 사용하는 Namespace의 목록은 아래와 같다.</p>
<ul>
<li><code>ipc, mnt, net, pid, pid_for_children, uts</code></li>
</ul>
<h4 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a><strong>PID Namespace</strong></h4><ol>
<li><p>분리된 새로운 네임스페이스에서는 PID=1부터 시작하나, 기존 네임스페이스에서도 (다른 PID로) 해당 프로세스를 볼 수 있으며, 이는 PID=1부터 시작하지 않는다.</p>
</li>
<li><p><code>ls -alh /proc/&#123;PID&#125;/ns</code> - PID에 대응되는 프로세스가 속한 네임스페이스를 출력한다. (sym link 형태의 구성)</p>
</li>
</ol>
<ul>
<li><p>위의 결과는 같은 1번 프로세스에서 생성된 경우 모두 같은 값을 갖는다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ diff &lt;(ls -Al /proc/1/ns | awk <span class="string">&#x27;&#123; print $11 &#125;&#x27;</span>) \ </span><br><span class="line">&lt;(ls -Al /proc/&#123;임의의_프로세스ID&#125;/ns | awk <span class="string">&#x27;&#123; print $11 &#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>User namespace는 UID 0을 줘서 root  <strong>같아 보이는</strong> - 어느 정도 제한된 - 권한을 제공할 수 있다. User namespace는 initial이 있고, 매 생성마다 Parent-Child 구조를 갖는다.</p>
</li>
<li><p>PID namespace 격리를 위해선 격리된 디렉토리에서의 모든 의존성이 준비 돼야 한다. - 의존성? docker Image가 하는 일이 바로 그것이니, docker Image를 활용해 mount한 폴더를 활용할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ~</span><br><span class="line">$ docker <span class="built_in">export</span> ~ &gt; ~.tar</span><br><span class="line">$ tar xf ~</span><br><span class="line">$ sudo unshare -p -f --mount-proc chroot . ./image_extracted_dir /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo $$</span></span><br><span class="line">&gt; 1</span><br></pre></td></tr></table></figure></li>
<li><p><code>unshare</code> 명령어를 써서 PID를 격리해 1번 프로세스가 되는 예시:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ unshare -p -f --mount-proc chroot . /bin/sh</span><br><span class="line">&gt; <span class="built_in">echo</span> $$ : 1</span><br><span class="line"></span><br><span class="line">$ unshare -p /bin/sh</span><br><span class="line">&gt; <span class="built_in">echo</span> $$: 3481</span><br></pre></td></tr></table></figure></li>
<li><p>각종 옵션들 정리</p>
<ol>
<li><code>p</code>: <em>PID 네임스페이스는 분리가 되었을텐데</em> 로 짐작해보건데 PID 네임스페이스를 의미하는 듯하다.</li>
<li><code>f</code>: <code>--fork</code>의 의미로, <code>unshare</code>의 child process로 실행한다고 한다.</li>
<li><code>--mount-proc</code>: <code>/proc</code> 이 기본값이어서, 기존 proc과 격리될 수 없다. 위 명령어에선 현재 폴더(.)를 넘겼다. </li>
</ol>
<ul>
<li>man page에선 <em>The new proc filesystem is explicitly as private</em>라고 하는데, 여기서 <em>private</em>이 무슨 뜻인지 모르겠다. 그리고, <em>mount proc filesystem</em>한다는 표현도 무슨 뜻인지 잘 모르겠다.</li>
<li>shell이 지원하는 명령어가 아니라 바이너리를 실행하려고 하면 <code>2: Cannot fork</code>라고 뜬다. Why?</li>
</ul>
<ol start="4">
<li>Host Shell에서 <code>ps -ef</code>하면 unshare도 하나의 프로세스로 뜨고, <code>sudo kill -9 3481</code> 하면 unshare도 종료된다.</li>
<li>프로세스 3481 == 프로세스 1 (unshare도 단지 하나의 프로세스)</li>
<li><code>/proc</code> 이 기본 PID namepsace이고, <code>init</code> 프로세스(pid 1)에 의해 pid namespace가 다 동일하다.</li>
<li><code>unshare</code>로 다른 디렉토리에 PID namespace를 mount하면 그 때부터 pid namepsace 값이 다른 값으로 할당됨</li>
</ol>
</li>
</ol>
<h4 id="UTS-Namepsace"><a href="#UTS-Namepsace" class="headerlink" title="UTS Namepsace"></a><strong>UTS Namepsace</strong></h4><p>출처: <a target="_blank" rel="noopener" href="https://www.44bits.io/ko/post/container-network-1-uts-namespace">UTS 네임스페이스를 사용한 호스트네임 격리 - 컨테이너 네트워크 기초 1편</a></p>
<p>UTS Namespace는 호스트 네임을 분리한다. 딱 이것만 한다. 별로 기능은 없다.</p>
<p>docker는 컨테이너마다 컨테이너ID로 호스트네임을 부여한다. 이 기능을 구현하는 방법은 무엇일까? <code>nsenter</code>로 가능하다. <code>nsenter</code>는 unshare로 지정한 네임스페이스 정보를 기반으로 프로세스를 실행하는 프로그램이다.</p>
<ol>
<li><code>unshare --uts=/tmp/utsns1 hostname utsns1</code> 명령으로 utsns1로 새로운 namespace를 정의하고 실행할 수 있다.</li>
<li><code>/tmp/utsns1</code> 파일에 unshare 설정을 저장한 후, </li>
<li><code>nsenter --uts=/tmp/utsns1 hostname</code> 수행 시 utsns1를 출력할 수 있다.</li>
</ol>
<h4 id="Network-Namepsace"><a href="#Network-Namepsace" class="headerlink" title="Network Namepsace"></a><strong>Network Namepsace</strong></h4><p>Network Namespace는 프로세스의 네트워크 환경을 분리한다. 실제로 docker 컨테이너마다 네트워크 인터페이스와 IP가 부여된다.</p>
<ul>
<li>(2편에서 확인할 예정)</li>
</ul>
<hr>
<p>TODO:</p>
<ul>
<li>네트워크 부분 더 공부하기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-04T12:35:00.000Z" title="2021-04-04T12:35:00.000Z">21-04-04</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-04-11T15:01:06.260Z" title="2021-04-11T15:01:06.260Z">21-04-12</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">8분안에 읽기 (약 1135 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-user-and-sudo/">리눅스에서의 sudo와 권한 관리 (1)</a></h1><div class="content"><p>이 글은 리눅스에서 sudo를 소개하고, 권한 관리에 대해 생각해본다. 예시 중에서 사용자를 생성하는 방법 또한 다룬다.</p>
<p>참고 자료</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/Sudo">sudo | Wikipedia (KR)</a></li>
</ul>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64)</p>
</blockquote>
<hr>
<blockquote>
<p>su와 sudo는 약자이다. su는 “substitute user”, sudo는 “substitute user do”이다.</p>
</blockquote>
<h3 id="리눅스에서의-su-사용법과-사용자-생성"><a href="#리눅스에서의-su-사용법과-사용자-생성" class="headerlink" title="리눅스에서의 su 사용법과 사용자 생성"></a><strong>리눅스에서의 su 사용법과 사용자 생성</strong></h3><p>su는 현재 로그인된 사용자에서 다른 사용자로 로그인하는 것이다.</p>
<p>사용자 목록은 <code>cat /etc/passwd</code>로 볼 수 있다. (이름과 다르게 비밀번호가 나오진 않는다.) </p>
<p>각 사용자의 암호화된 비밀번호를 확인하려면 <code>cat /etc/shadow</code>를 확인하라.</p>
<p>어떤 암호화가 쓰였는지는 <code>cat /etc/pam.d/common-password</code>로 확인할 수 있다 - 기준 환경에서는 <code>sha-512</code>를 사용한다. (출처: <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/8229/what-methods-are-used-to-encrypt-passwords-in-etc-passwd-and-etc-shadow">What methods are used to encrypt passwords in /etc/passwd and /etc/shadow?</a>)</p>
<hr>
<p>재밌는 점은, 사용자가 직접 만든 계정이 아닌 경우 로그인할 수 없게 되있다는 점이다. (출처: <a target="_blank" rel="noopener" href="https://askubuntu.com/questions/426990/what-are-the-default-passwords-of-these-users-nobody-daemon-uucp-etc">What are the default passwords of these users: nobody, daemon, uucp, etc.?</a>)</p>
<p><img src="/images/linux-sudo/sudoer2.png" alt="모든 그룹의 이름만 출력한 경우"></p>
<p>만약 ‘사람이 사용하는 용도의’ 사용자 목록을 확인하려면, <code>cat /bin/bash /etc/passwd</code>로 확인할 수 있다.</p>
<p><img src="/images/linux-sudo/sudoer3.png" alt="시스템 계정 제외하고 출력"></p>
<hr>
<p>사용자를 추가해서, 해당 사용자로 로그인해보자.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd tmp <span class="comment"># tmp는 유저명이다. 나머지는 자동으로 생성해준다. (단, 비밀번호가 없는 상태이다.)</span></span><br><span class="line">sudo passwd tmp <span class="comment"># 로그인을 하려면 비밀번호를 설정해야 한다. passwd 명령어로 비밀번호를 지정할 수 있다.</span></span><br><span class="line">su tmp</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> <span class="comment"># bash가 사라져서, 현재 셸을 출력해봤다. 기본 셸은 dash인걸로 아는데, /bin/sh를 사용하고 있다.</span></span><br><span class="line">bash <span class="comment"># bash shell로 전환한다.</span></span><br></pre></td></tr></table></figure>
<p>이렇게 로그인하면 bash가 사라지고, sh가 셸로 사용된다. (<code>chsh</code>로 바꿀 수 있다.)</p>
<hr>
<h3 id="사용자가-sudo를-사용할-수-있게-만들기-sudo의-권한에-대하여"><a href="#사용자가-sudo를-사용할-수-있게-만들기-sudo의-권한에-대하여" class="headerlink" title="사용자가 sudo를 사용할 수 있게 만들기, sudo의 권한에 대하여"></a><strong>사용자가 sudo를 사용할 수 있게 만들기, sudo의 권한에 대하여</strong></h3><p>sudo는 특정 작업을 root 권한으로 수행할 수 있게 하는 명령어이다. 특정 사용자를 sudo 그룹에 추가하기만 하면 된다: <code>sudo usermod -aG sudo &#123;사용자명&#125;</code>. 이후 사용자는 sudo 명령어를 사용할 수 있게 된다.</p>
<hr>
<p><img src="/images/linux-sudo/sudoer1.png" alt="sudo 파일의 내용"></p>
<p>각 유저에 대한 권한은 <code>/etc/sudoers</code>에 있는데, 권한의 포멧이 있다: <code>%sudo ALL=(ALL:ALL) ALL</code> 이것인데, (출처: <a target="_blank" rel="noopener" href="https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file">How To Edit the Sudoers File</a>) </p>
<table>
<thead>
<tr>
<th>%sudo</th>
<th>ALL=</th>
<th>(ALL:</th>
<th>ALL)</th>
<th>ALL</th>
</tr>
</thead>
<tbody><tr>
<td>username 규칙</td>
<td>hostname 규칙</td>
<td>sudo로 로그인할 수 있는 사용자 목록</td>
<td>sudo로 로그인할 수 있는 그룹 목록</td>
<td>root 권한으로 사용할 수 있는 명령어</td>
</tr>
</tbody></table>
<p>지금 알고 있는 지식으로는 sudo 파일의 Best Practice를 소개는 어렵기 때문에 추후로 미루지만, 권한 제어를 폭 넓게 할 수 있도록 필드가 5개나 된다는 점은 확인할 수 있었다. (아직 한 번도 sudoer 설정을 만져본 적이 없다는 점은 좀 부끄럽기도 하다.)</p>
<hr>
<h3 id="sudo의-장점"><a href="#sudo의-장점" class="headerlink" title="sudo의 장점"></a><strong>sudo의 장점</strong></h3><p>출처: <a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/135352/best-practices-for-hardening-sudo">Best practices for hardening sudo?</a></p>
<ol>
<li><p>sudo는 Root Password 공유를 막는다.</p>
</li>
<li><p><code>syslog</code> 등의 명령을 통해, sudo를 사용하는 경우 원격 서버로 로그를 전송하게 해서 더 빠르게 침입을 알아낼 수 있다.</p>
</li>
<li><p>제대로 권한 설정만 한다면 Root 권한보다 많이 축소되므로 침입자가 모든 기록을 말소하지 못하게 할 수 있다. (온전한 root 권한을 탈취 당한 경우 아무 소용이 없게 된다.)</p>
</li>
</ol>
<blockquote>
<p>위 출처의 아래 답변에서 얻은 사실인데, <code>ssh_user</code> 그룹을 만들어 remote login만 가능하게 하면 공격자가 ssh credential을 탈취하더라도 sudo 명령을 활용할 수 없기 때문에 보안 상 더 안전하다고 한다. (굉장히 유용한 방법인 듯하다.)</p>
</blockquote>
<hr>
<p>TODO:</p>
<ul>
<li>프로덕션 배포용 서버에 적절한 sudoer 설정에 대해 찾아보기</li>
<li>sudo 등의 예시 외에도 리눅스 상에서 보안 관련한 기능과 설정들을 찾아보기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-28T14:58:00.000Z" title="2021-03-28T14:58:00.000Z">21-03-28</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-28T14:56:25.740Z" title="2021-03-28T14:56:25.740Z">21-03-28</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">9분안에 읽기 (약 1334 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-how-to-find-files/">리눅스에서 파일을 찾는 방법</a></h1><div class="content"><p>이 글은 리눅스 환경에서 파일을 찾는 방법을 정리한 글이다. <a target="_blank" rel="noopener" href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=131835745">리눅스 핵심 레퍼런스</a>를 참고하여 작성하였다.</p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64)</p>
</blockquote>
<hr>
<h3 id="파일을-찾는-명령의-종류"><a href="#파일을-찾는-명령의-종류" class="headerlink" title="파일을 찾는 명령의 종류"></a><strong>파일을 찾는 명령의 종류</strong></h3><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>find</td>
<td>파일, 디렉토리 검색 중 가장 많은 옵션을 제공한다. 상대적으로 느리다.</td>
</tr>
<tr>
<td>locate (mlocate)</td>
<td>파일, 디렉토리 Index를 만들고, 해당 Index 로 검색을 수행한다.</td>
</tr>
<tr>
<td>which</td>
<td>셸의 탐색 경로 내에서 <strong>명령어</strong>의 위치를 찾는다.</td>
</tr>
<tr>
<td>type</td>
<td>Bash 셸 내장 프로그램으로 which와 같은 기능이지만 더 빠르다.</td>
</tr>
<tr>
<td>whereis</td>
<td>매개변수로 주어진 디렉토리 목록에 대해 탐색한다.</td>
</tr>
</tbody></table>
<hr>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a><strong>find</strong></h3><p>find의 경우 Man Page가 굉장히 어려워 <a target="_blank" rel="noopener" href="https://www.tecmint.com/35-practical-examples-of-linux-find-command/">35 Practical Examples of Linux Find Command</a>를 참고했다. 해당 페이지 제목에서도 알 수 있듯, 한 명령어 설명에 35개의 예제가 들어간다는 것부터 범상치 않음을 짐작할 수 있다. find는 정말 그 기능이 너무나 많다. 정말 강력하다고 할 수 있으나 인덱싱이 지원되지 않아 탐색 대상이 늘어나면 꽤 느려져서 전체 디렉토리 대상으로 수행할 거라면 Interactive한 일회성 작업에 적절할 것 같다.</p>
<p>아래의 모든 옵션은 직접 테스트 후 작성하였다.</p>
<hr>
<p><strong>1. 공통 기능</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>옵션 앞에 <code>!</code>를 붙이면 NOT 조건이 된다.</td>
<td><code>find ! -name &quot;*.txt&quot;</code></td>
<td>“*.txt”에 매칭되지 않는 파일, 디렉토리만 출력</td>
</tr>
</tbody></table>
<hr>
<p><strong>2. 이름 기반 검색</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Ouput</th>
</tr>
</thead>
<tbody><tr>
<td>(x)</td>
<td><code>find</code></td>
<td>하위 디렉토리 <strong>전부</strong> 재귀적으로 출력 (grep 하려면 전체 방문을 기다려야 함)</td>
</tr>
<tr>
<td>-name</td>
<td><code>find -name input.txt</code></td>
<td>하위 디렉토리에서 <code>input.txt</code>를 찾아 출력</td>
</tr>
<tr>
<td>-name “패턴”</td>
<td><code>find -name &quot;*.txt&quot;</code></td>
<td>*.txt에 매칭되는 파일/디렉토리 검색 (<code>*</code>만 사용 가능한지 모르겠음)</td>
</tr>
<tr>
<td>(폴더 명시)</td>
<td><code>find /bin (options...)</code></td>
<td><code>/bin</code> 아래에서 검색을 수행</td>
</tr>
<tr>
<td>-type</td>
<td>`find -type (f</td>
<td>d)`</td>
</tr>
</tbody></table>
<hr>
<p><strong>3. 권한 기반 검색</strong></p>
<blockquote>
<p>권한 비트 앞에 0, 1, 2 등 한 바이트가 더 표현할 수 있는데 SGID, Sticky Bit 등의 내용에 대해 잘 이해하고 있지 못해서 생략했다. 추후 보강하겠다.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Options</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-perm 권한</td>
<td><code>find -perm 777</code></td>
<td>권한이 777인 파일, 디렉토리를 출력</td>
</tr>
<tr>
<td>-perm /권한</td>
<td><code>find -perm /u=r</code></td>
<td><strong>(이 부분은 스펙과 출력이 달라서 추후 갱신할 예정입니다.)</strong> user 권한이 r인 파일(Read-only), 디렉토리를 출력 (대신 첫 글자만 해석함. rw 등 안 됨)</td>
</tr>
</tbody></table>
<hr>
<p><strong>4. 출력에 대해 다른 명령어 수행</strong></p>
<p><code>-exec</code> 옵션이 있는데, <code>-exec COMMAND &#123;&#125; \;</code>와 같이 표시하는 형태이다. <code>&#123;&#125;</code> 가 각 라인이 들어갈 placeholder인 듯하다. 다만 이는 Pipelining으로도 충분히 가능해보여서 (-exec은 스트리밍을 지원하는건가?) 설명은 생략한다.</p>
<hr>
<p><strong>5. 소유자 기반 검색</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-user 소유자명</td>
<td><code>find -user root</code></td>
<td>root 소유의 파일, 디렉토리 출력</td>
</tr>
<tr>
<td>-group 그룹명</td>
<td><code>find -group sb</code></td>
<td>sb 소유의 파일, 디렉토리 출력 (sb는 제 유저명입니다)</td>
</tr>
</tbody></table>
<blockquote>
<p>참고로 그룹의 목록은 /etc/group 파일에 텍스트로 저장돼있다 :)</p>
</blockquote>
<hr>
<p><strong>6. 시간 속성 기반 검색</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-mtime N</td>
<td><code>find ~ -mtime 1</code></td>
<td>1일 내에 <strong>변경된</strong> <code>~</code> 내의 파일 출력</td>
</tr>
<tr>
<td>-atime</td>
<td></td>
<td>접근 시각 기준</td>
</tr>
<tr>
<td>-mtime +N -mtime -M</td>
<td><code>find ~ -mtime +50 -mtime -100</code></td>
<td>N일보다 더 지나고 N일 보다 덜 지난 날짜 사이에서 변경된 <code>~</code> 내의 파일 출력</td>
</tr>
<tr>
<td>-cmin/mmin N</td>
<td><code>find -cmin/mmin 60</code></td>
<td>현재 디렉토리 아래에 변경된 지 60분 이내의 파일 출력</td>
</tr>
<tr>
<td>-amin N</td>
<td><code>find -amin 60</code></td>
<td>현재 디렉토리 아래에 접근한 지 60분 이내의 파일 출력</td>
</tr>
</tbody></table>
<p><strong>7. 파일 크기 기반 검색</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-size N</td>
<td><code>find -size 50M</code></td>
<td>50M인 파일 출력</td>
</tr>
<tr>
<td>-size +N -M</td>
<td><code>find -size +50M -100M</code></td>
<td>50M ~ 100M인 파일 출력 (초과, 미만)</td>
</tr>
</tbody></table>
<hr>
<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a><strong>locate</strong></h3><p>파일, 디렉토리 Index를 만들고, 해당 Index 로 검색을 수행한다. </p>
<p>기본 Index 파일이 생성되는 경로는 <code>/var/lib/mlocate/mlocate.db</code> 이다.</p>
<p>Index에서 검색하므로 가장 빠르다.</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>Example</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-b \NAME (–basename)</td>
<td><code>locate \input.txt</code></td>
<td>input.txt와 일치하는 이름을 가진 모든 파일/디렉토리를 출력</td>
</tr>
</tbody></table>
<hr>
<h3 id="which-type"><a href="#which-type" class="headerlink" title="which, type"></a><strong>which, type</strong></h3><p>셸의 탐색 경로 내에서 명령어의 위치를 찾는다.</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>명령어에 대한 모든 일치하는 바이너리 위치를 출력</td>
</tr>
</tbody></table>
<hr>
<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a><strong>whereis</strong></h3><p>매개변수로 주어진 디렉토리 목록에 대해 탐색한다.</p>
<p><code>whereis -bm ls tr -m gcc</code> : ls, tr 검색어에 대해 Binary, ManPage 검색 + gcc 검색어에 대해 ManPage 검색</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>Description</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>-b (binary)</td>
<td>검색어에 대응되는 바이너리 검색을 한다</td>
<td></td>
</tr>
<tr>
<td>-B,M,S [directories…]</td>
<td>-b/m/s 옵션으로 검색 시 탐색할 디렉토리</td>
<td></td>
</tr>
<tr>
<td>-m (manual)</td>
<td>검색어에 대응되는 매뉴얼 검색을 한다 (Man Page)</td>
<td></td>
</tr>
<tr>
<td>-s (sources)</td>
<td>검색에어 대응되는 소스파일 검색을 한다</td>
<td></td>
</tr>
<tr>
<td>-f</td>
<td>-B, -M, -S 옵션 사용시 반드시 사용해야 함. 찾을 검색어와 옵션의 구분자 역할을 한다</td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>TODO:</p>
<ul>
<li>find 이외에는 문서가 자세하고 정확한 경우는 잘 없어서 조사가 더 필요할 것 같다.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-26T08:00:00.000Z" title="2021-03-26T08:00:00.000Z">21-03-26</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-26T05:25:16.490Z" title="2021-03-26T05:25:16.490Z">21-03-26</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">몇 초안에 읽기 (약 97 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-5-stream-5/">Stream 생태계 정리</a></h1><div class="content"><p>이 글에서는 Node.js Stream API 생태계를 정리한다.</p>
<hr>
<hr>
<p>TODO:</p>
<ol>
<li>스트림을 제대로 써봐야 제대로 이해할 수 있을 것 같다.</li>
<li>스트림 생태계가 좀 엉망인데 직접 사용해보고 정리하는 기회가 필요할 것 같다.</li>
<li>이 글도 예제를 제대로 추가해 영양가 있는 글로 만들어야 한다.</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-25T06:00:00.000Z" title="2021-03-25T06:00:00.000Z">21-03-25</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-25T05:57:50.270Z" title="2021-03-25T05:57:50.270Z">21-03-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">11분안에 읽기 (약 1664 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-5-stream-4/">5장 Stream API 디자인 패턴 - Pipe, Fork, Merge, Mux/Demux</a></h1><div class="content"><p>이 글은 Stream에서의 Pipe, Fork, Merge, Mux/Demux 패턴에 대해 소개하고 Mux/Demux는 예를 제공한다.</p>
<p>참고 자료:</p>
<ul>
<li>Node.js의 Buffer API에 대해서는 <a target="_blank" rel="noopener" href="https://tk-one.github.io/2018/08/28/nodejs-buffer/">Node.js의 Buffer를 제대로 이해해보자</a></li>
<li>Node.js에서의 스트림 자체에 대해서는 <a href="https://jsqna.com/ndp-5-stream-1/">5장 Stream API (1/3) - 스트림 개요 및 Readable Stream</a></li>
<li>Stream의 종류 4가지에 대해서는 <a href="https://jsqna.com/ndp-5-stream-2/">5장 Stream API (2/3) - Node.js의 4가지 스트림 소개와 사용법</a></li>
<li>Stream 기반의 순차 실행, 병렬 실행 구현에 대해서는 <a href="https://jsqna.com/ndp-5-stream-3/">5장 Stream API (3/3) - Stream을 사용할 때에 순차 실행, 병렬 실행, 제한된 병렬 실행 구현하기</a></li>
</ul>
<hr>
<h3 id="1-Pipe-패턴"><a href="#1-Pipe-패턴" class="headerlink" title="1. Pipe 패턴"></a><strong>1. Pipe 패턴</strong></h3><p>여기서 말하는 Pipe 패턴이란 스트림의 조합으로 이루어진 하나의 파이프라인을 모듈화하고 재사용하는 방법을 말한다. </p>
<p>Pipe 패턴 구현 시 주의할 점</p>
<ul>
<li>첫 Stream에 Write하고, 마지막 Stream에서 Read해야 한다.</li>
<li>내부의 모든 Stream에서 발생하는 오류를 포착할 수 있어야 한다. Error Listener 하나로 Pipeline에서 발생하는 모든 오류를 구독할 수 있도록 한다.</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/felixge/node-combined-stream">Combined-Stream</a> 패키지를 이용한다. (사용량은 압도적이나 Stream v1 - Flowing 모드만 지원한다.)</p>
<p>(<a target="_blank" rel="noopener" href="https://github.com/mafintosh/pumpify">Pumpify</a>가 더 좋은 것 같은데 사용법을 잘 모르겠다.)</p>
<hr>
<h3 id="2-Fork-패턴"><a href="#2-Fork-패턴" class="headerlink" title="2. Fork 패턴"></a><strong>2. Fork 패턴</strong></h3><p>서로 다른 대상에 동일한 데이터를 보내는 경우, 즉 하나의 Readable에 2개 이상의 스트림을 연결하는 패턴이다. </p>
<p>Fork 패턴 구현 시 주의할 점</p>
<ul>
<li><code>.pipe</code> 사용 시 <code>&#123;end: false&#125;</code> 옵션이 필수가 된다. 한 쪽의 작업이 끝나는 경우 다른 쪽도 닫히기 때문</li>
<li>백 프레셔 때문에 제일 느린 스트림에 속도가 맞춰지게 된다.</li>
<li>같은 프로세스 내에 두 스트림이 있는 경우 chunk가 공유되므로 한 쪽의 스트림에서 해당 chunk의 내용을 직접 수정하게 되면 다른 스트림도 그 영향을 받게 된다.</li>
</ul>
<hr>
<h3 id="3-Merge-패턴"><a href="#3-Merge-패턴" class="headerlink" title="3. Merge 패턴"></a><strong>3. Merge 패턴</strong></h3><p>일련의 Readable을 하나의 스트림으로 연결하는 패턴이다. <code>.pipe(&#123;end: false&#125;)</code>로 연결해야 한다. Auto End 옵션은 하나의 Redable만 종료되더라도 연결된 스트림까지 종료시키기 때문이다.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/grncdr/merge-stream">Merge-Stream</a> 패키지를 사용한다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/feross/multistream">multistream</a> 패키지보다 훨씬 사용량이 많다.</li>
</ul>
<hr>
<h3 id="4-Mux-Demux-패턴"><a href="#4-Mux-Demux-패턴" class="headerlink" title="4. Mux/Demux 패턴"></a><strong>4. Mux/Demux 패턴</strong></h3><p>(직접 구현한다.) 여러 스트림에서 들어오는 데이터를 한 스트림(이 예에서는 <code>net</code> 패키지의 도움을 받아 TCP Socket을 사용한다.)으로 내보내고, 같은 방식으로 데이터를 받아들인 후 여러 스트림으로 다시 분류하는 멀티플렉싱/디멀티플렉싱을 스트림 수준에서 구현한다.</p>
<p><img src="/images/ndp-stream/MuxDemux.png" alt="아키텍처 요약"></p>
<p>긴 설명은 하지 않고, 코드에 주석을 달아 놓았으니 흐름을 따라가면 쉽게 이해할 수 있을 것이다.</p>
<p><strong>generateData.js</strong></p>
<p>표준 출력, 오류 스트림에서 데이터를 생성하기 위한 코드이다. Client에서 실행하게 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;out1&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;out2&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">&quot;err1&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;out3&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">&quot;err2&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Client.js</strong></p>
<p>generateData로 생성된 데이터가 표준 출력, 오류 스트림으로 들어오게 되고, 아래 코드에서 헤더로 포장한 후 Socket으로 Server에 전송한다. (참고로 Client 코드가 이 case에서 가장 어렵다. 이 코드만 이해하면 다 했다고 볼 수 있다.)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplexChannels</span>(<span class="params">sources, destination</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalChannels = sources.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sources.length; i++) &#123;</span><br><span class="line">    sources[i]</span><br><span class="line">      .on(<span class="string">&quot;readable&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> chunk;</span><br><span class="line">        <span class="keyword">while</span> ((chunk = <span class="built_in">this</span>.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 5+chunk byte (Node.js는 바이트 스트림(Octet Stream)만 지원하는건지, Buffer도 최소 단위가 bit이 아니라 byte이다.)</span></span><br><span class="line">          <span class="keyword">const</span> outBuff = Buffer.alloc(<span class="number">1</span> + <span class="number">4</span> + chunk.length); <span class="comment">// Buffer.alloc(size); === new Buffer(size);</span></span><br><span class="line">          outBuff.writeUInt8(i, <span class="number">0</span>); <span class="comment">// write(data, idx) - 이 경우에는 idx=0</span></span><br><span class="line">          outBuff.writeUInt32BE(chunk.length, <span class="number">1</span>); <span class="comment">// write (data, idx) 이 경우에는 idx=1 (앞 데이터는 8bit 이므로, 한 칸만 사용)</span></span><br><span class="line">          chunk.copy(outBuff, <span class="number">5</span>); <span class="comment">// 앞에서 40bit를 사용해서 다음 데이터의 offset=5</span></span><br><span class="line">          <span class="comment">// chunk가 무슨 타입인지 모르겠지만 Readable이 제공하는 chunk는 copy 메소드가 있는 듯.</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;Sending packet to channel: &quot;</span> + i);</span><br><span class="line">          destination.write(outBuff); <span class="comment">// 대상 스트림으로 쓰기</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 모든 Readable이 닫힌 후 대상 스트림 종료</span></span><br><span class="line">        <span class="keyword">if</span> (--totalChannels === <span class="number">0</span>) &#123;</span><br><span class="line">          destination.end();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net.connect: (port, host?, callback)</span></span><br><span class="line"><span class="keyword">const</span> socket = net.connect(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//현재 프로세스는 소켓을 열고 끝. net.connect는 Non-blocking call 이다.</span></span><br><span class="line">  <span class="keyword">const</span> child = child_process.fork(</span><br><span class="line">    <span class="comment">// child_process.fork로 새 프로세스에서 JS 파일을 실행한다. (이 경우 generateData.js)</span></span><br><span class="line">    process.argv[<span class="number">2</span>],</span><br><span class="line">    process.argv.slice(<span class="number">3</span>), <span class="comment">// fork로 실행할 JS파일</span></span><br><span class="line">    &#123; <span class="attr">silent</span>: <span class="literal">true</span> &#125; <span class="comment">// silent 옵션: Child 프로세스가 독립적인 표준 스트림을 갖도록 (상속받지 않도록)</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  multiplexChannels([child.stdout, child.stderr], socket); <span class="comment">// 대상 스트림으로 Socket 생성해 전달</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Server.js</strong></p>
<p>클라이언트로부터 데이터를 파싱한 후 각 스트림에 대응되는 파일에 내용을 쓴다. 헤더 격인 앞 1바이트를 읽어 채널을 구분한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 소켓마다 한 번 호출됨 (상태 관리 필요)</span></span><br><span class="line"><span class="comment">// 디멀티플렉싱 수행</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demultiplexChannel</span>(<span class="params">source, destinations</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 상태 관리 필드</span></span><br><span class="line">  <span class="keyword">let</span> currentChannel = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> currentLength = <span class="literal">null</span>;</span><br><span class="line">  source</span><br><span class="line">    .on(<span class="string">&quot;readable&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 1. 표준 입력/오류 구분</span></span><br><span class="line">      <span class="keyword">let</span> chunk;</span><br><span class="line">      <span class="keyword">if</span> (currentChannel === <span class="literal">null</span>) &#123;</span><br><span class="line">        chunk = source.read(<span class="number">1</span>);</span><br><span class="line">        currentChannel = chunk &amp;&amp; chunk.readUInt8(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 데이터 길이 파싱</span></span><br><span class="line">      <span class="keyword">if</span> (currentLength === <span class="literal">null</span>) &#123;</span><br><span class="line">        chunk = source.read(<span class="number">4</span>);</span><br><span class="line">        currentLength = chunk &amp;&amp; chunk.readUInt32BE(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (currentLength === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 데이터 길이만큼 읽기</span></span><br><span class="line">      chunk = source.read(currentLength);</span><br><span class="line">      <span class="keyword">if</span> (chunk === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 읽은 데이터(chunk)를 대상 스트림에 작성</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Received packet from: &quot;</span> + currentChannel);</span><br><span class="line">      destinations[currentChannel].write(chunk);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// chunk 순서대로 호출되므로 여기서 다시 null을 할당하면 됨 :)</span></span><br><span class="line">      currentChannel = <span class="literal">null</span>;</span><br><span class="line">      currentLength = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 소켓에서 받은 데이터가 끝난 경우 대상 스트림 모두 종료</span></span><br><span class="line">      destinations.forEach(<span class="function">(<span class="params">destination</span>) =&gt;</span> destination.end());</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Source channel closed&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 소켓 3000번으로 서버 열기</span></span><br><span class="line">net</span><br><span class="line">  .createServer(<span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 연결 수립 시 수행할 Callback</span></span><br><span class="line">    <span class="keyword">const</span> stdoutStream = fs.createWriteStream(<span class="string">&quot;stdout.log&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> stderrStream = fs.createWriteStream(<span class="string">&quot;stderr.log&quot;</span>);</span><br><span class="line">    <span class="comment">// Source: 소켓을 통해 전달된 octet-stream, 대상 스트림 2개: 표준 출력, 표준 오류</span></span><br><span class="line">    demultiplexChannel(socket, [stdoutStream, stderrStream]);</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Server started&quot;</span>));</span><br></pre></td></tr></table></figure>
<hr>
<p>TODO:</p>
<ol>
<li>스트림을 제대로 써봐야 제대로 이해할 수 있을 것 같다.</li>
<li>스트림 생태계가 좀 엉망인데 직접 사용해보고 정리하는 기회가 필요할 것 같다.</li>
<li>이 글도 예제를 제대로 추가해 영양가 있는 글로 만들어야 한다.</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-21T13:00:00.000Z" title="2021-03-21T13:00:00.000Z">21-03-21</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-20T13:07:43.260Z" title="2021-06-20T13:07:43.260Z">21-06-20</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">15분안에 읽기 (약 2224 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-shell-1/">리눅스 셸(bash) 기본 기능 소개</a></h1><div class="content"><p>이 글에서 소개할 내용은 굉장히 유용한 기능이라고 생각하며, 셸의 역할인 코드 실행 시의 입/출력에 대한 Proxy, Middleware 역할을 잘 활용하는 기능들이라고 생각한다. 이 글은 리눅스 핵심 레퍼런스의 일부를 참고해 작성하였다. </p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (GCP Compute Engine)</p>
</blockquote>
<hr>
<blockquote>
<p>셸은 단순한 호출보다 훨씬 많은 것을 할 수 있다.</p>
</blockquote>
<hr>
<h3 id="1-wildcard-정규표현식과-유사한-검색을-수행한-결과를-명령의-입력으로-사용"><a href="#1-wildcard-정규표현식과-유사한-검색을-수행한-결과를-명령의-입력으로-사용" class="headerlink" title="1. wildcard: 정규표현식과 유사한 검색을 수행한 결과를 명령의 입력으로 사용"></a><strong>1. wildcard: 정규표현식과 유사한 검색을 수행한 결과를 명령의 입력으로 사용</strong></h3><hr>
<h4 id="1-가장-기본이-되는-예제"><a href="#1-가장-기본이-되는-예제" class="headerlink" title="1. 가장 기본이 되는 예제"></a>1. 가장 기본이 되는 예제</h4><p>이름에 wildcard 검색을 수행해 결과를 명령의 입력으로 사용할 수 있다. 이름 일치 기준은 디렉토리이다. 즉 <code>a*</code>를 셸 명령어에 입력하게 되면, <code>./a</code>로 시작하는 파일/디렉토리를 반환한다. 특정 상위 폴더나 하위 폴더를 대상으로 검색하고 싶은 경우 그에 맞는 상대 경로를 입력하면 된다.  </p>
<hr>
<p>(ex 1) <code>ls a*</code> == <code>ls aardvark adamantium apple</code>  </p>
<p>(ex 2) <code>ls githubblog/.*</code> == <code>ls githubblog/.git githubblog/.deploy_git, ...</code></p>
<p><img src="/images/linux-shell/a1.png" alt="기준 디렉토리 목록"></p>
<p>위 사진은 기준 디렉토리이다. 여기서 <code>g*</code> 인 파일/디렉토리를 <code>ls -alF</code>의 매개변수로 주려고 한다. </p>
<p><img src="/images/linux-shell/a2.png" alt="g*에 해당하는 목록을 wildcard를 통해 입력으로 사용"></p>
<p>위 사진은 명령의 결과물로, 실제로 잘 수행됨을 확인할 수 있다.</p>
<hr>
<h4 id="2-추가-옵션"><a href="#2-추가-옵션" class="headerlink" title="2.추가 옵션"></a>2.추가 옵션</h4><p><code>[문자들...]</code> : 문자들 중 하나와 일치하는 경우. </p>
<ul>
<li><code>[aieou]</code> : 모음 중 하나. 단 이렇게 찾으려면 파일/디렉토리 이름이 a, i, e, o, u 중 하나여야 한다. (즉 한 글자)</li>
</ul>
<hr>
<p><code>[^문자들...]</code>, <code>[!문자들...]</code> : 명시된 문자 이외의 any 문자</p>
<ul>
<li><code>[^aieou]</code> : 자음 중 하나. 단 이렇게 찾으려면 파일/디렉토리 이름이 b, c, d, f, g, … 중 하나여야 한다. (즉 한 글자)</li>
</ul>
<hr>
<p><code>?</code> : 임의의 한 문자. character 하나의 placeholder라고 생각하면 편리하다.</p>
<ul>
<li><code>[githubblo?]</code> : <code>githubblog</code>가 있다면 일치한다.</li>
</ul>
<hr>
<p><code>*</code> : asterisk의 일반적인 의미처럼 아무거나. <u>empty를 포함한</u> 모든 string을 의미. 보통 조합할 때 필수적으로 사용된다.</p>
<ul>
<li><code>*[aioeu]</code> : 모음으로 끝나는 경우</li>
<li><code>*[aioeu]*</code> : 모음이 포함된 경우</li>
<li><code>[aioeu]*</code> : 모음으로 시작하는 경우</li>
</ul>
<hr>
<h3 id="2-중괄호-확장-단순히-가능한-모든-경우의-수를-입력으로-사용"><a href="#2-중괄호-확장-단순히-가능한-모든-경우의-수를-입력으로-사용" class="headerlink" title="2. 중괄호 확장: 단순히 가능한 모든 경우의 수를 입력으로 사용"></a><strong>2. 중괄호 확장: 단순히 가능한 모든 경우의 수를 입력으로 사용</strong></h3><p>문자열 중간에서 사용되며 가능한 모든 경우의 수로 치환된 후 입력으로 사용된다.</p>
<p><img src="/images/linux-shell/b1.png" alt="echo a{b,c,d}e{f,g,h} 결과"></p>
<p>(ex) <code>echo a&#123;b,c,d&#125;e&#123;f,g,h&#125;</code> == <code>echo abef abeg abeh acef aceg aceh adef adeg adeh</code></p>
<hr>
<h3 id="3-변수-String-타입의-환경-변수"><a href="#3-변수-String-타입의-환경-변수" class="headerlink" title="3. 변수: String 타입의 환경 변수"></a><strong>3. 변수: String 타입의 환경 변수</strong></h3><blockquote>
<p>bash 프로파일 관리에 대해선 좀 더 나중에 다루려고 한다.</p>
</blockquote>
<p>Windows의 환경 변수와 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/ko-kr/windows-server/administration/windows-commands/set_1">cmd 환경 변수</a>와 같은 2가지 변수가 있다. 모두 환경 변수이지만 그 범위가 다른데, <u>cmd 환경 변수에 대응</u>되는 Linux에서의 개념이 셸 변수이다. 단 아래의 방법으로 하면 해당 세션(셸)에서만 사용할 수 있으므로 일회성 변수로 생각하면 좋다.</p>
<p><strong>쓰기</strong> : <code>MYVAR=string_value</code></p>
<p><strong>읽기</strong> : <code>$MYVAR</code></p>
<p>만약 환경 변수로 저장하고 싶다면, <code>export MYVAR=string_value</code>와 같이 사용하면 된다. 환경 변수는 <code>printenv</code> 혹은 <code>env</code> 명령으로 확인할 수 있다.</p>
<hr>
<h4 id="기본으로-제공되는-환경-변수"><a href="#기본으로-제공되는-환경-변수" class="headerlink" title="기본으로 제공되는 환경 변수"></a><strong>기본으로 제공되는 환경 변수</strong></h4><p><code>PATH</code> : 바이너리 검색 경로의 목록. 콜론으로 구분.</p>
<p><code>PWD</code> :  현재 디렉토리 ( <code>OLDPWD</code> : 마지막으로 방문한 디렉토리 )</p>
<p><code>HOME</code> : 홈 디렉토리 ( ex : <code>/home/sb</code> )</p>
<p><code>USER</code> : 로그인명 ( <code>sb</code> )</p>
<hr>
<h3 id="4-alias"><a href="#4-alias" class="headerlink" title="4. alias"></a><strong>4. alias</strong></h3><p>단순한 String 치환이다.</p>
<p><strong>지정</strong> :  <code>alias ll = &quot;ls -lG&quot;</code>를 입력하면, 이후 셸에서 <code>ll</code>을 입력하면 <code>ls -lG</code>가 입력된다.</p>
<p><strong>목록 확인</strong> : <code>alias</code>만 입력하면 된다.</p>
<p><img src="/images/linux-shell/c1.png" alt="alias 입력 시의 결과"></p>
<hr>
<h3 id="5-입출력-redirection"><a href="#5-입출력-redirection" class="headerlink" title="5. 입출력 redirection"></a><strong>5. 입출력 redirection</strong></h3><blockquote>
<p>아직 입출력을 파일을 통해 수행해본 적이 없어서 추후 적절한 예시를 추가하려고 한다. 이번 글에서는 개념적으로 그 사용법만 다룬다.</p>
</blockquote>
<p>표준 입출력의 지점을 임의의 파일에 수행하게 한다.</p>
<p><strong>입력을 파일의 내용으로</strong> : <code>command &lt; input_file</code></p>
<ul>
<li>재미있게도 <code>echo &lt; sample.txt</code> 와 같이, <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/63658/redirecting-the-content-of-a-file-to-the-command-echo">echo 명령은 임의의 input 파일의 내용을 출력할 수 없는데</a>, 표준 입출력에서 내용을 읽지 않기 때문이다.</li>
</ul>
<p><strong>출력을 파일로</strong> : </p>
<ol>
<li><p>새로운 파일로 작성 :  <code>command &gt; output_file</code></p>
</li>
<li><p>기존 파일에 이어 쓰기 : <code>command &gt;&gt; output_file</code></p>
</li>
<li><p>오류의 경우 : <code>command 2&gt; error_file</code></p>
</li>
<li><p>출력, 오류 모두 : <code>command &gt;&amp; output_file</code> 혹은 <code>command &amp;&gt; output_file</code></p>
</li>
<li><p>출력, 오류 각각 : <code>command &gt; output_file 2&gt; error_file</code></p>
</li>
</ol>
<blockquote>
<p>리눅스에서 표준 스트림은 3가지이며 자세한 내용은 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%ED%91%9C%EC%A4%80_%EC%8A%A4%ED%8A%B8%EB%A6%BC">위키 백과 (표준 스트림)</a> 참고</p>
</blockquote>
<hr>
<h3 id="6-Pipe"><a href="#6-Pipe" class="headerlink" title="6. Pipe"></a><strong>6. Pipe</strong></h3><blockquote>
<ol>
<li>각 프로그램이 하나의 일을 잘 할 수 있게 만들 것. 새로운 일을 하려면, 새로운 기능들을 추가하기 위해 오래된 프로그램을 복잡하게 만들지 말고 새로 만들 것.</li>
<li>모든 프로그램 출력이 아직 잘 알려지지 않은 프로그램이라고 할지라도 다른 프로그램에 대한 입력이 될 수 있게 할 것. 무관한 정보로 출력을 채우지 말 것. 까다롭게 세로로 구분되거나 바이너리로 된 입력 형식은 피할 것. 대화식 입력을 고집하지 말 것.</li>
<li>소프트웨어를, 심지어는 운영 체제일지라도 이른 시기에 수주에 걸쳐 이상적으로 시도해가며 설계하고 만들 것. 어설픈 부분을 버리고 다시 만드는 것을 주저하지 말 것.</li>
<li>프로그래밍 작업을 가볍게 하기 위해, 심지어 우회하는 방법으로 도구를 만들고 바로 버릴지라도 어설픈 도움 보다는 도구 사용을 선호할 것.</li>
</ol>
<p>출처: <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%B2%A0%ED%95%99">위키 백과 (유닉스 철학)</a></p>
</blockquote>
<p>Pipe 연산자는 유닉스 철학을 구현하는 도구 중 하나로, 이 중 2번 규칙을 지키는 도구로 사용된다.</p>
<p>(ex) <code>who | sort | awk &#39;&#123;print $1&#125;&#39; | less</code></p>
<blockquote>
<p>pipe 연산자의 효과를 제대로 소개하는 예제를 만들기엔 아직 아는 명령어가 극히 적어서 추후 제대로 소개하고자 한다. 해당 소개 글이 작성될 경우 이 글에서 링크를 제공하도록 하겠다.</p>
</blockquote>
<hr>
<h3 id="7-평가식"><a href="#7-평가식" class="headerlink" title="7. 평가식"></a><strong>7. 평가식</strong></h3><p>평가식이란 그 내용이 코드로 해석되는 영역을 말한다. 셸에서의 평가식은 해당 평가식을 셸에서 따로 실행시켰을 때의 결과를 반환하는 형태를 갖는다. 이 평가식의 문법은 크게 두 가지가 있는데,</p>
<ol>
<li>backtick : <code>echo This year is ``date +%Y\`` </code><ul>
<li>This year is 2021</li>
</ul>
</li>
<li>$() : <code>echo Next year is $(expr $(date +%Y) + 1)</code><ul>
<li>Next year is 2022</li>
</ul>
</li>
</ol>
<p>평가식으로 (5)에서 실패했던 <code>echo &lt; sample.txt</code>를 평가식으로는 실행할 수 있다: <code>echo $(cat sample.txt)</code> (`을 사용해도 된다.)</p>
<hr>
<h3 id="8-작업-제어"><a href="#8-작업-제어" class="headerlink" title="8. 작업 제어"></a><strong>8. 작업 제어</strong></h3><p>셸에서 수행되는 프로그램은 대개 포그라운드로 실행된다. 즉 사용자와의 인터렉션이 블로킹되는데 셸에서 프로그램을 실행할 때 백그라운드로도 실행시킬 수 있다. 또한 포그라운드와 백그라운드를 넘나들 수 있으며 작업을 정지하고 다시 실행할 수도 있으며 셸 마저 정지할 수도 있다.</p>
<p><strong>백그라운드로 작업 실행</strong> : <code>command ... &amp;</code> (<code>&amp;</code>가 핵심이다.)</p>
<p><strong>포그라운드 작업 정지</strong> : <code>Ctrl + Z</code></p>
<p><strong>백그라운드에서 작업 재개</strong> : `bg {id}``</p>
<p><strong>포그라운드로 작업을 가져와 실행</strong> : <code>fg &#123;id&#125;</code></p>
<p><strong>현재 수행 중인 작업의 목록 조회</strong> : <code>jobs</code></p>
<p><strong>현재 셸 정지</strong> : <code>suspend</code> (현재 실행 중인 셸이 2개 이상이어야 호출 가능하다.)</p>
<hr>
<h3 id="9-여러-셸-동시-사용"><a href="#9-여러-셸-동시-사용" class="headerlink" title="9. 여러 셸 동시 사용"></a><strong>9. 여러 셸 동시 사용</strong></h3><p><code>screen</code>은 내장 기능이어서 dependency가 추가로 필요하지 않아 사용에 제약이 없지만 그 기능이 적고 불편하다. <code>tmux</code>가 많이 사용되며 기본으로 설치되는 경우도 있으나(WSL Ubuntu에는 기본으로 설치돼있다.) 둘 모두 사용해본 적이 없어 추후에 다루도록 한다.</p>
<hr>
<p><strong>TODO</strong> :</p>
<p>입출력 Redirection 적극적으로 활용해보기 (특히 알고리즘 테스트 케이스 수행 시)</p>
<p>screen/tmux 모두 사용해보고 비교하기</p>
<p>리눅스 명령어 더 공부하고, pipe로 효과적인 예 만들기</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-14T05:00:00.000Z" title="2021-03-14T05:00:00.000Z">21-03-14</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-14T04:58:49.669Z" title="2021-03-14T04:58:49.669Z">21-03-14</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">7분안에 읽기 (약 999 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-dir/">리눅스 주요 디렉토리의 이름과 의미 정리 (계속 업데이트 예정)</a></h1><div class="content"><p>이 글은 리눅스를 처음 시작하는 경우 다른 OS의 디렉토리 구성과의 큰 차이로 인한 불편함을 줄이기 위한 큰 지도이다.</p>
<hr>
<h3 id="1-Home-디렉토리"><a href="#1-Home-디렉토리" class="headerlink" title="1. Home 디렉토리"></a><strong>1. Home 디렉토리</strong></h3><p>크게 2가지 Home 디렉토리가 있다. 이는 사용자에 따라 구분되는데,</p>
<ul>
<li>일반 사용자: <code>/home/&#123;USER_NAME&#125;</code> </li>
<li>루트 사용자: <code>/root</code></li>
</ul>
<p>형태로 사용한다.</p>
<hr>
<h3 id="2-시스템-디렉토리"><a href="#2-시스템-디렉토리" class="headerlink" title="2. 시스템 디렉토리"></a><strong>2. 시스템 디렉토리</strong></h3><p>시스템 디렉토리란 사용자 디렉토리를 제외한 (거의) 모든 디렉토리를 말한다. 윈도우에서 <code>Program Files</code> 폴더가 시스템 디렉토리에 포함된다고 생각하면 이 정의에 동의할 수 있을 것이고, <code>Windows</code>, <code>AppData</code> 등의 폴더만 시스템 디렉토리라고 생각한다면 이 정의에 동의하긴 어려울 듯 하다.</p>
<hr>
<h4 id="일반적인-경로-구성"><a href="#일반적인-경로-구성" class="headerlink" title="일반적인 경로 구성"></a><strong>일반적인 경로 구성</strong></h4><p><img src="/images/linux-dir/sysdir.png" alt="시스템 디렉토리의 경로 구성"></p>
<hr>
<p>(ex) <code>/usr/local/share/emacs</code></p>
<ul>
<li><code>/usr/local</code> : 스코프</li>
<li><code>/share</code> : 카테고리</li>
<li><code>/emacs</code> : 응용 프로그램</li>
</ul>
<h4 id="경로-구성-요소-스코프"><a href="#경로-구성-요소-스코프" class="headerlink" title="경로 구성 요소 - 스코프"></a><strong>경로 구성 요소 - 스코프</strong></h4><p>스코프는 가장 상위 디렉토리로서 하위 디렉토리인 카테고리나 응용 프로그램이 실행되는 범위를 나타낸다. 다만 구분에 사용되는 명확한 기준은 없고 단지 <code>/</code>가 <code>/usr</code>보다 좀 더 운영 체제에 가까운 근본적인 수준이라는 느낌이라고 한다(출처: 리눅스 핵심 레퍼런스).</p>
<p><strong>스코프의 종류</strong>:</p>
<ol>
<li><p><code>/</code> : 리눅스 시스템 파일</p>
</li>
<li><p><code>/usr</code> : <em>또 다른</em> 리눅스 시스템 파일</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/308045/differences-between-bin-sbin-usr-bin-usr-sbin-usr-local-bin-usr-local">Differences between /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin</a> 참고</li>
</ul>
</li>
<li><p><code>/usr/local</code> : 개인 컴퓨터에서 지역적으로 생성되는 시스템 파일</p>
<p>(ex) <code>/usr/local/bin</code> : 기본 프로그램이 아닌 경우 주로 여기에 설치된다.</p>
</li>
</ol>
<hr>
<h4 id="경로-구성-요소-카테고리"><a href="#경로-구성-요소-카테고리" class="headerlink" title="경로 구성 요소 - 카테고리"></a><strong>경로 구성 요소 - 카테고리</strong></h4><p>카테고리는 하위 디렉토리인 응용 프로그램의 목적을 나타낸다.</p>
<ol>
<li><p>실행 파일:   </p>
<ul>
<li><code>bin</code> : 바이너리</li>
<li><code>sbin</code> : 바이너리 (root 사용자 용이어서 root 권한이 필요하다.)</li>
<li><code>lib</code> : 바이너리에서 사용되는 라이브러리</li>
<li>Ubuntu 20.04의 경우 <code>/</code> 스코프의 <code>bin, sbin, lib</code>이 <code>/usr</code> 스코프로의 심볼릭 링크로 돼 있음 (어떤 배포판들이 또 이렇게 돼있는지는 확인 x)</li>
<li><img src="/images/linux-dir/link.png"></li>
</ul>
</li>
<li><p>설정 파일:</p>
<ul>
<li><code>etc</code> : 시스템 설정 파일</li>
<li><code>init.d</code>, <code>rc.d</code> : 부팅 설정 파일</li>
</ul>
</li>
<li><p>문서: <code>doc</code>, <code>info</code>, <code>man</code>, <code>share</code></p>
</li>
<li><p>HW 관련:</p>
<ul>
<li><code>dev</code> : Linux에서는 장치를 파일로 표현한다.</li>
<li><code>media</code>, <code>mnt</code> : Disk 마운트 지점<ul>
<li>리눅스는 디렉토리 트리가 하나여야 하므로 mount를 통해 트리를 병합해야 함</li>
<li><a target="_blank" rel="noopener" href="https://blog.naver.com/PostView.nhn?blogId=lunarispars&logNo=221462605068">[ 리눅스 마스터 ] 리눅스 디스크관리 - 마운트 (+실습, 명령어정리 )</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Runtime:</p>
<ul>
<li><code>var</code> : 클라이언트마다 다른 파일을 저장<ul>
<li><a target="_blank" rel="noopener" href="https://jadehan.tistory.com/11">Linux 기본 - /var 디렉토리의 이해</a></li>
</ul>
</li>
<li><code>run</code> : 실행 중인 프로세스의 ID를 담고 있는 PID 파일</li>
</ul>
</li>
<li><p>운영체제 관련:</p>
<ul>
<li><code>boot</code> ( <code>/boot/vmlinuz</code> ): 커널, 부팅 관련 파일</li>
<li><code>lost+found</code> : 손상된 파일 등 추후 복구를 위한 임시 저장 경로<ul>
<li><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/18154/what-is-the-purpose-of-the-lostfound-folder-in-linux-and-unix">What is the purpose of the lost+found folder in Linux and Unix?</a></li>
</ul>
</li>
<li><code>proc</code> : 현재 실행 중인 프로세스 정보. 저용량이며 실시간으로 반영한다.<ul>
<li><code>cat /proc/ioports</code> : I/O HW 목록 표시</li>
<li><code>cat /proc/cpuinfo</code> : 프로세서 정보. 코어 단위로 상세 정보를 출력</li>
<li><code>cat /proc/version</code> : OS 버전 정보 표시 (ex: <code>Linux version 4.19.128-microsoft-standard</code>)</li>
<li><code>cat /proc/uptime</code> : ms 단위로 uptime 출력. (<code>uptime</code> 명령어가 더 낫다)</li>
<li><code>ll /proc/&#123;PID&#125;</code> : PID에 대응되는 프로세스의 정보. (많은데 잘 모르겠다)</li>
<li><code>ll /proc/self</code> : 현재 실행중인 프로세스로의 심볼릭 링크 (ex) 1261</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p>이 글은 꾸준히 계속 업데이트될 예정입니다!</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">이전</a></div><div class="pagination-next"><a href="/page/3/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">48</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/NCloud/"><span class="level-start"><span class="level-item">NCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/RabbitMQ/"><span class="level-start"><span class="level-item">RabbitMQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-29T14:59:00.000Z">21-08-29</time></p><p class="title"><a href="/linux-uptime-top/">uptime, top으로 CPU 부하 확인하기</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-22T09:20:00.000Z">21-08-22</time></p><p class="title"><a href="/linux-rmq-monitoring-easy/">리눅스에서 tmux와 rabbitmqctl을 이용한 Queue 잔여 메시지 모니터링하기</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/RabbitMQ/">RabbitMQ</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-15T10:10:00.000Z">21-08-15</time></p><p class="title"><a href="/linux-new-machine-settings/">리눅스 - 클라우드 머신 세팅하기 (Naver Cloud)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/NCloud/">NCloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-25T14:55:00.000Z">21-07-25</time></p><p class="title"><a href="/linux-file-descriptor/">리눅스에서의 파일 디스크립터와 리다이렉션</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-17T14:58:00.000Z">21-07-17</time></p><p class="title"><a href="/linux-env-security/">환경 변수와 보안</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NCloud/"><span class="tag">NCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RabbitMQ/"><span class="tag">RabbitMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
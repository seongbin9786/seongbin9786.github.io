<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-03T12:00:00.000Z" title="2021-03-03T12:00:00.000Z">21-03-03</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-03T11:53:28.360Z" title="2021-03-03T11:53:28.360Z">21-03-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">8분안에 읽기 (약 1126 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-7-dependency-injection-2/">7장 의존성 주입 (2/2) - 간단한 Javascript DI 컨테이너 구현체</a></h1><div class="content"><p>이 글은 <a href="https://jsqna.com/ndp-7-dependency-injection-1/">7장 의존성 주입 (1/2)</a>에서 설명한 DI 컨테이너의 간단한 구현체를 제시한다. Javascript이기 때문에 타입 정보를 얻을 수 없어 String으로 의존성을 판단하는 부분을 참고하기 바란다. </p>
<hr>
<p>이 글의 코드는 <a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code">출처</a>에서 배포된 코드를 가져왔음을 밝힌다.</p>
<hr>
<h2 id="1-DI-컨테이너-구현"><a href="#1-DI-컨테이너-구현" class="headerlink" title="1. DI 컨테이너 구현"></a><strong>1. DI 컨테이너 구현</strong></h2><h3 id="diContainer-js"><a href="#diContainer-js" class="headerlink" title="diContainer.js"></a><strong>diContainer.js</strong></h3><p>아쉽게도 패키지 전체를 미리 스캔하여 자동으로 의존 관계를 파악하고 의존성 주입을 수행하지는 않는다. 기능은 크게 <code>get</code>, <code>factory</code>, <code>register</code>가 있다. 자세한 설명은 주석을 참고하라.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fnArgs는 함수의 인자 목록을 String 배열로 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> fnArgs = <span class="built_in">require</span>(<span class="string">&quot;parse-fn-args&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dependencies = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> factories = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> diContainer = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// factory, register 둘 다 단순 등록 기능이다.</span></span><br><span class="line">  <span class="comment">// factory 메소드의 경우 의존성 주입이 필요한 객체인 경우 사용한다.</span></span><br><span class="line">  diContainer.factory = <span class="function">(<span class="params">name, factory</span>) =&gt;</span> &#123;</span><br><span class="line">    factories[name] = factory;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register 메소드의 경우 의존성 주입이 필요 없는 객체(상수 등)를 등록할 때 사용한다.</span></span><br><span class="line">  diContainer.register = <span class="function">(<span class="params">name, dep</span>) =&gt;</span> &#123;</span><br><span class="line">    dependencies[name] = dep;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. get은 dependencies에 없는 경우 factory로 간주하고 가져옴</span></span><br><span class="line"><span class="comment">  2. 만약 가져오려 했던 객체가 존재하면 해당 객체로 inject를 호출함 (inject를 통해 재귀적으로 의존성을 resolve.)</span></span><br><span class="line"><span class="comment">  3. (2)의 결과를 dependencies에 저장</span></span><br><span class="line"><span class="comment">  4. 만약 그래도 dependencies에 없는 경우 모듈을 찾을 수 없는 것.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  diContainer.get = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dependencies[name]) &#123;</span><br><span class="line">      <span class="keyword">const</span> factory = factories[name];</span><br><span class="line">      dependencies[name] = factory &amp;&amp; diContainer.inject(factory);</span><br><span class="line">      <span class="keyword">if</span> (!dependencies[name]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Cannot find module: &quot;</span> + name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dependencies[name];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. factory로 등록된 객체를 전달받음</span></span><br><span class="line"><span class="comment">  2. fnArgs는 함수(factory의 경우, 의존성을 명시한 함수를 export 함.)의 인자를 가져옴</span></span><br><span class="line"><span class="comment">  3. 인자에 대해 map으로 get을 수행한 배열을 args 변수에 저장함</span></span><br><span class="line"><span class="comment">  4. factory(생성자)를 resolved 된 dependencies로 호출함</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  diContainer.inject = <span class="function">(<span class="params">factory</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> args = fnArgs(factory).map(<span class="function"><span class="keyword">function</span> (<span class="params">dependency</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> diContainer.get(dependency);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> factory.apply(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> diContainer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-컨테이너-사용"><a href="#2-컨테이너-사용" class="headerlink" title="2. 컨테이너 사용"></a><strong>2. 컨테이너 사용</strong></h2><h3 id="1-app-js"><a href="#1-app-js" class="headerlink" title="1. app.js"></a><strong>1. app.js</strong></h3><p>DI 컨테이너에 각 객체를 등록하는 과정을 이 파일을 진입점 삼아 수행하였다. 좀 더 좋은 DI 컨테이너라면 Reflection 등을 이용해 자동으로 mark된 객체를 등록하고 의존성 주입을 진행할 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> diContainer = <span class="built_in">require</span>(<span class="string">&quot;./lib/diContainer&quot;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// register는 추가적으로 의존성 주입이 필요 없는 객체를 등록한다. (상수 등)</span></span><br><span class="line">diContainer.register(<span class="string">&quot;dbName&quot;</span>, <span class="string">&quot;example-db&quot;</span>);</span><br><span class="line">diContainer.register(<span class="string">&quot;tokenSecret&quot;</span>, <span class="string">&quot;SHHH!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// factory는 의존성 주입이 필요한 객체를 등록한다.</span></span><br><span class="line">diContainer.factory(<span class="string">&quot;db&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;./lib/db&quot;</span>));</span><br><span class="line"><span class="comment">// Service 객체 등록 (의존성 주입 필요한 상태)</span></span><br><span class="line">diContainer.factory(<span class="string">&quot;authService&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;./lib/authService&quot;</span>));</span><br><span class="line"><span class="comment">// Controller 객체 등록 (의존성 주입 필요한 상태)</span></span><br><span class="line">diContainer.factory(<span class="string">&quot;authController&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;./lib/authController&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// get은 의존성을 반환한다. (재귀적으로 의존성 주입이 된 채로 반환된다.)</span></span><br><span class="line"><span class="keyword">const</span> authController = diContainer.get(<span class="string">&quot;authController&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Express에 Controller 등록</span></span><br><span class="line">app.post(<span class="string">&quot;/login&quot;</span>, authController.login);</span><br><span class="line">app.get(<span class="string">&quot;/checkToken&quot;</span>, authController.checkToken);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-authController-js"><a href="#2-authController-js" class="headerlink" title="2. authController.js"></a><strong>2. authController.js</strong></h3><p>의존성 주입이 적용되는 객체 1이다. 주석 참고.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Express에서 일반적으로 사용되는 Controller 예제이다.</span></span><br><span class="line"><span class="comment">// 모듈 차원에서 함수로 내보내며(DI 컨테이너 작동 방식에 맞춤), 인자에 이름으로 의존성을 명시한다.</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">authService</span>) =&gt;</span> &#123; <span class="comment">// DI 컨테이너에 의해 authService 의존성을 주입 받게 된다.</span></span><br><span class="line">  <span class="keyword">const</span> authController = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  authController.login = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    authService.login(req.body.username, req.body.password,</span><br><span class="line">      (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> res.status(<span class="number">401</span>).send(&#123;</span><br><span class="line">            ok: <span class="literal">false</span>,</span><br><span class="line">            error: <span class="string">&#x27;Invalid username/password&#x27;</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.status(<span class="number">200</span>).send(&#123;<span class="attr">ok</span>: <span class="literal">true</span>, <span class="attr">token</span>: result&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  authController.checkToken = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    authService.checkToken(req.query.token,</span><br><span class="line">      (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> res.status(<span class="number">401</span>).send(&#123;</span><br><span class="line">            ok: <span class="literal">false</span>,</span><br><span class="line">            error: <span class="string">&#x27;Token is invalid or expired&#x27;</span>  </span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.status(<span class="number">200</span>).send(&#123;<span class="attr">ok</span>: <span class="string">&#x27;true&#x27;</span>, <span class="attr">user</span>: result&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> authController;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="3-appService-js"><a href="#3-appService-js" class="headerlink" title="3. appService.js"></a><strong>3. appService.js</strong></h3><p>의존성 주입이 적용되는 객체 2이다. 주석 참고.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jwt-simple&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">&#x27;bcrypt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 역시 모듈을 함수로 내보내며 의존성을 명시했다.</span></span><br><span class="line"><span class="comment">// 이 예제에서는 db 객체에 대해선 생략하였다. (DI 설명에서 의미 없는 구성 요소)</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">db, tokenSecret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> users = db.(...);</span><br><span class="line">  <span class="keyword">const</span> authService = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  authService.login = <span class="function">(<span class="params">username, password, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    users.get(username, <span class="function">(<span class="params">err, user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      </span><br><span class="line">      bcrypt.compare(password, user.hash, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">        <span class="keyword">if</span> (!res) <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid password&#x27;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> token = jwt.encode(&#123;</span><br><span class="line">          username: username,</span><br><span class="line">          expire: <span class="built_in">Date</span>.now() + (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>) <span class="comment">//1 hour</span></span><br><span class="line">        &#125;, tokenSecret);</span><br><span class="line">        </span><br><span class="line">        callback(<span class="literal">null</span>, token);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  authService.checkToken = <span class="function">(<span class="params">token, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> userData;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      userData = jwt.decode(token, tokenSecret);</span><br><span class="line">      <span class="keyword">if</span> (userData.expire &lt;= <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Token expired&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      <span class="keyword">return</span> process.nextTick(callback.bind(<span class="literal">null</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    users.get(userData.username, <span class="function">(<span class="params">err, user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      callback(<span class="literal">null</span>, &#123;<span class="attr">username</span>: userData.username&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> authService;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>TODO:</strong></p>
<p>Node.js 스트림 이어서 포스팅하기</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-23T12:20:00.000Z" title="2021-02-23T12:20:00.000Z">21-02-23</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-03T11:50:32.780Z" title="2021-03-03T11:50:32.780Z">21-03-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">11분안에 읽기 (약 1690 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-7-dependency-injection-1/">7장 의존성 주입 (1/2) - Node.js/Javascript 환경에서의 한 패키지 내의 의존성 관리</a></h1><div class="content"><p>이 글은 Node.js/Javascript 환경에서의 <u><strong>한 패키지(App) 내의</strong></u> 모듈 간의 의존성을 관리하는 방법에 대해 다룬다. 명시하지 않은 경우 Javascript 환경임을 미리 밝힌다.</p>
<blockquote>
<p>Typescript는 지금까지 많이 활용돼왔고 생태계가 성숙한 상태이므로, OOP 방식으로 문제 해결을 하려는 경우 Typescript가 적정 기술이라고 생각한다.</p>
</blockquote>
<hr>
<p><img src="/images/ndp-7/hardcoded-import.png" alt="흔한 하드코딩 의존성(구현체 직접 import)의 예"></p>
<hr>
<h3 id="1-유독-언급이-적은-Node-js에서의-의존성-관리-왜"><a href="#1-유독-언급이-적은-Node-js에서의-의존성-관리-왜" class="headerlink" title="1. 유독 언급이 적은 Node.js에서의 의존성 관리, 왜?"></a><strong>1. 유독 언급이 적은 Node.js에서의 의존성 관리, 왜?</strong></h3><p>백엔드와 같이 쉽고 빠르게 규모가 커지고 기능 변경이 잦은 코드 베이스인 경우 설계가 중요한 경우가 많을 것이다. 설계는 의존성 관리가 기본이며 Node.js 백엔드 또한 그 예외는 아닐 것인데 말이다.</p>
<p><strong>Q.</strong> 왜 Node.js에서는 <u>하드 코딩된 의존 관계</u>를 구축하는 코드를 찾기가 매우 쉬울까?</p>
<p><strong>A. 가설:</strong> 인터페이스와 상관 없이 임의의 객체를 집어 넣어 테스트를 할 수 있기 때문에 굳이 Interface가 필요하지 않다. <u>동적 타입 언어</u>이니까.</p>
<hr>
<h3 id="2-“동적-타입-언어”라는-특징"><a href="#2-“동적-타입-언어”라는-특징" class="headerlink" title="2. “동적 타입 언어”라는 특징"></a><strong>2. “동적 타입 언어”라는 특징</strong></h3><h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a><strong>장점</strong></h4><p>만약 Java 였다면 Interface를 아예 사용하지 않는 것은 설계에 큰 문제가 있음을 시사하는 것이겠지만 <u>Javascript는 동적 타입 언어</u>이다. 기능을 실행하는 객체의 타입이 중요하지 않은 언어이다. 인터페이스가 없는 만큼 규칙도 없지만 그만큼 유연해진 셈이다.</p>
<h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a><strong>단점</strong></h4><p>다만 동적 타입을 활용해 테스트가 가능하다고 해도 자연스럽게 생기는 강한 결합이 사라지는 것은 아니다. <u>구현체에 직접 의존하면 강한 결합이 발생</u>한다. 의존하는 객체의 구현 상세에 대한 아무런 격리 장치가 없으며 구현체에서 변경이 생겼을 때 해당 의존성을 사용하는 모든 객체에 그 여파가 전달되므로 다시 검증(테스트), 빌드해야만 한다. </p>
<hr>
<h3 id="3-OOP의-문제-해결-방식"><a href="#3-OOP의-문제-해결-방식" class="headerlink" title="3. OOP의 문제 해결 방식"></a><strong>3. OOP의 문제 해결 방식</strong></h3><p>OOP 에서는 인터페이스를 미리 정의하고 해당 인터페이스를 최대한 변경하지 않음(Open Close Principle)을 통해 문제를 해결한다. 인터페이스에 의존함을 통해 구현 상세와 사용 객체를 진정으로 격리시킬 수 있으며 이는 의존성 관리에 매우 큰 역할을 한다.</p>
<p>의존성에 의한 강한 결합을 막는 수단은 현재로썬 서비스 로케이터 패턴과 의존성 주입이 있다. </p>
<p>이제부터 이 글은 Javascript/Node.js 에서의 의존성 주입에 대해 다룬다.</p>
<hr>
<h3 id="4-서비스-로케이터-패턴"><a href="#4-서비스-로케이터-패턴" class="headerlink" title="4. 서비스 로케이터 패턴"></a><strong>4. 서비스 로케이터 패턴</strong></h3><p>서비스 로케이터 패턴이란 “<strong>의존성이 있는 각 객체가 서비스 로케이터 객체만을 직접 의존하고, 각 객체는 서비스 로케이터에 의존성을 명시해 구현체를 받아오는 것</strong>“을 말한다. (서비스 로케이터 패턴에 대해 더 자세히 알고 싶다면 <a target="_blank" rel="noopener" href="https://edykim.com/ko/post/the-service-locator-is-an-antipattern/#%EC%A0%95%EB%A6%AC">이 글</a>을 참고하라.)</p>
<p>아래 예는 AuthController가 AuthService에 의존하는 코드이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AuthController.js - AuthService에 의존한다.</span></span><br><span class="line"><span class="comment">// AuthController는 ServiceLocator에만 &#x27;직접&#x27; 의존한다.</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">serviceLocator</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> authService = serviceLocator.get(<span class="string">&#x27;authService&#x27;</span>); <span class="comment">// TS 등 정적 타입 언어에서는 타입으로 받아온다.</span></span><br><span class="line">  <span class="comment">// Javascript는 딱히 타입이 없으므로 String으로 의존성(객체)을 식별한다.</span></span><br><span class="line">  <span class="comment">// require()와 사용 방식이 매우 닮아있다. 차이가 있다면, require는 전체 경로를 명시한다는 점이다.</span></span><br><span class="line">  <span class="keyword">const</span> authController = &#123;&#125;;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="서비스-로케이터-패턴의-장점"><a href="#서비스-로케이터-패턴의-장점" class="headerlink" title="서비스 로케이터 패턴의 장점"></a><strong>서비스 로케이터 패턴의 장점</strong></h4><p>의존성의 구현체에 의존하지 않게 해준다. 이는 의존성 주입과 동일한 장점이며 아주 좋은 장점이다.</p>
<h4 id="서비스-로케이터-패턴의-단점"><a href="#서비스-로케이터-패턴의-단점" class="headerlink" title="서비스 로케이터 패턴의 단점"></a><strong>서비스 로케이터 패턴의 단점</strong></h4><p>객체의 구현 코드를 보지 않으면 곧바로 의존 관게를 파악할 수 없다. 생성자 등으로 명시하지 않기 때문에 - 생성자의 파라미터로 명시한다면 필수값이라는 문서화의 역할을 수행하게 되는데 비해 - 모든 객체에 대해 문서화가 필요하다.</p>
<hr>
<h3 id="5-의존성-주입"><a href="#5-의존성-주입" class="headerlink" title="5. 의존성 주입"></a><strong>5. 의존성 주입</strong></h3><p>의존 관계를 가장 잘 다루는 방법은 아마도 <u>DI</u>일 것이다. Javascript 진영에선 Angular가 최초로 의존성 주입을 도입한 것으로 안다(Typescript도 없던 시절이었는데!).</p>
<p>의존성 주입이란 “<strong>모듈의 의존성을 외부 개체에 의해 입력으로 전달 받는 것</strong>“을 말한다.  의존성 주입의 개념 자체는 매우 간단하다. DI를 지원하기 위한 컨테이너와 지원 방식을 구현하는 게 어려울 뿐이다. </p>
<p>(ex) AuthController가 AuthService에 의존하는 경우의 예시를 확인하자.</p>
<p>Before DI: 구현체를 직접 가져오는 모듈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 직접 가져온다.</span></span><br><span class="line"><span class="keyword">const</span> authService = <span class="built_in">require</span>(<span class="string">&#x27;./authService&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.login = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  authService.login(...);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>After DI: 의존성을 받아오는 모듈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authService를 전달 받아서 사용한다. authService의 출처와 구현체에 대해 아는 것은 더 이상 이 객체의 책임이 아니다. 그냥 사용만 하면 된다.</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">authService</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> authController = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  authController.login = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    authService.login(req.body.username, req.body.password, ...);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> authController</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Service Locator / DI Container의 간략한 구현도 포함하려고 했으나 2편에서 다루도록 하겠다.</p>
</blockquote>
<hr>
<h3 id="6-Node-js의-DI-컨테이너-생태계"><a href="#6-Node-js의-DI-컨테이너-생태계" class="headerlink" title="6. Node.js의 DI 컨테이너 생태계"></a><strong>6. Node.js의 DI 컨테이너 생태계</strong></h3><p>약간의 짬을 내어 찾아보니 크게 4개의 오픈소스 컨테이너들이 있었다: <a target="_blank" rel="noopener" href="https://github.com/inversify/InversifyJS">InversifyJs</a>, <a target="_blank" rel="noopener" href="https://github.com/microsoft/tsyringe">tsyringe</a>, <a target="_blank" rel="noopener" href="https://github.com/typestack/typedi">typedi</a>, <a target="_blank" rel="noopener" href="https://github.com/jeffijoe/awilix">awilix</a> (점유율 순). </p>
<blockquote>
<p>tsyringe는 Microsoft에서 만들었다. 재밌는 점은 MS에서 inversifyjs를 사용한다고 나와있는 것이다. NestJs는 DI를 Core에 내장하여 차트에 포함시켰다.</p>
</blockquote>
<p><img src="/images/ndp-7/di-container-comp-chart.png" alt="dif"></p>
<p>각 라이브러리의 자세한 비교는 기회가 된다면 추후 진행하려 한다.</p>
<hr>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><strong>TODO:</strong></h4><ol>
<li>Clean Architecture를 다시 읽는다. SOLID 원칙 조차 희미해진 듯하다.</li>
<li>DI와 DIP의 관계에 대해 다시 공부해야겠다.</li>
<li>양파 껍질 Architecture에 대해 제대로 이해해야겠다.</li>
<li><code>require</code>과 서비스 로케이터 패턴의 관계에 대해 이해해야겠다.</li>
</ol>
<p>CS에서 가장 자신있던 객체지향을 이렇게 모르게 됐다는 게 새삼 충격적이다 :(</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-02T12:20:00.000Z" title="2021-02-02T12:20:00.000Z">21-02-02</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-02-02T12:06:31.340Z" title="2021-02-02T12:06:31.340Z">21-02-02</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/ExpressJs/">ExpressJs</a></span><span class="level-item">14분안에 읽기 (약 2162 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ejs-1-why-express-2/">Express를 사용해야 할 이유 (2) - Microframework</a></h1><div class="content"><p>이 글은 microframework라는 개념과 express의 용도를 연관지어 <u>생각</u>해본다. 이 글은 기술적으로 사실이라고 검증되지 않은 내용이 포함되며 데이터에 근거한 결론보다 생각 위주로 작성됨을 미리 알린다.</p>
<hr>
<p>대략 2주 전 <a href="https://jsqna.com/ejs-1-why-express/">Express를 사용해야 할 이유 (1)</a>을 쓰면서 왜 Express를 많이 쓰는걸까? 생각을 많이 해봤지만 결론을 내리지 못 했다. 아래는 당시 글에 작성했던 intro이다.</p>
<blockquote>
<p>잠시나마 사용해본 Express는 내게 React 같았다. 무엇이든 할 수 있어 보였으나 직접 하기에는 매우 불편하고, 그러다보니 REST API를 작성할 때 이런 것까지 해야 돼? 혹은 이런 기능이 없어서 불편하네 등이 많았는데…</p>
</blockquote>
<p>오늘이 되어서야 왜 Express가 기능이 적은지 알게 되었는데, 그 마법의 키워드는 바로 <em>Microframework</em>이다. (진지하게 이 키워드에 대해 오늘 이전에 들어본 적이 단 한 번도 없었다.)</p>
<h3 id="Microframework란"><a href="#Microframework란" class="headerlink" title="Microframework란?"></a><strong>Microframework란?</strong></h3><p><strong>1. 정의</strong>: <u>최소 기능을 갖는</u> 웹 애플리케이션 프레임워크 &lt;-&gt; full-fledged framework (필요한 기능은 대부분 갖춘 프레임워크를 의미)</p>
<p><strong>2. 기능</strong>: Microframework는 서비스 개발 시 “<u>주로</u>“, “<u>일반적으로</u>“ 사용되는 공통적인 기능들을 제공하지 않는다. 제공하지 않는다는 그 기능들이란 대체로 아래와 같다.</p>
<ul>
<li>인증, 인가</li>
<li>ORM 혹은 DB 관련 기능</li>
<li>입력값 검증 / 보안 (Validation, Sanitation)</li>
<li>템플릿 엔진</li>
</ul>
<p><strong>3. 목적</strong>: Microframework는 작은 API 서버를 제작하는게 목적이다.</p>
<p>정리하자면 Microframework는 기능의 다양성이나 설계의 편리성보다 기능의 단순성이 더 우선된 프레임워크이다.</p>
<p>따라서 규모 있게 Monolith로 제작하는 경우 full-fledged framework를 사용하는 게 맞다고 본다. 실제로 Walamrt는 Node.js 기반으로 백엔드를 구성했지만 Commerce 기업이라 Hapi.js(full-fledged framework)를 직접 만들어서 사용하기도 하고 말이다. </p>
<hr>
<h4 id="Microframework의-종류"><a href="#Microframework의-종류" class="headerlink" title="Microframework의 종류"></a><strong>Microframework의 종류</strong></h4><p>아래는 주요 언어의 Microframework의 목록의 일부다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Express.js">Express.js</a> for Node.js</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Flask_(web_framework)">Flask</a> for Python</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sinatra_(software)">Sinatra</a> for Ruby</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spark_(software)">Spark</a> for Java (NOT Apache Spark)</li>
</ul>
<p>(더 많은 목록은 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microframework">위키 백과 Microframework 문서 (EN)</a>를 참고 바람.)</p>
<p>예상한 대로 <a target="_blank" rel="noopener" href="http://expressjs.com/">Express.js</a>도 microframework로 등재돼있다. Express 소개문에 “<em>Fast, unopinionated, <u>minimalist</u> web framework for Node.js</em>“ 라고 괜히 되어 있는 것이 아니다.</p>
<p>Netflix에서는 Restify라는 프레임워크를 예전부터 사용 중인데, <a target="_blank" rel="noopener" href="https://stackshare.io/restify">Restify도 Microframework이다</a>. Restify는 Semantically correct RESTful 을 지향한다. 온전히 REST API를 위한 기능만 제공하므로 Express 등에서 제공하는 템플릿 엔진 조차 없는데 기능의 단순함 측면에서 더 매력적이라고 할 수 있다. Restify는 또한 Connect 미들웨어를 지원하므로 Express 미들웨어와 호환된다.</p>
<p>아래는 <a target="_blank" rel="noopener" href="https://restify.com/">Restify 공식 홈페이지</a>에 나와있는 소개이다.</p>
<blockquote>
<p>Meet Restify - A Node.js web service framework optimized for building semantically correct RESTful web services ready for production use at scale. restify optimizes for introspection and performance, and is used in some of the largest Node.js deployments on Earth.</p>
</blockquote>
<hr>
<h3 id="Microframework가-Microservices에-좋을까"><a href="#Microframework가-Microservices에-좋을까" class="headerlink" title="Microframework가 Microservices에 좋을까?"></a><strong>Microframework가 Microservices에 좋을까?</strong></h3><blockquote>
<p> 아직 MSA에 대해 공부한 적 없기도 하고 이런 지식들이 쉬운 편이 아니라 좀 배워야 키워드 검색이 가능하기 때문에 Youtube와 여러 글들을 읽어보면서 느낀 점을 적으려 한다.</p>
</blockquote>
<p>왜 restify를 사용하는지 추측해보자면 굉장히 많은 컨테이너에서 돌아가는 MSA를 구축할 때 작은 서비스가 유리하기 때문이 아닐까?  Netflix는 (다른 기업들이 응당 그러하듯) MSA로 개발할 때 기능 단위로 분리하는데, Monolithic Service에 들어갈 많은 기능들이 기본 제공되지 않는 프레임워크가 <u>가벼워지는데</u> 유리한 것이다. (Netflix는 의사 결정 시 성능에 우선순위를 두는 듯 하다. 13년도에 Java에서 Node.js로의 이주를 시작한 것만 봐도.)</p>
<hr>
<h3 id="Node-js를-쓰는-대부분의-use-case가-microframework가-필요해서일까"><a href="#Node-js를-쓰는-대부분의-use-case가-microframework가-필요해서일까" class="headerlink" title="Node.js를 쓰는 대부분의 use case가 microframework가 필요해서일까?"></a><strong>Node.js를 쓰는 대부분의 use case가 microframework가 필요해서일까?</strong></h3><p><a href="https://jsqna.com/ejs-1-why-express/">이전 글</a> 내용 중 다운로드 수를 비교한 자료가 있었는데 Express가 압도적이었다. 같은 microframework이며 <a target="_blank" rel="noopener" href="https://www.fastify.io/benchmarks/">벤치마크(hello world)도 더 우수한</a> Koa가 그렇게 많이 사용되지 않는 점(약 21배 차이)은 이전 글에서도 다뤘듯 async/await 문법의 지원과 커뮤니티의 차이 때문임으로 보인다. </p>
<blockquote>
<p>다운로드 수에 대한 요즘 생각:</p>
<ol>
<li><p>러닝 커브. 많은 사람들이 Javascript가 배우기 쉽다고 말하며 그렇게 진입하는 사람이 적지 않다. 그저 React.js와 Express.js를 기초적인 수준에서 사용하는데 머무는 사람들이 정말 많다고 생각한다.</p>
</li>
<li><p>Netflix처럼 애초에 Managed로 환경 구성이 잘 된 경우라면 npm에서 다운로드 수 집계가 제대로 되지 않을 것 같다. (Proxy를 통한 캐싱 등) 즉 npm 다운로드가 현업 개발 시의 실제 사용 빈도를 정확히 나타내는 것도 아닐 수 있을 것이다.</p>
</li>
</ol>
<p>따라서 단순히 npm 다운로드 수로 비교하는 것보단 실제로 돈을 벌고 많은 트래픽을 처리하는 기업에서 무슨 스택을 사용하는지가 더 중요할 것으로 보인다.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Hapi</th>
<th align="left">Koa</th>
<th align="left">Nest</th>
<th align="left">Express</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://jsqna.com/images/ejs-1/hapi.png"><img src="https://jsqna.com/images/ejs-1/hapi.png" alt="img"></a></td>
<td align="left"><a href="https://jsqna.com/images/ejs-1/koa.png"><img src="https://jsqna.com/images/ejs-1/koa.png" alt="img"></a></td>
<td align="left"><a href="https://jsqna.com/images/ejs-1/nest.png"><img src="https://jsqna.com/images/ejs-1/nest.png" alt="img"></a></td>
<td align="left"><a href="https://jsqna.com/images/ejs-1/express.png"><img src="https://jsqna.com/images/ejs-1/express.png" alt="img"></a></td>
</tr>
</tbody></table>
<p>(참고로 restify는 12만, fastify는 19만 정도 된다. - fastify의 경우 Nest.js에서 사용되는 면이 있으니 참고)</p>
<hr>
<h4 id="다운로드-수를-유일한-척도로-삼고-맹신해서는-안-될-것-같다"><a href="#다운로드-수를-유일한-척도로-삼고-맹신해서는-안-될-것-같다" class="headerlink" title="다운로드 수를 유일한 척도로 삼고 맹신해서는 안 될 것 같다."></a><strong>다운로드 수를 유일한 척도로 삼고 맹신해서는 안 될 것 같다.</strong></h4><p>Express의 점유율이 매우 높다는 것을 microframework를 사용하는 숫자가 Node.js 백엔드 개발자 중에서 대다수라고 받아들이면 안 될 듯하다. Netflix의 경우는 MSA를 도입했기 때문이지만 트래픽이 많지 않은 기업들의 경우 아직 Monolithic이거나 작은 규모의 분산 시스템이면 충분할 거라고 생각하기 때문이다.</p>
<p>Node.js의 경우 … </p>
<ul>
<li>Javascript를 프론트엔드와의 공용어로 사용할 수 있다는 점</li>
<li>SSR 시 코드 재사용이 가능하다는 점</li>
<li>백엔드 언어와 Javascript 간의 Context Switching이 사라진다는 점</li>
<li>Interpreter 언어여서 Startup이 매우 빠르다는 점</li>
<li>모듈 생태계가 크다는 점이 장점</li>
</ul>
<p>이런 장점 속에서 굳이 프레임워크에서 가치를 찾지 않으려는 경우도 많지 않을까?</p>
<p>다운로드 수가 많다고 해서 Express를 사용할 이유는 없다. 1편에서도 밝혔듯이 Javascript와 Node.js의 장점 자체도 이미 많으며 Express에서 조금 고생하면서 Monolithic 서비스 개발하는 것은 점진적으로 러닝 커브가 올라가는 형태라고 생각하고, 딱 그 정도 수준이 필요한 기업도 많을 거라고 생각한다.</p>
<h3 id="아직-결론은-내릴-수-없을-것-같다"><a href="#아직-결론은-내릴-수-없을-것-같다" class="headerlink" title="아직 결론은 내릴 수 없을 것 같다."></a><strong>아직 결론은 내릴 수 없을 것 같다.</strong></h3><p>아직 Node.js의 정수를 다 배우지 못 했기 때문에, 아직 MSA를 배우지 못 했기 때문에 정확한 판단을 내릴 수가 없다. 이것들을 어느 정도 습득하고 나서 정말 왜 Express가, Express만이 이렇게 잘 팔리는 이유를 분석할 수 있으면 좋겠다.</p>
<hr>
<h3 id="What-I-Learned"><a href="#What-I-Learned" class="headerlink" title="What I Learned"></a><strong>What I Learned</strong></h3><ol>
<li><p>Netflix는 <a target="_blank" rel="noopener" href="https://netflixtechblog.com/">기술 블로그</a>와 컨퍼런스를 통해 정말 많은 기술적인 내용들을 공유한다는 걸 오늘 리서치하면서 배웠다. Youtube의 경우 여러 채널에 Video가 산재돼있는데 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=CZ3wIuvmHeM&list=PLqXBqaWzmb_c0d3jHhxk8cF0ldP6EGfvL">이 Playlist</a>가 좋은 것 같다.</p>
</li>
<li><p>아직도 Node.js 생태계에 대해 제대로 이해하지 못 하고 있다는 점을 또 알게됐다. 아직 해결되지 못한 질문들에 대해 데이터를 찾아서 반드시 답을 내리고 싶다.</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-01T09:00:00.000Z" title="2021-02-01T09:00:00.000Z">21-02-01</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-03T11:53:48.260Z" title="2021-03-03T11:53:48.260Z">21-03-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">12분안에 읽기 (약 1828 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-5-stream-1/">5장 Stream API (1/3) - 스트림 개요 및 Readable Stream</a></h1><div class="content"><p>이 글은 Node.js 디자인 패턴 CH 05 스트림 코딩의 일부를 참고해서 작성하였다. 이번 글은 Stream API에 대해 깊이 다루기보다 스트림 자체에 대해 다룬다.</p>
<hr>
<h3 id="스트림-개요"><a href="#스트림-개요" class="headerlink" title="스트림 개요"></a><strong>스트림 개요</strong></h3><p>스트림은 파일을 버퍼 단위로 옮겨서 전부 옮길 때까지 기다린 후 처리하기보다 매 버퍼 단위로 전송하는 방식이다.</p>
<p>스트림은 본질적으로 비동기 패러다임으로, <u>기다린 후</u> 처리하는 Sync 방식에 대비된다. 물론 <code>fs.readFile</code> 역시 Node.js 런타임에서 I/O를 처리해주니 스레드가 Block 되진 않겠지만, 애초에 <u>I/O 수준에서도 기다릴 일이 없게</u> 하는 것이 처리량에서 우위이지 않을까? </p>
<p>(처리량에서 정말 우위일지는 잘 모르겠다. 스트리밍 오버헤드에 대해 공부해본 적이 없기 때문.)</p>
<h3 id="스트림의-공간-효율성"><a href="#스트림의-공간-효율성" class="headerlink" title="스트림의 공간 효율성"></a><strong>스트림의 공간 효율성</strong></h3><p>스트림은 메모리에 파일의 전체 내용을 올리지 않고 버퍼의 크기만큼만 메모리를 할당하기 때문에 공간 효율적이다. 더 좋은 점은 <u>파일의 크기에 상관 없이</u> 일정한 양의 메모리를 점유한다는 점이다.</p>
<blockquote>
<p>이것과 별개로 V8 엔진은 32bit 기준 ~1GB, 64bit 기준 ~1.7GB 정도의 메모리만 사용하도록 설정돼있어(더 높이려면 빌드해야 함.) 파일이 큰 경우 전체 파일을 한 번에 메모리에 올릴 수 없음.</p>
</blockquote>
<hr>
<p>공간 비효율적인 파일 압축 코드 (ex: example.tar -&gt; example.tar.gz)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">fs.readFile(file, <span class="function">(<span class="params">err, buffer</span>) =&gt;</span> &#123;</span><br><span class="line">  zlib.gzip(buffer, <span class="function">(<span class="params">err, buffer</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.writeFile(file + <span class="string">&#x27;.gz&#x27;</span>, buffer, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;File successfully compressed&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>공간 효율적인 파일 압축 코드 (Stream API)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파일을 읽는데에 buffer 크기만큼만 메모리를 점유하기 때문에 공간 효율적</span></span><br><span class="line"><span class="comment">// pipe 체이닝으로 각 chunk에 대해 이런 저런 처리를 할 수 있음.</span></span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(fs.createWriteStream(file + <span class="string">&#x27;.gz&#x27;</span>))</span><br><span class="line">  .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;File successfully compressed&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>참고로 gzip이 어떻게 스트림에 대해 동작하는지 궁금하다면 아래 글들을 참고해보면 좋을 것 같다.</p>
<p><a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/393834/how-is-it-possible-to-gzip-a-stream-before-the-entire-contents-are-known">How is it possible to GZIP a stream before the entire contents are known? | StackOverFlow</a> </p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19700503/how-does-gzip-compression-rate-change-when-streaming-data">How does gzip compression rate change when streaming data? | StackOverFlow</a></p>
<hr>
<h3 id="스트림의-시간-효율성"><a href="#스트림의-시간-효율성" class="headerlink" title="스트림의 시간 효율성"></a><strong>스트림의 시간 효율성</strong></h3><p>Stream은 TTFB(Time to First Byte)에 강점이 있는데, TTFB는 파일의 크기에 비례하여 빠를 수 밖에 없다. 파일의 크기가 클 수록 읽는 데 대기시간이 필요하지만 Stream은 곧바로 응답을 보내기 시작하기 때문이다.</p>
<blockquote>
<p>웹에서 TTFB는 매우 중요하다.</p>
<p>자세한 건 <a target="_blank" rel="noopener" href="https://github.com/vercel/next.js/issues/1209">Next.js의 재밌는 이슈(Stream rendering to reduce TTFB and CPU load)</a> 참고.</p>
</blockquote>
<h4 id="파일을-단위로-전송하는-Server-Client-모델"><a href="#파일을-단위로-전송하는-Server-Client-모델" class="headerlink" title="파일을 단위로 전송하는 Server-Client 모델"></a><strong>파일을 단위로 전송하는 Server-Client 모델</strong></h4><p>다음의 사이클을 단 1회 거치게 된다: read &gt; compress &gt; send &gt; receive &gt; decompress &gt; write</p>
<hr>
<h4 id="chunk-단위로-전송하는-Server-Client-모델"><a href="#chunk-단위로-전송하는-Server-Client-모델" class="headerlink" title="chunk 단위로 전송하는 Server-Client 모델"></a><strong>chunk 단위로 전송하는 Server-Client 모델</strong></h4><p>위의 사이클을 매 chunk마다 거치게 되므로 파이프라이닝과 같은 형태로 병렬 처리가 가능하다. 물론 chunk의 크기마다 다르겠지만 각 단계를 거치는 만큼 오버헤드가 있을 것이다. (HTTP header 등. 이 부분에 대해선 잘 알지 못한다.)</p>
<blockquote>
<p> Node.js 동시성을 활용하는 것이므로 순서를 맞춰줘야 하는데 Stream API가 알아서 처리한다고 한다. </p>
</blockquote>
<hr>
<p>아래는 파일을 전송하는 스트림 예제 코드이다.</p>
<p><strong>client</strong>: 파일을 받아 디스크에 쓰는 역할</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = req.headers.filename;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;File request received: &#x27;</span> + filename);</span><br><span class="line">  req</span><br><span class="line">    .pipe(zlib.createGunzip())</span><br><span class="line">    .pipe(fs.createWriteStream(filename))</span><br><span class="line">    .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span> <span class="comment">/* CREATED */</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">      res.end(<span class="string">&#x27;That\&#x27;s it\n&#x27;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;filename&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Listening&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>server</strong>: 파일을 읽고 전송하는 역할</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> server = process.argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  hostname: server,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    filename: path.basename(file),</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/octet-stream&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Encoding&#x27;</span>: <span class="string">&#x27;gzip&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = http.request(options, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server response: &#x27;</span> + res.statusCode);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;File successfully sent&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="스트림의-문제-해결력"><a href="#스트림의-문제-해결력" class="headerlink" title="스트림의 문제 해결력"></a><strong>스트림의 문제 해결력</strong></h3><p>스트림은 Composition으로 문제 해결을 한다. Express Middleware와 같이 마음껏 파이프라인을 만들어낼 수 있다. </p>
<ul>
<li>파이프라인은 각 기능 간에 결합이 없기 때문에 항상 1차원으로 코드가 <u>표현</u>된다. (분기가 없다는 게 아니라 가독성이 좋다는 것.)</li>
<li>선언형으로 프로그래밍하기 수월하다. 선언형 패러다임은 코드를 요약해서 바라볼 수 있기 때문에 쉽게 이해하기 좋다.</li>
</ul>
<blockquote>
<p>스트림을 기반으로 비동기 이벤트를 처리하는 패러다임을 Reactive라고 하고 이를 위한 RxJS가 있다.</p>
</blockquote>
<p>(ex) 암호화 기능 추가</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 복호화</span></span><br><span class="line">.pipe(crypto.createDecipheriv(<span class="string">&quot;aes-192-gcm&quot;</span>, <span class="string">&quot;a_shared_secret&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 암호화</span></span><br><span class="line">.pipe(crypto.createCipheriv(<span class="string">&quot;aes-192-gcm&quot;</span>, <span class="string">&quot;a_shared_secret&quot;</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Node-js에서-지원하는-스트림"><a href="#Node-js에서-지원하는-스트림" class="headerlink" title="Node.js에서 지원하는 스트림"></a><strong>Node.js에서 지원하는 스트림</strong></h3><p>Node.js가 지원하는 스트림은 EventEmitter 객체를 상속하며 binary, 문자열 뿐만 아니라 거의 모든 Javascript의 값을 읽을 수 있다. 이러한 스트림에는 크게 네 종류가 있는데 이번 글에서는 (글이 길어지는 관계로) Readable만 다룬다.</p>
<ul>
<li>Readable, Writable, Duplex, Transform</li>
</ul>
<hr>
<h4 id="1-Readable"><a href="#1-Readable" class="headerlink" title="1. Readable"></a><strong>1. Readable</strong></h4><p>Readable 스트림은 외부에서 읽기 위한 스트림으로, 자신이 가진 값을 chunk로 써서 내보내는 역할이다. </p>
<blockquote>
<p>사용 예:</p>
<p><code>readable</code> 이벤트에 listener를 등록하고 이벤트 발생 시 버퍼에 있는 내용을 모두 읽기</p>
</blockquote>
<blockquote>
<p>API로는 아래의 함수가 있다.</p>
<p><code>readable.read([size]) // read는 동기 함수이다.</code></p>
</blockquote>
<p>(ex) 표준 입력(stdin) 받아서 표준 출력(<code>console.log</code>, <code>stdout.write</code>)하기</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">&#x27;readable&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;New data available&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Chunk read: (<span class="subst">$&#123;chunk.length&#125;</span>) &quot;<span class="subst">$&#123;chunk.toString()&#125;</span>&quot;`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> process.stdout.write(<span class="string">&#x27;End of stream&#x27;</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Stream v1, v2에 따라 non-flowing mode, flowing mode 로 나뉘는데 어차피 v1은 사용되지 않으므로 설명을 생략한다.</p>
</blockquote>
<hr>
<h4 id="ReadableStream을-하나-새로-만드는-예제"><a href="#ReadableStream을-하나-새로-만드는-예제" class="headerlink" title="ReadableStream을 하나 새로 만드는 예제"></a><strong>ReadableStream을 하나 새로 만드는 예제</strong></h4><p>지금까지는 <code>fs</code>, <code>http</code>의 스트림을 그대로 사용했지만 직접 ReadableStream을 만들어 활용할 수도 있다. </p>
<p><code>stream.Readable</code>을 상속해 abstract function인 <code>_read([size])</code>(public 인터페이스인 <code>read</code>와 헷갈리면 안 된다)를 구현하면 ReadableStream 객체를 하나 만들 수 있다.</p>
<p>구현을 위해 <code>push(data[, encoding])</code> 함수를 호출해 내부 버퍼에 값을 쓸 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Chance = <span class="built_in">require</span>(<span class="string">&#x27;chance&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1] 생성</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_read</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Pushing chunk of size: <span class="subst">$&#123;chunk.length&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">this</span>.push(chunk, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123; </span><br><span class="line">      <span class="built_in">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2] 사용</span></span><br><span class="line"><span class="keyword">const</span> RandomStream = <span class="built_in">require</span>(<span class="string">&#x27;./randomStream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> RandomStream();</span><br><span class="line"></span><br><span class="line">randomStream.on(<span class="string">&#x27;readable&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> chunk;</span><br><span class="line">  <span class="keyword">while</span>((chunk = randomStream.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received: <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>나머지 스트림 종류 다루기</p>
<p>백 프래셔</p>
<p>스트림 기반 비동기 제어</p>
<p>Pipe Composition</p>
<p>멀티 플렉싱, 디멀티 플렉싱</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-28T06:05:00.000Z" title="2021-01-28T06:05:00.000Z">21-01-28</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-28T06:06:43.740Z" title="2021-01-28T06:06:43.740Z">21-01-28</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a><span> / </span><a class="link-muted" href="/categories/Frontend/React-js/">React.js</a></span><span class="level-item">14분안에 읽기 (약 2159 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/atomic-design-1/">Atomic Design - 1 Intro</a></h1><div class="content"><p>이 글은 Atomic Design의 목적과 활용에 대해 간단하게 다룬다. 이후 시리즈에서는 실제 적용 예시를 다루고자 한다.</p>
<hr>
<h3 id="목적"><a href="#목적" class="headerlink" title="목적"></a><strong>목적</strong></h3><p>현대 프론트엔드는 두 가지 복잡성을 맞이했는데, Atomic Design은 이 문제를 해결하는데 효과적이다.</p>
<ul>
<li><p>이전에 비해 다양한 해상도를 지원해야 함.</p>
</li>
<li><p>UI 컴포넌트의 종류가 다양해지고 복잡해짐. 많은 상태를 갖게 됨.</p>
</li>
</ul>
<hr>
<p>즉 유지보수 비용이 크게 늘어난 상태이다. 소프트웨어 개발에서 복잡성을 낮추는 방식은 분할 정복과 의존성 격리를 통한 SRP 만족인데, Atomic Design은 프론트엔드의 구성 요소를 디자인 수준에서 분할하므로, 개발자는 이를 재사용하여 총 개발 비용을 낮출 수 있다.</p>
<p>기존에도 HTML, CSS 수준에서 컴포넌트 개발이 어느 정도 가능했으나 React.js의 등장 후 CSS-in-JS 라는 생태계가 조성된 덕분에 컴포넌트 개념의 완전한 구현이 가능해졌기 때문에 Atomic Design이 더 많이 언급되고 활용되는 듯하다.</p>
<hr>
<p>현대에는 <a target="_blank" rel="noopener" href="https://uxdesign.cc/everything-you-need-to-know-about-design-systems-54b109851969">디자인 시스템 (EN)</a>을 사용하는 것이 일반적인데, 디자인 시스템이란 브랜딩 디자인, 컴포넌트를 위한 스타일 가이드, 컴포넌트 등으로 구성된 디자인 &amp; 추상적인 개념의 집합이다. </p>
<p>이런 디자인 시스템의 Typo, Spacing 등을 포함해 컴포넌트를 라이브러리로 개발해놓으면, 전사적으로 디자인이 통일성을 갖게 되기도 하고 개발 측면에선 이미 개발된 디자인 요소를 빠르게 선언적으로 활용할 수 있기 때문에 생산성에 많이 유리하다. </p>
<ul>
<li>이미 널리 알려진 디자인 시스템의 라이브러리 또한 많다. 아무래도 Material Design의 구현체인 <a target="_blank" rel="noopener" href="https://material-ui.com/">Material-UI</a>가 가장 유명할 것이다.</li>
</ul>
<hr>
<p>Atomic Design의 접근 방식은 디자인 시스템을 구축하는 데 효과적이므로 많이 사용된다. 이후에 Atomic Design이 어떻게 개발 과정에서 유용하게 사용되는지 설명한다.</p>
<h3 id="이론"><a href="#이론" class="headerlink" title="이론"></a><strong>이론</strong></h3><p>가장 큰 개념으로 페이지, 컴포넌트가 있다. 컴포넌트가 조합돼 페이지를 구성하는 형태이다.</p>
<p>컴포넌트는 조합되므로 재사용된다. 즉 효율적이며 페이지 간 일관성 또한 보장된다.</p>
<p>컴포넌트는 아래의 4개의 하위 요소로 나뉜다. (작은 순으로 정렬)</p>
<ul>
<li>원자 (Atom)</li>
<li>분자 (Molecule)</li>
<li>유기체 (Organism)</li>
<li>템플릿 (Template)</li>
</ul>
<hr>
<h4 id="원자-Atom"><a href="#원자-Atom" class="headerlink" title="원자 (Atom)"></a><strong>원자 (Atom)</strong></h4><p>더 분해할 수 없는 가장 작은 요소이다. 아주 작은 기능도 Atom의 조합으로 만들어지는, 콘텐츠로서의 구체성은 없다.</p>
<p>(ex) 검색 폼: { <u>검색 Text, 검색 Input 바, 전송 버튼</u> } 이라는 Atom의 조합으로 생성 (여기서 어떻게 조합하는지는 또 별개의 정보.)</p>
<p>종류:</p>
<ul>
<li>버튼</li>
<li>텍스트 인풋, 색 팔레트, …</li>
<li>타이포그래피, 제목 (h1, h2, h3, …)</li>
<li>아이콘</li>
<li>체크박스, 라디오 버튼</li>
</ul>
<hr>
<h4 id="분자-Molecule"><a href="#분자-Molecule" class="headerlink" title="분자 (Molecule)"></a><strong>분자 (Molecule)</strong></h4><p>분자는 원자들의 조합을 그 단위로 한다. 분자부터 콘텐츠로서의 구체성이 있다.</p>
<p>(ex) <u>검색 폼</u>: { 검색 Text, 검색 Input 바, 전송 버튼 } 이라는 구체적인 목적이 있는 요소.</p>
<p>분자는 원자들의 조합이지만 계속해서 재사용성이 유지해야 한다.</p>
<p>(ex) 검색 폼은 여러 페이지에서 사용됨.</p>
<p>아무래도 재사용성 유지를 위해 적은 수의 Atom을 조합하여 그 범용성을 높인다.</p>
<hr>
<h4 id="유기체-Organism"><a href="#유기체-Organism" class="headerlink" title="유기체 (Organism)"></a><strong>유기체 (Organism)</strong></h4><p>유기체는 분자 뿐만 아니라 원자까지 조합해 만들어진다.</p>
<p>유기체부터는 재사용이 강제되지 않는다. 즉 분자와 유기체의 차이는 재사용성이라고 생각할 수 있다.</p>
<p>(ex) Header, Footer 컴포넌트</p>
<p>유기체는 Container의 형태를 띄기도 한다. (ex) ProductList (ProductListItem의 배치 역할)</p>
<p>아무래도 이런 List 컴포넌트는 재사용하기 어렵기 때문에 유기체로 분류되는 것이 일반적이다.</p>
<blockquote>
<p>몇 개의 Organism을 배치하면 하나의 페이지가 완성된다고 하는데 잘 모르겠다.</p>
</blockquote>
<hr>
<h4 id="템플릿-Template"><a href="#템플릿-Template" class="headerlink" title="템플릿 (Template)"></a><strong>템플릿 (Template)</strong></h4><p>하위 컴포넌트들의 배치가 목적인 컴포넌트로, 페이지 구조나 레이아웃 구성을 담당한다.</p>
<p>하위 컴포넌트는 자신의 형태만 다룰 뿐 자신이 어떻게 배치될 지에 대해 책임지지 않는데, 템플릿은 이러한 컴포넌트들을 어떻게 배치시키고 표현할 것인지 결정한다.</p>
<blockquote>
<p>약간 <code>UI = render(state)</code> 느낌이기도 하다.</p>
</blockquote>
<hr>
<h4 id="페이지-Page"><a href="#페이지-Page" class="headerlink" title="페이지 (Page)"></a><strong>페이지 (Page)</strong></h4><p>페이지는 템플릿에 예제/실제 데이터가 들어간 상태를 말한다. (ex) Mockup</p>
<p>템플릿에 데이터를 주고 초기화한 인스턴스라고 생각해도 좋다.</p>
<hr>
<h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a><strong>장점</strong></h3><p>Atomic Design은 디자이너도 함께 실행해야 하는 것이지만 개발자 측면에서의 장점만 나열하겠다.</p>
<h4 id="1-원활한-의사소통"><a href="#1-원활한-의사소통" class="headerlink" title="1. 원활한 의사소통"></a><strong>1. 원활한 의사소통</strong></h4><p>컴포넌트 단위로 나누는 것은 그 단위가 미리 정의가 돼야 하며 모두가 동의해야 한다. 그러한 단위를 굳이 Atomic Design이 주장하는 바대로 따를 필요는 없지만 의사 소통 이전에 미리 정의돼야함은 변함이 없다. 이 때 Atomic Design은 이런 단위를 미리 정의해서 제공한다.</p>
<p>충분히 납득할만한 수준으로 잘 정의됐으며 이미 널리 알려져 있기 때문에 사용할 가치가 높다고 생각한다.</p>
<h4 id="2-의존성-분리"><a href="#2-의존성-분리" class="headerlink" title="2. 의존성 분리"></a><strong>2. 의존성 분리</strong></h4><p>Atomic Design에 부합하도록 각 요소를 잘 분리한다면 아래와 같은 실익을 얻을 수 있다.</p>
<ul>
<li>개발 과정을 병렬로 진행할 수 있고</li>
<li>각 요소가 변경되더라도 변경되는 요소를 최소한으로 줄일 수 있음</li>
</ul>
<h4 id="3-작은-컴포넌트"><a href="#3-작은-컴포넌트" class="headerlink" title="3. 작은 컴포넌트"></a><strong>3. 작은 컴포넌트</strong></h4><p>Atomic Design의 각 단위에 맞게 하나의 역할을 하는 컴포넌트로 개발하면 각 컴포넌트를 작게 유지할 수 있다. 덕분에 그 개수가 늘어나도 변경에 의한 변경을 최소화할 수 있으며 따라서 복잡성이 지수적으로 올라가기보다 선형적으로 증가할 것이다. 뭐든 작게 유지하는 것은 key to computer science 이고 UNIX 철학에도 들어맞는다. </p>
<blockquote>
<p>Make each program do one thing well.</p>
</blockquote>
<hr>
<h3 id="주의점"><a href="#주의점" class="headerlink" title="주의점"></a><strong>주의점</strong></h3><h4 id="1-재사용을-위한-반응형-디자인"><a href="#1-재사용을-위한-반응형-디자인" class="headerlink" title="1. 재사용을 위한 반응형 디자인"></a><strong>1. 재사용을 위한 반응형 디자인</strong></h4><p>컴포넌트는 데이터에 따라 여러 상태를 가질 수 있고, 따라서 여러 해상도에서 표시될 수 있다. 컴포넌트가 여러 해상도를 지원하려면 가로 너비(width)가 변할 수 있게 개발해야 한다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* before */</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* after */</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-하위-컴포넌트에서-레이아웃-속성-최대한-피하기"><a href="#2-하위-컴포넌트에서-레이아웃-속성-최대한-피하기" class="headerlink" title="2. 하위 컴포넌트에서 레이아웃 속성 최대한 피하기"></a><strong>2. 하위 컴포넌트에서 레이아웃 속성 최대한 피하기</strong></h4><p>Atomic Design에서 컴포넌트를 배치하는 역할은 상위 컴포넌트의 역할이다. 배치란 위치를 결정하는 일이고 따라서 각 컴포넌트는 자신이 그려지는 바깥 범위의 레이아웃을 방해하면 안 된다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 여백은 배치(레이아웃) 속성이며 이렇게 스스로 값을 줘버리면 배치하는 입장에서 굳이 덮어써야 한다. */</span></span><br><span class="line"><span class="selector-class">.atom</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Atom을 조합하는 Molecule이 조합된 Atom을 알아서 배치하는 것이 적절하다. */</span></span><br><span class="line"><span class="selector-class">.molecule</span> <span class="selector-class">.atom</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-CSS3-Flexbox-GridBox-사용하기"><a href="#3-CSS3-Flexbox-GridBox-사용하기" class="headerlink" title="3. CSS3 Flexbox/GridBox 사용하기"></a><strong>3. CSS3 Flexbox/GridBox 사용하기</strong></h4><p>flex, grid 속성은 배치에 최적화된 속성이며 Organism의 경우 List 컴포넌트와 같이 Molecule을 배치하는 역할을 주로 하기 때문에 이 때 사용하는 것은 적절하다고 할 수 있다. </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.organism</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="실제-활용-예시"><a href="#실제-활용-예시" class="headerlink" title="실제 활용 예시"></a><strong>실제 활용 예시</strong></h3><p><a target="_blank" rel="noopener" href="https://velog.io/@thsoon/%EC%93%B8%EB%95%8C%EC%97%86%EC%9D%B4-%EA%B3%A0%ED%80%84%EC%9D%B8-%ED%88%AC%EB%91%90%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-FE-2.-%EB%B7%B0-%EC%84%A4%EA%B3%84">Atomic Design으로 Todo 만들기 (KR)</a></p>
<hr>
<p>출처: <a target="_blank" rel="noopener" href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=190038704">더 괜찮은 웹 개발자가 되기 위한 리액트 스타일 가이드 (Aladin)</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-25T11:00:00.000Z" title="2021-01-25T11:00:00.000Z">21-01-25</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-25T22:45:47.390Z" title="2021-01-25T22:45:47.390Z">21-01-26</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">11분안에 읽기 (약 1660 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-async-2/">JS Async Functionality 2 - Promise</a></h1><div class="content"><p>이 시리즈는 자바스크립트에서 비동기를 다룰 때 마주치는 개념들을 다룬다. 이번 글에서는 Promise를 다룬다. </p>
<p><a href="https://jsqna.com/js-async-1/">JS Async Functionality 1 - Intro</a></p>
<hr>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise:"></a><strong>Promise:</strong></h4><p><code>&#123; pending, fulfilled, rejected &#125;</code>상태를 가지는 객체로,  <code>executor</code> 함수를 인자로 받는다. </p>
<ul>
<li><p>executor 함수( <code>(resolve, reject ) =&gt; &#123;&#125;</code> )의 역할:</p>
<ol>
<li>비동기 함수를 호출하고 </li>
<li>그 비동기 함수의 콜백에서 resolve를 호출한다.</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">url</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 이 함수가 executor 함수이다. (주석 설명 참조)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. example Async API provided by Node.js</span></span><br><span class="line">    http.get(options, <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">let</span> data;</span><br><span class="line">        result.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> data += chunk);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. Calls either [ resolve, reject ] from async callback.</span></span><br><span class="line">        result.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> resolve(data));</span><br><span class="line">        result.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> reject(err));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>executor 함수는 기존의 비동기 처리 방식을 그대로 옮겨온 것으로 이해하기 어렵지 않다.</p>
</li>
<li><p>다만 Promise Chaining이라는 개념으로 Callback Hell을 1차원으로 들여쓰기 단계를 낮출 수 있다.</p>
</li>
<li><p>이렇게 들여쓰기 단계를 줄이는 것은 중요한데 가독성에 의한 논리 오류가 빈번하게 발생했기 때문이다.</p>
</li>
</ul>
<hr>
<p>또한 Javascript 특성상 CPS 패턴으로 작성된 비동기 처리 함수에서, 이후에 호출되는 함수는 이전 함수의 클로저 참조도 할 수 있다. </p>
<ul>
<li>부주의하게 클로저 영역의 변수들을 사용하는 경우 메모리 사용량 면에서 좋을 게 없었다. </li>
<li>(ex) 전체 비동기 절차가 끝날 때 까지 호출 함수의 지역 변수들이 해제되지 못하는 등.</li>
</ul>
<hr>
<h4 id="Promise-Chaining"><a href="#Promise-Chaining" class="headerlink" title="Promise Chaining:"></a><strong>Promise Chaining:</strong></h4><p>Promise는 타입이자 객체이다. Promise(<executor function>); 인스턴스는 자신의 실행 흐름에 관여하는 메소드를 세 개 갖는다: <strong><u>then</u></strong>, <strong><u>catch</u></strong>, <u><strong>finally</strong></u> (참고로 메소드는 총 5개이다. race, all이 그 나머지 둘이다.)</p>
<ul>
<li>Prototype에 등록된 함수로, then은 Promise를 반환하고(그래서 Chaining이 가능하고) catch는 reject된 Promise에 한 해 수행되는 조건문으로 <code>then(undefined, onRejected)</code>와 동등하다. finally는 JS의 try-catch-finally의 finally와 동등하다.</li>
</ul>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a><strong>then</strong></h4><p><code>then</code> = (onFulfilled, onRejected) =&gt; Promise</p>
<p>즉 then의 두 번째 인자는 catch 절인 셈이다. 웬만하면 가독성을 위해 따로 catch 절을 사용한다.</p>
<ul>
<li><p>onFulfilled = value =&gt; Promise (여기서 value는 Promise가 resolve한 값이다. 보통 비동기 함수의 결괏값.)</p>
</li>
<li><p>onRejected = value =&gt; {} (여기서 value는 Promise가 reject한 값이다. 보통 Error 객체.)</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.then(onFulfilled, onRejected);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 비동기가 별 탈 없이 진행된 경우.</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 비동기 함수 수행 중 오류가 난 경우.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>then에서는 값을 그냥 반환하는 경우 Promise.resolve로 감싼 것과 같다. 즉 Promise가 반환되는 것인데, 그렇기 때문에 Promise Chaining이 가능한 것이다.</p>
</li>
</ul>
<hr>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a><strong>catch</strong></h4><p><code>catch</code> = onRejected =&gt; Promise <strong>(!)</strong></p>
<ul>
<li><p>catch 메소드는 <code>try-catch</code>의 <code>catch</code>와 같은 역할이다. 즉, catch가 성공했느냐, 실패했느냐에 따라 다시 then이 실행될 수도 있고 다른 catch가 실행될 수도 있고 앱이 멈출 수도 있다.</p>
</li>
<li><p>Case 1: catch 절에서 resolved Promise를 반환하는 경우: 이후의 then 수행</p>
</li>
</ul>
<ul>
<li><p>catch 절에서 따로 throw를 하거나, <code>Promise.reject()</code>를 호출하지 않는 경우 Promise는 resolved 상태로 변하여 then을 수행한 것과 동등하게 된다.</p>
</li>
<li><p>Case 2: catch 절에서 rejected Promise를 반환하는 경우: 이후의 catch 수행</p>
</li>
</ul>
<ul>
<li><p>JS의 try-catch에서 catch는 여러 개가 존재할 수 없는 것에 비해 Promise가 rejected 상태이면 catch절은 계속해서 호출된다. 보통 여러 개의 catch 절은 특정 오류만 잡고 싶을 때 사용한다.</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래처럼 pin-point로 catch 절을 사용하는 것이 가능하다.</span></span><br><span class="line"><span class="comment">// 기존 JS에서 try-catch를 여러 번 순차적으로 사용한 것과 동등하다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.Promise를 생성</span></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">// 1. throw를 호출해 catch 절로 이동</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;oh, no!&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 2. reject 혹은 throw를 하지 않으므로 then 수행</span></span><br><span class="line">  <span class="built_in">console</span>.error(e.message); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 3. 이 then이 수행되게 됨.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;after a catch the chain is restored&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 4. 만약 [2], [3]에서 throw를 하는 경우 여기로 오게 됨.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Not fired due to the catch&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a><strong>finally</strong></h4><p>(설명 생략)</p>
<hr>
<h3 id="알기-어려운-Promise의-특징"><a href="#알기-어려운-Promise의-특징" class="headerlink" title="알기 어려운 Promise의 특징"></a><strong>알기 어려운 Promise의 특징</strong></h3><p><strong>1. <u>then, catch는 비동기로 실행</u>된다.</strong></p>
<ul>
<li><p>아무리 Promise.resolve(); 로 resolve가 동기로 수행되더라도 then, catch는 비동기로 queue 된다.</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="literal">null</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Async: &#x27;</span> + v));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Sync!&#x27;</span>);</span><br><span class="line"><span class="comment">// 결과:</span></span><br><span class="line"><span class="comment">// Sync!</span></span><br><span class="line"><span class="comment">// Async: null</span></span><br><span class="line"><span class="comment">// WHY? then이 async로 microtask queue에 들어갔기 때문.</span></span><br><span class="line"><span class="comment">// then이</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>2: then, catch는 <u>비동기이지만 한꺼번에 수행</u>된다.</strong></p>
<ul>
<li><p>만약 then, catch가 setTimeout과 같은 일반적인 비동기였다면 <u>Task Queue</u>에서 처리된다. Task Queue는 한 작업만 처리하고 나머지 작업은 다음 순서로 넘긴다.</p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(loop, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">loop();</span><br><span class="line"><span class="comment">// 무한 루프에 걸리지 않는다.</span></span><br><span class="line"><span class="comment">// Microtask가 아니므로 이벤트 루프에서 한 작업씩만(!!!) 처리한다.</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>그러나 Promise, then, catch는 <u>Microtask Queue</u>에서 수행되는데, 이는 Event Loop 내의 Event Loop으로 생각하면 된다.</p>
<ul>
<li><p>굳이 이렇게 하는 이유는 </p>
<ol>
<li>다른 Javascript 수행이 되지 않음을 보장 </li>
<li>화면이 변경되지 않음을 보장 하기 위해서이다.</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>Microtask가 호출한 microtask 역시 이어서 수행되며 microtask queue가 빌 때까지 이 단계는 끝나지 않는다. </p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// then은 microtask에 queue 된다.</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(loop);</span><br><span class="line">&#125;</span><br><span class="line">loop();</span><br><span class="line"><span class="comment">// microtask는 현재 cycle에서 microtask가 비워질 때까지 수행을 멈추지 않는다.</span></span><br><span class="line"><span class="comment">// 즉 무한 루프를 비동기 코드로 발생시킬 수 있는 셈이다.</span></span><br></pre></td></tr></table></figure></li>
<li><p>출처: <a target="_blank" rel="noopener" href="https://ko.javascript.info/event-loop#ref-834">이벤트 루프와 매크로, 마이크로 태스크</a>, <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">Jake Archibald: Inside Loop - JSConf.Asia | Youtube</a></p>
</li>
</ul>
</li>
<li><p>Promise가 연속적으로 수행되어 문제가 발생하는 예제를 생각하려고 했으나 대부분의 비동기는 microtask를 사용하지 않기에 큰 문제는 없을 것 같다. 따라서 이 본문의 내용을 몰라도 거의 문제는 없을 것 같다.</p>
</li>
</ul>
<hr>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a><strong>출처</strong></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">Promise then</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch">Promise catch</a> (재밌는 점은 catch 문서는 한국어 번역이 없다는 점이다.)</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Using_promises">Using Promises</a></p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>처음에 React를 통해 ES6를 배우면서 Promise를 접했을 때보다 문서 개수나 번역이 훨씬 좋아졌다는 걸 느꼈다. 앞으로의 JS 표준을 다루는 MDN Wiki 문서가 있으면 나도 기여해야겠다</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-22T10:40:00.000Z" title="2021-01-22T10:40:00.000Z">21-01-22</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-22T10:48:13.890Z" title="2021-01-22T10:48:13.890Z">21-01-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/NestJs/">NestJs</a></span><span class="level-item">10분안에 읽기 (약 1542 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/jsb-1-nestjs/">NestJS를 사용해야 할 이유</a></h1><div class="content"><p><a href="https://jsqna.com/ejs-1-why-express/">Express를 사용해야 할 이유 (1)</a>을 쓰면서 NestJS는 굉장히 매력적인 대상으로 다가왔다. 이번 글에서는 NestJS를 사용해야 할 이유를 조금 더 자세히 정리하고, NestJS를 간략히 알아본다.</p>
<hr>
<h3 id="NestJS를-사용해야-할-이유"><a href="#NestJS를-사용해야-할-이유" class="headerlink" title="NestJS를 사용해야 할 이유"></a><strong>NestJS를 사용해야 할 이유</strong></h3><p>NestJs만의 장점이 뭐가 있을까? 생각보다 좀 있었는데, 아무래도 Rich Framework의 특징을 많이 갖고 있다.</p>
<table>
<thead>
<tr>
<th>장점</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>CLI</td>
<td>생산성에 도움이 되는 유틸을 제공한다고 한다.</td>
</tr>
<tr>
<td>문서화</td>
<td>자세하고 유지보수가 잘 되는 문서를 갖고 있다고 한다. (타 프레임워크에 비해 기능이 훨씬 많은데도)</td>
</tr>
<tr>
<td>활성화된 개발 팀</td>
<td><a href="https://jsqna.com/ejs-1-why-express/">이전 글</a>에서 알아본 바로 이는 굉장히 특장점이다. (다른 언어에 비해 백엔드가 많이 약하다고 생각함)</td>
</tr>
<tr>
<td>Nest 전용 모듈</td>
<td>Spring처럼 타 라이브러리를 쉽게 사용할 수 있게 전용 모듈을 개발했다. TypeORM, Mongoose, GraphQL, Logging, Validation, Caching, WebSockets 등의 모듈이 있다고 한다.</td>
</tr>
<tr>
<td>MSA를 염두에 둔 설계</td>
<td>(이건 내가 MSA에 대한 이해가 적어서 얼마나 효과적일지 모르겠음.)</td>
</tr>
<tr>
<td>Typescript 채택</td>
<td>(Typescript 경험이 일천해 얼마나 효과적일지 모르겠음.)</td>
</tr>
<tr>
<td>테스트 용이성</td>
<td>프레임워크 핵심 가치에 테스트 용이성이 있고 프레임워크에서 설계를 <u>제공</u>하므로, 다른 프레임워크에 독자적인 설계를 했을 때보다 테스트가 용이할 것으로 <u>기대됨</u>.</td>
</tr>
</tbody></table>
<h4 id="NestJS를-사용하는-기업"><a href="#NestJS를-사용하는-기업" class="headerlink" title="NestJS를 사용하는 기업"></a><strong>NestJS를 사용하는 기업</strong></h4><p>사용하는 기업 목록 중 SW적으로 큰 기업이 없는데 무슨 이유일지 모르겠다. 분명 시장의 선택은 합리적일텐데 정말 선택받지 못한거라면 중요한 문제가 있을 거라는 합리적인 의심을 해볼 만하다.</p>
<hr>
<h3 id="NestJS의-핵심"><a href="#NestJS의-핵심" class="headerlink" title="NestJS의 핵심"></a><strong>NestJS의 핵심</strong></h3><hr>
<h4 id="패러다임"><a href="#패러다임" class="headerlink" title="패러다임"></a><strong>패러다임</strong></h4><p>Typescript를 <u>지원</u>하면서 OOP, FP, FRP(Functional Reactive) 요소를 조합한 백엔드 프레임워크이다.</p>
<blockquote>
<p>Typescript 사용은 강제가 아니다.</p>
</blockquote>
<p>Express, Fastify 를 기반해 개발됐고, NestJs가 윗단으로 추상화 계층을 제공하지만 바로 접근할 수도 있다.</p>
<p>NestJs는 Node.js HTTP 프레임워크 추상화 계층을 구현해놓았기 때문에, Express, Fastify 이외에도 Adapter 패턴을 통해 인터페이스 구현체만 제공한다면 어떤 기술 위에서도 작동할 수 있다고 한다. 아마 Fastify로 이주할 때 개발해 놓은듯하다.</p>
<blockquote>
<p><code>@nestjs/platform-expres</code>, <code>@nestjs/platform-fastify</code> 로 패키지가 분리돼있으니 참고해보면 재밌을 것 같다.</p>
</blockquote>
<p>다만 NestJs에서 Express 생태계가 필요할 것 같지도 않고 Fastify가 훨씬 빠른데 굳이 Express를 기본값으로 해놓은 이유는 모르겠다.</p>
<p>NestJs는 Typescript를 사용하지 않는다면 Babel이 필요하다고 하며 Node.js 10.13버전 미만으로는 지원하지 않는다.</p>
<blockquote>
<p>Typescript가 정확히 어떤 Javascript 버전까지 지원하는지 확인할 수 없었는데 조만간 Typescript를 학습하면서 정리해야겠다.</p>
</blockquote>
<hr>
<h4 id="목표"><a href="#목표" class="headerlink" title="목표"></a><strong>목표</strong></h4><p>프론트 3대 프레임워크 덕분에 개발자 생산성이 향상됐고 빠르고 테스트 가능하고 확장성있는 프론트엔드 개발이 가능해졌는데, 그 외 좋은 라이브러리들이 많지만 애플리케이션 구조, 설계 측면의 문제를 해결하는 프로젝트는 없었다. (이건 Javascript 계열의 특징이라고 생각한다. 아마도 대규모로 개발하는 제품에 Javascript를 쓰지 않기 때문인 것으로 보인다. 요즘은 언어가 많이 좋아졌는데도 말이다.)</p>
<p>NestJs는 애플리케이션 <u>아키텍처를 제공</u>한다(즉 개발자가 결정하는 게 아님). 테스트 가능하고, 확장성 있고, 느슨히 결합되고, 쉽게 유지보수 가능한 설계이다. Angular에서 영감을 받았다. (Angular는 강제성 있는 구조를 제공한다. React는 그 반대이고.)</p>
<hr>
<h3 id="NestJS-Docs-Intro-요약"><a href="#NestJS-Docs-Intro-요약" class="headerlink" title="NestJS Docs Intro 요약"></a><strong>NestJS Docs Intro 요약</strong></h3><p>문서의 내용을 요약했다.</p>
<h4 id="프로젝트-제너레이터"><a href="#프로젝트-제너레이터" class="headerlink" title="프로젝트 제너레이터"></a><strong>프로젝트 제너레이터</strong></h4><p><code>nest new &#123;project_name&#125;</code> 을 입력하면 프로젝트 폴더가 생성된다. (<code>npm i -g @nestjs/cli</code>로 설치되는 CLI 유틸인듯)</p>
<p>기본으로 생성되는 프로젝트 구조는 아래와 같다. 도메인이나 레이어 별로 폴더가 나뉘진 않는 듯하다.</p>
<blockquote>
<p>src</p>
<ul>
<li>app.controller.ts</li>
<li>app.controller.spec.ts</li>
<li>app.module.ts</li>
<li>app.service.ts</li>
<li>main.ts</li>
</ul>
</blockquote>
<p>아래는 Express에서의 파일 역할 비교이다.</p>
<table>
<thead>
<tr>
<th>file</th>
<th>NestJS</th>
<th>Express</th>
</tr>
</thead>
<tbody><tr>
<td>Controller</td>
<td>app.controller.ts</td>
<td>(사용자 나름)</td>
</tr>
<tr>
<td>Service</td>
<td>app.service.ts</td>
<td>(사용자 나름)</td>
</tr>
<tr>
<td>App</td>
<td>app.module.ts</td>
<td>App.js</td>
</tr>
<tr>
<td>Index (진입점)</td>
<td>main.ts</td>
<td>index.js</td>
</tr>
</tbody></table>
<hr>
<h4 id="재밌는-문서-구성"><a href="#재밌는-문서-구성" class="headerlink" title="재밌는 문서 구성"></a><strong>재밌는 문서 구성</strong></h4><p>아래는 몇 개의 하위 문서에 들어갔을 때 맨 위에 보이는 모식도 몇 개를 가져온 것이다.</p>
<p>Spring에서도 제공하지 않는 모식도를 Nest에서 제공하는 게 재밌었는데,</p>
<ol>
<li>개발진들이 정말 OOP를 좋아하는 것 같다고 느껴졌고</li>
<li>그래서 <u>오브젝트</u> 책을 보면서 같이 배우면 재밌을 것 같았고</li>
<li>Spring에 비해 Nest는 확실히 설계를 결정해주는 느낌이 들어서 자신감이 느껴졌고</li>
</ol>
<p>그동안 설계를 <u>정해준</u> 프레임워크는 사용해 본적이 없었는데 받아들이기만 한다면 생산성도 꽤 좋아질 것 같다. 설계 수준 또한 오픈 소스로 개발되니 어느 정도 검증됐을 거라고 생각한다. 따라서 꽤 좋은 학습 경험을 주지 않을까 생각이 든다.</p>
<p><img src="https://docs.nestjs.com/assets/Controllers_1.png" alt="Controller 문서의 모식도"></p>
<p><img src="https://docs.nestjs.com/assets/Components_1.png" alt="Provider 문서의 모식도"><img src="https://docs.nestjs.com/assets/Modules_1.png" alt="Module 문서의 모식도"></p>
<hr>
<p>출처:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.nestjs.com/">NestJS Docs</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://selleo.com/blog/why-choose-nest-js-as-your-backend-framework">Why choose Nest.js as your backend framework? | selleo</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-19T07:20:00.000Z" title="2021-01-19T07:20:00.000Z">21-01-19</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-02-02T12:01:32.770Z" title="2021-02-02T12:01:32.770Z">21-02-02</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/ExpressJs/">ExpressJs</a></span><span class="level-item">21분안에 읽기 (약 3193 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ejs-1-why-express/">Express를 사용해야 할 이유 (1) - 생태계 조사</a></h1><div class="content"><p>잠시나마 사용해본 Express는 내게 React 같았다. 무엇이든 할 수 있어 보였으나 직접 하기에는 매우 불편하고, 그러다보니 REST API를 작성할 때 이런 것까지 해야 돼? 혹은 이런 기능이 없어서 불편하네 등이 많았는데 이번에 알아보려고 한다. 얼마나 많이 Express를 사용하며, 왜 Express를 사용하는지 팩트 위주로 체크해봤다.</p>
<hr>
<h3 id="1-Node와-Express의-장점을-헷갈리면-안-된다"><a href="#1-Node와-Express의-장점을-헷갈리면-안-된다" class="headerlink" title="1. Node와 Express의 장점을 헷갈리면 안 된다."></a><strong>1. Node와 Express의 장점을 헷갈리면 안 된다.</strong></h3><p>대부분의 웹사이트에서 소개하는 Express의 장점들은 <a target="_blank" rel="noopener" href="https://tsh.io/blog/why-use-nodejs/">Javascript, Node.js의 장점</a>들이었다. 많은 글을 읽어보아도 Express의 장점을 소개하는 글은 많이 없었고 대부분 Node.js의 장점을 소개하고 있었다. </p>
<p>Express가 Node 기반인 게 큰 장점이라는 걸까… 그래서 Node.js와 같은 목적으로 생성된 프레임워크/런타임을 조사해보았다.</p>
<hr>
<h3 id="2-Reactor-Pattern을-구현한-프레임워크-런타임"><a href="#2-Reactor-Pattern을-구현한-프레임워크-런타임" class="headerlink" title="2. Reactor Pattern을 구현한 프레임워크/런타임"></a><strong>2. Reactor Pattern을 구현한 프레임워크/런타임</strong></h3><p><strong>A. 역시 Node.js만 있는 것은 아니었다.</strong> Javascript를 깊게 배우고 생태계를 옮겨 탈 바에 기존에 사용하던 언어로 작업하는 게 현실적이긴하다.</p>
<table>
<thead>
<tr>
<th>Lang</th>
<th>Sync Framework</th>
<th>Async Framework</th>
</tr>
</thead>
<tbody><tr>
<td>Java</td>
<td>Spring Web MVC</td>
<td><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html">Spring WebFlux</a> (<a href="https://jsqna.com/ndp-1-reactor-pattern/">Reactor Pattern</a>), <a target="_blank" rel="noopener" href="https://vertx.io/">Vert.x (JVM 기반)</a></td>
</tr>
<tr>
<td>Python</td>
<td>Flask, Django</td>
<td><a target="_blank" rel="noopener" href="https://github.com/tiangolo/fastapi">FastAPI</a>, <a target="_blank" rel="noopener" href="https://github.com/tornadoweb/tornado">Tornado</a>, <a target="_blank" rel="noopener" href="https://github.com/channelcat/sanic/blob/master/docs/sanic/getting_started.rst">Sanic</a>, … (꽤 많다.)</td>
</tr>
<tr>
<td>Javascript</td>
<td>-</td>
<td>*</td>
</tr>
</tbody></table>
<p>다른 언어에 대해선 찾아보지 않았지만 Java, Python이 점유율이 큰 언어들이므로 충분하다고 생각한다. 벤치마크를 찾아보진 않았지만 같은 패턴을 기반으로 제작됐기 때문에 실제 서비스로 구현했을 땐 성능 면에서도 비슷할 것으로 예상된다.</p>
<p>다만 Node.js의 장점이라면, 선천적으로 비동기 API가 장려되어왔기 때문에 비동기 API로 작성된 라이브러리 활용 면에서 낫지 않을까 생각한다.</p>
<p><img src="https://blog.kakaocdn.net/dn/cvOos4/btqBAVbGq1W/SRBlIXlePKbV9U2k13Kcyk/img.png" alt="Spring Web Flux 구조 - Node.js EventLoop과 유사"></p>
<p>출처: </p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://happyer16.tistory.com/entry/%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EA%B0%90%EB%8B%B9%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-Spring-WebFlux-%EB%8F%84%EC%9E%85">대용량 트래픽을 감당하기 위한 Spring Webflux 도입</a>, </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://devahea.github.io/2019/04/21/Spring-WebFlux%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%81%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A1%9C-%EB%A7%8E%EC%9D%80-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EA%B0%90%EB%8B%B9%ED%95%A0%EA%B9%8C/">Spring Webflux는 어떻게 적은 리소스로 많은 트래픽을 감당할까</a></p>
</li>
</ul>
<hr>
<h3 id="3-Node-js-백엔드-프레임워크-간의-점유율-만족도-비교"><a href="#3-Node-js-백엔드-프레임워크-간의-점유율-만족도-비교" class="headerlink" title="3. Node.js 백엔드 프레임워크 간의 점유율/만족도 비교"></a><strong>3. Node.js 백엔드 프레임워크 간의 점유율/만족도 비교</strong></h3><p>제대로 비교하기 전에 통계 자료부터 확인하자.</p>
<ul>
<li>참고로 <a target="_blank" rel="noopener" href="https://medium.com/weekly-webtips/next-js-on-the-server-side-notes-to-self-e2170dc331ff">Next.js는 SSR 용 백엔드(SSR, Code Splitting 자동)</a>라고 생각하면 된다.</li>
</ul>
<hr>
<p><strong>점유율 요약 (아래 그림):</strong></p>
<ul>
<li>Express의 점유율이 압도적이다.</li>
<li>Koa, Hapi 라는 네임드의 점유율이 꽤 낮다.</li>
<li>서비스 개발에 가장 유리할 거라고 생각했던 Nest.js의 점유율이 13%밖에 안돼서 의문이다.</li>
</ul>
<p><img src="/images/ejs-1/express-1.png" alt="2020 점유율 순위"></p>
<table>
<thead>
<tr>
<th>Hapi</th>
<th>Koa</th>
<th>Nest</th>
<th>Express</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/images/ejs-1/hapi.png"></td>
<td><img src="/images/ejs-1/koa.png"></td>
<td><img src="/images/ejs-1/nest.png"></td>
<td><img src="/images/ejs-1/express.png"></td>
</tr>
</tbody></table>
<p>물론 Express를 기반으로 하는 다른 프레임워크 등이 어느 정도 반영됐을 것이긴 하다. Nest도 처음에는 Express 기반이었으니까. 그래도 다운로드 수의 큰 차이를 보면 나머지 프레임워크의 시장성이 의심되긴 한다.</p>
<hr>
<p><strong>만족도 비교 (아래 그림):</strong></p>
<ul>
<li>Express는 점유율에 이어 만족도도 최상위권이다.</li>
<li>Nest.js가 5% point 정도의 차이가 있지만 준수한 편이다. </li>
<li>Koa의 만족도가 76%인 점인 이유는 장점이었던 동기식 코딩 방식인 async-await이 표준화됐기 때문임으로 보인다.</li>
<li>Hapi는 만족도가 매우 낮은 것으로 보아 사용할 수 없겠다는 생각이 들었다. (추후 조사를 해봐야겠다.)</li>
</ul>
<p><img src="/images/ejs-1/express-2.png" alt="2020 만족도 순위"></p>
<p>출처: <a target="_blank" rel="noopener" href="https://2020.stateofjs.com/ko-KR/technologies/back-end-frameworks/">2020 State Of JS (한국어 번역)</a></p>
<hr>
<h3 id="4-왜-이렇게-Express를-많이-쓰는-걸까"><a href="#4-왜-이렇게-Express를-많이-쓰는-걸까" class="headerlink" title="4. 왜 이렇게 Express를 많이 쓰는 걸까?"></a><strong>4. 왜 이렇게 Express를 많이 쓰는 걸까?</strong></h3><blockquote>
<p>정말 Express가 좋은걸까? </p>
<p>다른 언어의 프레임워크를 비교해봤을 때 솔직히 좋다고 하진 못 할것 같다.</p>
</blockquote>
<hr>
<h4 id="1-단순함-0"><a href="#1-단순함-0" class="headerlink" title="1. 단순함 (+0)"></a><strong>1. 단순함 (+0)</strong></h4><p>정말 많은 블로그에서 Express의 최장점을 단순함으로 꼽고 있었는데 장점보다는 목적에 가까운 것이라 생각한다. 목표에 따라 단순함은 장점이 될 수도, 단점이 될 수도 있기 때문이다. 단순함을 장점으로 꼽는 경우 둘 중 하나이다. </p>
<ul>
<li>Rich Framework를 감당할 만큼 숙련된 개발자로 채우기 어려운 조직이거나</li>
<li>애초에 큰 규모의 서비스를 작성하기 위해 Express를 사용하지 않거나</li>
</ul>
<p>만약 서비스 개발을 위해 Express를 사용한다면 단순함은 직접적인 단점이 된다. </p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/danielfsousa/express-rest-boilerplate">기본적인 의존성만 담은 Boilerplate(1.4k stars)</a>만 보더라도 같이 깔아야 할 라이브러리들이 많아 학습 곡선이 가팔라진다.</p>
</li>
<li><p>처음 입문하는 경우 미들웨어들을 직접 찾는 추가적인 일을 하게 된다. (한 프레임워크 내에서 찾는 것과 대조적.)</p>
</li>
<li><p>Rich Framework 들에 비해 설계를 너무 근본적인 것들부터 해야 해 오히려 설계 측면에선 난도가 높다. (DI/IOC가 없고 여러 라이브러리를 비교 분석 후 사용해야 함.)</p>
</li>
</ul>
<p>다만 적절한 Boilerplate를 찾으면 이 문제가 어느 정도 해소된다는 점과 이후 단락에서 소개할 내용들을 통해 단순함의 단점을 상쇄할 수 있다.</p>
<p>Node.js는 출시 후 아직까지도 작은 서비스를 만드는 데 적합하다는, 프로토 타이핑 위주라는 인식이 남아 있는 것 같고, 그런 용도로 채택하여 단순함이 종종 장점이 되는 것 같기도 하다.</p>
<hr>
<h4 id="2-Express-Middleware-0"><a href="#2-Express-Middleware-0" class="headerlink" title="2. Express Middleware (+0)"></a><strong>2. Express Middleware (+0)</strong></h4><p>어떤 언어, 프레임워크로 웹 개발을 하더라도 Express에 미들웨어에 해당하는 계층에서 확장성을 가져가는 것은 기본이지 특별한 기능은 아니다. 또한 Express에서 제공하던 자체 Middleware들은 모두 <a target="_blank" rel="noopener" href="https://github.com/senchalabs/connect#middleware">Connect 미들웨어 라이브러리</a>로 <a target="_blank" rel="noopener" href="http://expressjs.com/en/guide/migrating-4.html#core-changes">옮겨갔다</a>. <a target="_blank" rel="noopener" href="https://nextjs.org/docs/api-routes/api-middlewares#connectexpress-middleware-support">Next.js에서는 이 미들웨어들을 지원하는데</a>, 그럼 다른 프레임워크에서도 의도하기만 하면 재사용 할 수 있는 셈이다. (의존성이 req, res, next 인자 밖에 없으니.)</p>
<hr>
<h4 id="3-Community-3"><a href="#3-Community-3" class="headerlink" title="3. Community (+3)"></a><strong>3. Community (+3)</strong></h4><p>Express는 꽤 많은 사용자 풀을 보유하고 있다. 이미 사용자가 많아 검색을 통한 문제 해결이 비교적 원활하다.</p>
<p>아래는 <a target="_blank" rel="noopener" href="https://insights.stackoverflow.com/trends?tags=express,nestjs,next.js">StackOverFlow 트렌드</a>인데 koa(js), hapi(js)는 태그로 잡히지도 않아서 비교가 불가능했다. 이는 생태계 조성이 거의 전무하다는 뜻인데 koa나 hapi는 출시된 지 시간이 지났음에도 이정도이며 특히 Hapi는 정말 작은 사용자 풀을 보여준다(사용하지 마세요).</p>
<p><img src="/images/ejs-1/trends-sto.png" alt="StackOverFlow Trends: Express vs Nest vs Next"></p>
<hr>
<h4 id="4-Async-await을-workaround로-쓸-수-있다-1"><a href="#4-Async-await을-workaround로-쓸-수-있다-1" class="headerlink" title="4. Async-await을 workaround로 쓸 수 있다. (+1)"></a><strong>4. Async-await을 workaround로 쓸 수 있다. (+1)</strong></h4><p>Express v5 부터는 Response Handler 및 Middleware에서 async/await을 사용할 수 있지만 아직 Release 되지 않은 관계로 사용할 수는 없다.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/expressjs/express/issues/4256#issuecomment-619616708">Express QnA 이슈의 답변</a>이다.</p>
<p>Q. How to use async/await in express 5?</p>
<p>A: There is one <u>main difference</u> between v4 and v5 when it comes to <u>async/await and promises in general</u>. In v5, if you return a promise from a response handler (or middleware), if that promise rejects and is not handled elsewhere, then Express will handle the error. It handles the rejection by passing the rejection reason to <code>next</code> for you.</p>
</blockquote>
<p>v4에서도 async-await을 쓸 수 있는데, 아주 간단한 미들웨어 <a target="_blank" rel="noopener" href="https://github.com/Abazhenov/express-async-handler">express-async-handler</a>로 한 번 감싸주면 된다. (원리는 <a target="_blank" rel="noopener" href="https://medium.com/@changjoopark/express-%EB%9D%BC%EC%9A%B0%ED%8A%B8%EC%97%90%EC%84%9C-async-await%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A0%A4%EB%A9%B4-7e8ffe0fcc84">이 설명</a> 참고) (같은 원리로 Promise도 처리 가능)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find a user by id</span></span><br><span class="line">router.get(</span><br><span class="line">  <span class="string">&#x27;/:id&#x27;</span>,</span><br><span class="line">  asyncHandler(<span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.user.id === req.params.id) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.status(<span class="number">403</span>).send(FORBIDDEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> UserRepository.findUserById(req.params.id);</span><br><span class="line">    <span class="keyword">if</span> (!user) <span class="keyword">return</span> res.status(<span class="number">404</span>).send(NOT_FOUND);</span><br><span class="line"></span><br><span class="line">    res.json(user);</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="5-Koa나-Express나-둘-다-개발은-하지-않는다-0"><a href="#5-Koa나-Express나-둘-다-개발은-하지-않는다-0" class="headerlink" title="5. Koa나 Express나 둘 다 개발은 하지 않는다. (+0)"></a><strong>5. Koa나 Express나 둘 다 개발은 하지 않는다. (+0)</strong></h4><p>Koa나 Express나 발전을 멈춘지 좀 됐다.</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/koajs/koa/issues/1114">Koa의 Roadmap 3.0</a>을 보면 현재 모습이 Koa의 완성형이라고 생각할 수 있다.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/koajs/koa/tree/7ae9c3e1099688ada21411a350d2b50dae629388">17년도 이후로 유지보수</a>가 대부분 Documentation에 치중되어 있다.</p>
</li>
</ul>
<p>KoaJS는 <a target="_blank" rel="noopener" href="https://github.com/koajs/koa/tree/8ee8abcc3268189c3f44abfb64d42903a87c4d5e">2013년에 시작</a>해 제너레이터 기반으로 미들웨어를 쉽게 작성하기 위해 나온 프레임워크인데, async-await 표준이 2017년 초부터 Node.js에서 공식적으로 지원되면서 그 의미가 퇴색되지 않았나 생각이 든다.</p>
<p>Express 역시 Documentation 위주의 유지보수, v5를 6-7년 째 안 내고 있긴 하다. (14, 15년도 쯤까지만 일한듯)</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/expressjs/express/issues/2844">Is express dying?</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/expressjs/express/pull/2237">Release v5</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/pillarjs/router">Router 모듈</a> (Express가 라우팅 관련 책임을 이 모듈로 넘긴 듯하다.) (얘도 유지보수가 죽었고.)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://nodejs.org/en/blog/announcements/foundation-express-news/">Node.js Foundation to Add Express to its Incubator Program</a> 16년 초에 Express 소유권이 넘어갔다고 한다.(인과관계는 잘x)</p>
</li>
</ul>
<hr>
<h3 id="5-서비스-개발-측면에선-NestJs가-더-낫지-않을까-추후-보강-예정"><a href="#5-서비스-개발-측면에선-NestJs가-더-낫지-않을까-추후-보강-예정" class="headerlink" title="5. 서비스 개발 측면에선 NestJs가 더 낫지 않을까? (추후 보강 예정)"></a><strong>5. 서비스 개발 측면에선 NestJs가 더 낫지 않을까? (추후 보강 예정)</strong></h3><p>Express, Koa는 현재 사실상 유지보수가 되고 있지 않다. 프로젝트에서 돈을 벌지 못하기 때문인 것으로 보이는데, 기업 스폰서가 없으며 프레임워크도 간단해 기술 지원이 불가능해 수익 모델이 없다. (Hapi는 Walmart에서 사용 중이긴 하지만 너무 마이너하다. 왜 인기가 없을까?)</p>
<p>NestJS는 구조가 Angular의 영향을 받았다고 돼있지만 Spring과 유사한 구조와 개발자 경험을 제공한다고 생각하며, Spring은 그 기능과 복잡성을 통해 기술 지원으로 돈을 벌고 있기 때문에 NestJS가 이 모델을 구현한다면 긴 시간 유지보수를 해나갈 수 있을 것 같다.</p>
<hr>
<p>정확히 무슨 벤치마크를 했는진 모르겠지만 성능 측면에서 NestJs-Fasitfy[현재 버전]가 Express보다 낫다고 한다. (<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/47733390/nestjs-vs-plain-express-performance">출처</a>)</p>
<table>
<thead>
<tr>
<th>Framework</th>
<th>Req/sec</th>
<th>Trans/sec</th>
<th>Req/sec DIFF</th>
<th>Trans/sec DIFF</th>
</tr>
</thead>
<tbody><tr>
<td>Nest-Express</td>
<td>15370</td>
<td>3.17MB</td>
<td>+4.38%</td>
<td>+4.23%</td>
</tr>
<tr>
<td>Nest-Fastify</td>
<td>30001</td>
<td>4.38MB</td>
<td>+2.20%</td>
<td>+2.23%</td>
</tr>
<tr>
<td>Express</td>
<td>17208</td>
<td>3.53MB</td>
<td>+8.38%</td>
<td>+8.31%</td>
</tr>
<tr>
<td>Fastify</td>
<td>33578</td>
<td>4.87MB</td>
<td>+6.55%</td>
<td>+6.53%</td>
</tr>
</tbody></table>
<p>NestJS에 대해선 추후 더 조사하려고 한다.</p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><h4 id="1-NestJS"><a href="#1-NestJS" class="headerlink" title="1. NestJS"></a><strong>1. NestJS</strong></h4><p>NestJS는 다루는 양이 방대하기도 하고 앞의 리서치에서 시간을 너무 많이 사용해서 따로 시간을 내서 리서치하진 못 해서 다음 기회에 꼭 하도록 한다.</p>
<h4 id="2-Fasify"><a href="#2-Fasify" class="headerlink" title="2. Fasify"></a><strong>2. Fasify</strong></h4><p>한 번 조사해봐야 할 것 같다. async-await도 지원하며 제대로 관리되고 있는 것 같다.</p>
<p>아래는 <a target="_blank" rel="noopener" href="https://github.com/fastify/fastify">README에 게시된 벤치마크</a>인데 성능도 역시 좋고.</p>
<table>
<thead>
<tr>
<th>Framework</th>
<th>Version</th>
<th>Router?</th>
<th>Requests/sec</th>
</tr>
</thead>
<tbody><tr>
<td>Express</td>
<td>4.17.1</td>
<td>✓</td>
<td>15,978</td>
</tr>
<tr>
<td>hapi</td>
<td>19.1.0</td>
<td>✓</td>
<td>45,815</td>
</tr>
<tr>
<td>Restify</td>
<td>8.5.1</td>
<td>✓</td>
<td>49,279</td>
</tr>
<tr>
<td>Koa</td>
<td>2.13.0</td>
<td>✗</td>
<td>54,848</td>
</tr>
<tr>
<td><strong>Fastify</strong></td>
<td><strong>3.0.0</strong></td>
<td><strong>✓</strong></td>
<td><strong>78,956</strong></td>
</tr>
<tr>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>http.Server</code></td>
<td>12.18.2</td>
<td>✗</td>
<td>70,380</td>
</tr>
</tbody></table>
<h4 id="3-HapiJS"><a href="#3-HapiJS" class="headerlink" title="3. HapiJS"></a><strong>3. HapiJS</strong></h4><p>Hapi도 개발이 계속 진행 중이고 Nest처럼 Rich한 Framework를 목표로 하는 것 같고, Walmart에서 실제로 사용하면서 주도적으로 개발하다가 작년 중순부터 <a target="_blank" rel="noopener" href="https://github.com/hapijs/hapi/issues/4113">Community-driven으로 간다고 한다</a>. 성장 가능성이 꽤 있는 것 같아서 시간이 나면 조사하면 좋을 것 같다. Facebook이 React를 만들어 프론트엔드 생태계를 많이 바꿔낸 것처럼.</p>
<h4 id="4-Express-In-Action-2016"><a href="#4-Express-In-Action-2016" class="headerlink" title="4. Express In Action (2016)"></a><strong>4. Express In Action (2016)</strong></h4><p>이 책을 좀 더 읽어보고 Express의 가치를 발견하다면 정말 좋을 것 같다.</p>
<h4 id="5-기타"><a href="#5-기타" class="headerlink" title="5. 기타"></a><strong>5. 기타</strong></h4><p>Promise, Async-await이 성능이 CPS 패턴에 비해 느리다는 의견이 종종 나왔는데 왜 그런지 확인해보기</p>
<p>D2에서 Node.js는 Socket.IO 때문에 떴다고 하던데 정말인지 확인해보기</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T10:55:00.000Z" title="2021-01-15T10:55:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">7분안에 읽기 (약 1070 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-generator/">Javascript의 Generator</a></h1><div class="content"><p>이 글은 자바스크립트의 제너레이터 문법에 대해 간략히 소개한다.</p>
<hr>
<h3 id="정의"><a href="#정의" class="headerlink" title="정의"></a><strong>정의</strong></h3><p>JavaScript의 제너레이터는 <code>function*</code> 으로 정의된 제너레이터 함수가 반환한 객체이다. 이 객체는 이터레이터(iterator)이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo()로 생성된 제너레이터를 순회하며 값을 읽어간다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-객체와-함수-팩토리"><a href="#Generator-객체와-함수-팩토리" class="headerlink" title="Generator 객체와 함수(팩토리)"></a><strong>Generator 객체와 함수(팩토리)</strong></h3><p><u>제너레이터 함수</u>를 호출하면 <u>제너레이터 객체</u>를 반환하고 끝난다.</p>
<p>제너레이터 객체의 <code>next(...args)</code>를 통해 제너레이터의 본문을 일정 부분 실행할 수 있다.</p>
<ul>
<li>이터레이터는 <code>next()</code> 함수로 파라미터를 전달할 수 없다.</li>
<li>제너레이터가 값을 읽을 수 있기 때문에 <u><strong>협력적 멀티 태스킹</strong></u>이 가능하다.</li>
</ul>
<h3 id="Generator-기반-협력적-멀티-태스킹"><a href="#Generator-기반-협력적-멀티-태스킹" class="headerlink" title="Generator 기반 협력적 멀티 태스킹"></a><strong>Generator 기반 협력적 멀티 태스킹</strong></h3><p>협력적 멀티 태스킹은 코루틴에 나오는 개념이다. (추후 정리할 예정이다.)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">go(<span class="function"><span class="keyword">function</span>* <span class="title">producer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> write(i);</span><br><span class="line">    <span class="keyword">yield</span> sleep(<span class="number">100</span>); <span class="comment">// -- sleep이 가능해진다!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">go(<span class="function"><span class="keyword">function</span>* <span class="title">consumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> v;</span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    <span class="keyword">typeof</span> (v = <span class="keyword">yield</span> read()) !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;read:&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>이 코드의 <code>go</code>와 같은 함수를 <strong>제너레이터 실행기</strong>라고 한다. <code>co</code> 라이브러리가 훌륭한 제너레이터 실행기를 제공한다.</p>
<p>제너레이터 실행기는 원래 동기적으로 수행되는 제너레이터를 비동기 호출을 수행하게 만든 다음 callback을 통해 다시 제너레이터를 호출하게끔 하여 비동기 코드를 동기 코드처럼 작성할 수 있게 하는 목적의 함수이다.</p>
<h3 id="제너레이터-실행기"><a href="#제너레이터-실행기" class="headerlink" title="제너레이터 실행기"></a><strong>제너레이터 실행기</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 제너레이터 실행기</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grun</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> it = g();</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x = it.next(val);</span><br><span class="line">    <span class="keyword">if</span> (!x.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        x.value</span><br><span class="line">          .then(iterate)</span><br><span class="line">          .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> it.throw(err));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(iterate, <span class="number">0</span>, x.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 실행기를 사용한 모습.</span></span><br><span class="line"><span class="comment">// 꽤 async-await과 같이 가독성이 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">theFutureIsNow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    data = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;a.txt&#x27;</span>),</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;b.txt&#x27;</span>),</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;c.txt&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;Unable to read one or more input files: &#x27;</span> +</span><br><span class="line">        err.message,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> ptimeout(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> nfcall(</span><br><span class="line">      fs.writeFile,</span><br><span class="line">      <span class="string">&#x27;d.txt&#x27;</span>,</span><br><span class="line">      data[<span class="number">0</span>] + data[<span class="number">1</span>] + data[<span class="number">2</span>],</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;Unable to write output file: &#x27;</span> +</span><br><span class="line">        err.message,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-직접-만들어보기"><a href="#Generator-직접-만들어보기" class="headerlink" title="Generator 직접 만들어보기"></a><strong>Generator 직접 만들어보기</strong></h3><p>자료 중 재밌는 것이 있었다: <a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/babel%EC%9D%80-generator%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%82%98-c78523645cd7">Babel은 Generator를 어떻게 바꾸나</a>. 지금 나한테는 바로 이해하긴 어렵다. 직접 만들어보면 이해에 큰 도움이 될 듯 하다.</p>
<h3 id="Generator의-단점-Iterable은-가변-인자가-아니다"><a href="#Generator의-단점-Iterable은-가변-인자가-아니다" class="headerlink" title="Generator의 단점: Iterable은 가변 인자가 아니다"></a><strong>Generator의 단점: Iterable은 가변 인자가 아니다</strong></h3><p>제너레이터 객체는 위에서 말했듯 Iterable이지만, 이는 <u><strong>가변 인자와는 달라</strong></u>서, Math.min같은 함수를 이용할 때 spead 연산자로 배열로 만들어 넘겨야 하므로, 인자 전달 부분에서 아쉽다고 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 객체만 넘길 순 없음.</span></span><br><span class="line"><span class="comment">// 굳이 제너레이터 객체를 넘길거면, 받는 함수 입장에서 이터레이터를 써야 할 듯?</span></span><br><span class="line"><span class="comment">// for-of 문으로.</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// spread 연산자로 넘겨줘야 함.</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...foo());</span><br></pre></td></tr></table></figure>
<h3 id="Generator의-콜-스택"><a href="#Generator의-콜-스택" class="headerlink" title="Generator의 콜 스택?"></a><strong>Generator의 콜 스택?</strong></h3><blockquote>
<p>Calling <code>.next()</code> method just pushes that call on the top of the stack. It will then run the code inside the generator function.</p>
<p><strong><u>difference</u></strong>: it has to remember the state of all local variables, but engines already know how to do that from the implementation of closures. A generator call will restore the state so that it can continue where it left off.</p>
</blockquote>
<p>일반적인 콜 스택과 동일하다고 한다. 다만 제너레이터 내에서 제너레이터를 호출하는 경우 복잡하다고 하는데, 거기까지 알 필요는 없을 듯 하다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48873128/javascript-stack-model-for-generators">Javascript stack model for generators | StackOverFlow</a></p>
<p>출처: <a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%9E%AC%EB%AF%B8-246553cadfbd">Javascript Generator의 재미 (2016.12)</a></p>
<p>출처: Learning Javascript, O Reilly</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><strong>TODO</strong>:</h3><p>부족한 내용 보충하기. 제너레이터가 개념 뿐 아니라 사용이 중요한 개념이어서 정리가 난잡한데 다음주 중으로 정리하려고 한다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T10:54:00.000Z" title="2021-01-15T10:54:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">3분안에 읽기 (약 426 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-promise-all/">Promise.all은 Parallel로 실행되는가?</a></h1><div class="content"><p>Javascript의 모든 코드는 이벤트 루프에서 처리된다. 그리고 Node.js의 이벤트 루프 구현체로 libuv가 사용 된다는 사실은 널리 알려져 있다. 그런데 이상하지 않은가?</p>
<h3 id="Promise-all은-Parallel로-실행되는가"><a href="#Promise-all은-Parallel로-실행되는가" class="headerlink" title="Promise.all은 Parallel로 실행되는가?"></a><strong>Promise.all은 Parallel로 실행되는가?</strong></h3><p>이벤트 루프 모델을 이해했다면 자바스크립트에 병렬 실행은 없다는 것을 이해했을 것이다. 파일, 네트워크 I/O는 자바스크립트 코드가 직접 처리하는 것이 아니고, 콜백은 이벤트 루프에 의해 호출되어 순차적으로 실행된다.</p>
<blockquote>
<p>그럼, Promise.all은 어떤가?</p>
</blockquote>
<p>음… 애초에 자바스크립트 코드가 병렬적으로 실행될 수 있는가?</p>
<h4 id="Promise-all을-잘-몰라서-생긴-일"><a href="#Promise-all을-잘-몰라서-생긴-일" class="headerlink" title="Promise.all을 잘 몰라서 생긴 일"></a><strong>Promise.all을 잘 몰라서 생긴 일</strong></h4><p><code>Promise.all</code>은 Promise의 호출 순서와는 전혀 관계가 없다. Promise의 기본 동작을 하나도 건드리지 않는다.</p>
<p>Promise.all이 제공하는 기능이란, 트랜잭션과 같이 하나라도 실패하면 catch 훅으로 넘어가게 하는 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3, p4, p5])</span><br><span class="line">  .then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="오히려-순차적으로-Promise를-실행하는-것이-더-특별하다"><a href="#오히려-순차적으로-Promise를-실행하는-것이-더-특별하다" class="headerlink" title="오히려 순차적으로 Promise를 실행하는 것이 더 특별하다."></a><strong>오히려 순차적으로 Promise를 실행하는 것이 더 특별하다.</strong></h4><p><code>reduce</code>를 사용해 <code>iterable.reduce((p, fn) =&gt; p.then(fn), Promise.resolve())</code>로 순차적으로 실행시킬 수 있다. (웬만하면 <code>then</code>으로 직접 잇겠지만.)</p>
<p><a href="https://jsqna.com/js-async-1">Async Functions in Javascript 1</a>를 참고해도 좋을 것 같다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://medium.com/@sandeepv68/how-does-promise-all-works-internally-978ee82f3348">How does Promise.all all works interanlly</a></p>
<p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30823653/is-node-js-native-promise-all-processing-in-parallel-or-sequentially">Is Node.js native Promise.all processing in parallel or sequentially? | StackOverFlow</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">이전</a></div><div class="pagination-next"><a href="/page/3/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-09T14:10:00.000Z">21-05-09</time></p><p class="title"><a href="/linux-tmux/">tmux 사용법 정리</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-11T14:55:00.000Z">21-04-11</time></p><p class="title"><a href="/linux-namespaces-1/">Linux와 Docker의 기술적 관계 (1/3)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-04T12:35:00.000Z">21-04-04</time></p><p class="title"><a href="/linux-user-and-sudo/">리눅스에서의 sudo와 권한 관리 (1)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-28T14:58:00.000Z">21-03-28</time></p><p class="title"><a href="/linux-how-to-find-files/">리눅스에서 파일을 찾는 방법</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-26T08:00:00.000Z">21-03-26</time></p><p class="title"><a href="/ndp-5-stream-5/">Stream 생태계 정리</a></p><p class="categories"><a href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
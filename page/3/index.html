<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-11T11:00:00.000Z" title="2021-01-11T11:00:00.000Z">21-01-11</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-25T11:21:13.860Z" title="2021-01-25T11:21:13.860Z">21-01-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">13분안에 읽기 (약 1935 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-async-1/">JS Async Functionality 1 - Intro</a></h1><div class="content"><p>이 글은 자바스크립트에서 비동기를 다룰 때 마주치는 개념들인 Promise, Generator, Async-Await을 큰 범위에서 다룬다. 중간 중간에 재밌는 패턴들도 수록했다.</p>
<hr>
<h3 id="Why-Promise"><a href="#Why-Promise" class="headerlink" title="Why Promise?"></a><strong>Why Promise?</strong></h3><blockquote>
<p><strong><u>What’s Promise?</u></strong><br>Promise는 순차적인 비동기 코드를 깔끔하게 짤 수 있게 하는 문법이다. 문법에 포함된 <code>Promise 객체</code>로 처리한다. Promise로 거의 모든 비동기를 처리한다고 해도 과언이 아니다.</p>
<p>Promise가 익숙하지 않다면 MDN을 참고:<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a> &gt; <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises</a></p>
</blockquote>
<p>비동기 작업 시 순차적인 흐름을 많이 구현해야 하는데, <u>CPS 방식으론 간결하게 짤 수 없다</u>. <a href="https://jsqna.com/ndp-3-cps-tips/">CPS 패턴 사용 시의 Tip | JSQnA</a> 참고.</p>
<p><strong>Promise의 장점</strong>: (콜백과 관련한 비교에 대한 내용은 <a href="https://jsqna.com/ndp-2-cps/">CPS 패턴</a> 참고.)</p>
<ul>
<li>프로미스 체인을 사용하면 작업들을 순차 실행시키는 일은 그리 어렵지 않다.</li>
<li><code>throw</code>를 프로미스 체인에서 사용할 수 있다.</li>
<li>catch 될 때까지 전체 체인에 오류를 자동으로 전파할 수 있다. 비동기 오류가 누락될 확률이 줄어든다.</li>
<li>동기적으로 값을 반환해도 비동기적인 호출을 보장한다. 함수가 동기, 비동기 반환을 섞어서 하는 것은 나쁘다.</li>
<li><code>Promise.all</code> 함수를 통해 비동기 작업을 병렬로 실행할 수 있다. (이건 CPS도 가능)</li>
<li><code>Promise.race</code> 함수를 통해 비동기 작업 중 가장 먼저 수행이 끝난 결과만 사용할 수 있다. (CPS에선 직접 구현해야 함.)</li>
</ul>
<p><strong>Promise로 함수 배열을 순차적으로 실행하는 패턴</strong> (현재 이해 부족으로 인해 수정 필요함.):</p>
<p>책에 재밌는 코드가 있어 가져왔다. Promise로 함수의 배열을 순차적으로 실행하는 방법이 있을까?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sequential :: Array(() =&gt; Promise) =&gt; Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequential</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 빈 값을 반환하는 Promise를 생성한다.</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  tasks.forEach(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// promise에 then으로 체인을 걸고,</span></span><br><span class="line">    <span class="comment">// 다음 순번의 &#x27;이전 작업&#x27;이 되기 위해 promise 변수로 할당한다.</span></span><br><span class="line">    <span class="comment">// UPDATE: task는 Promise를 반환하는 함수여야 한다.</span></span><br><span class="line">    promise = promise.then(task);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 최종 Promise를 반환한다.</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reduce로도 가능하다:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> promise = tasks.reduce(</span><br><span class="line">  (prev, task) =&gt; prev.then(task),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> retreive result</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>제한된 개수로 병렬 실행하기</strong>: (현재 이해 부족으로 인해, 추후 삽입 예정)</p>
<hr>
<h3 id="ES8-비동기-함수"><a href="#ES8-비동기-함수" class="headerlink" title="ES8 비동기 함수"></a><strong>ES8 비동기 함수</strong></h3><p>정의에 대한 자세한 내용은 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN async function</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">MDN AsyncFunction 생성자</a>를 참고하라.</p>
<p>ES7 비동기 함수는 비동기적으로 동작하는, <code>async</code>, <code>await</code> 문법이 활용된 함수이다.</p>
<p>(설명 보충 예정.)</p>
<hr>
<h3 id="Why-Generator"><a href="#Why-Generator" class="headerlink" title="Why Generator?"></a><strong>Why Generator?</strong></h3><blockquote>
<p><u><strong>What’s Generator?</strong></u></p>
<p>Generator는 시작 지점이 여러 개이며 중간에 실행을 정지/재개할 수 있는 함수이다.</p>
<ul>
<li><u>시작 지점이 여러 개</u>: 다른 시작 지점에 대해 매번 새로운 arguments로 호출할 수 있다.</li>
<li><u>정지/재개할 수 있다</u>: 제너레이터 함수는 실행 후 값을 반환할 때 정지한다. 이후 호출하면 다시 재개된다.</li>
</ul>
<p>Generator가 익숙하지 않다면 MDN을 참고:</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function</a>*</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator</a></p>
<p>시작하기 전에 아래 두 코드의 결과를 모르겠다면 이후 내용을 이해하기 어려우므로, Generator에 대해 추가적으로 공부를 하기 바란다.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator Example 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fruitGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;watermelon&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFruitGenerator = fruitGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator Example 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iteratorGenerator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = iteratorGenerator([</span><br><span class="line">  <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;orange&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;watermelon&#x27;</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">let</span> currentItem = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!currentItem.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(currentItem.value);</span><br><span class="line">  currentItem = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Generator-with-CPS-into-Async-Await"><a href="#Generator-with-CPS-into-Async-Await" class="headerlink" title="Generator with CPS into Async-Await:"></a><strong>Generator with CPS into Async-Await:</strong></h4><p>놀랍게도 Generator에 약간의 양념을 치면 ES7 비동기 함수를 만들어낼 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터로 비동기 흐름을 구현하는 방법이다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFlow</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// callback 함수는 비동기 함수에 CPS 패턴으로 넘겨져서, 결괏값으로 다시 제너레이터를 호출하는 데 사용된다.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> generator.throw(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> results = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    generator.next(</span><br><span class="line">      results.length &gt; <span class="number">1</span> ? results : results[<span class="number">0</span>],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> generator = generatorFunction(callback);</span><br><span class="line">  generator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncFlow, callback을 감추고, yield를 await으로 바꾼다면 async-await과 같은 문법을 지닌다.</span></span><br><span class="line">asyncFlow(<span class="function"><span class="keyword">function</span>* (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fileName = path.basename(__filename);</span><br><span class="line">  <span class="keyword">const</span> myself = <span class="keyword">yield</span> fs.readFile(</span><br><span class="line">    fileName,</span><br><span class="line">    <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">yield</span> fs.writeFile(</span><br><span class="line">    <span class="string">`clone_of_<span class="subst">$&#123;fileName&#125;</span>`</span>,</span><br><span class="line">    myself,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Clone created&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a><strong>try-catch</strong></h4><p>Async-Await과 유사하게, 제너레이터에는 <code>throw</code> API가 있는데, 제너레이터 함수 내에서 <code>try-catch</code>로 이를 처리할 수 있다:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> twoWay = twoWayGenerator();</span><br><span class="line">twoWay.next(args); <span class="comment">// args를 전달</span></span><br><span class="line">twoWay.throw(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">// throw로 Error 객체 전달. 제너레이터 함수 내의 catch 절로 이동하게 된다.</span></span><br></pre></td></tr></table></figure>
<p>참고자료 전문: <a target="_blank" rel="noopener" href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2">Async-Await ≈ Generators + Promises</a></p>
<p>참고 2: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36196608/difference-between-async-await-and-es6-yield-with-generators">Difference between async/await and ES6 yield with generators | StackOverFlow</a></p>
<p>참고 3: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31483342/es2017-async-vs-yield">ES2017 - Async vs. Yield | StackOverFlow</a></p>
<hr>
<h4 id="하나의-API로-CPS와-Promise-모두-지원하는-방법"><a href="#하나의-API로-CPS와-Promise-모두-지원하는-방법" class="headerlink" title="하나의 API로 CPS와 Promise 모두 지원하는 방법"></a><strong>하나의 API로 CPS와 Promise 모두 지원하는 방법</strong></h4><p><u>mongoose</u>와 같은 많은 라이브러리는 CPS와 Promise 방식을 모두 지원한다. 어떻게 한 함수로 동시에 지원할 수 있을까? 아래 코드와 같이 구현한다면 가능하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 마지막 인자로 callback 함수를 받는다.</span></span><br><span class="line"><span class="comment">// Promise로 사용하는 경우 callback 함수를 넘기지 않으니, 상관 없다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncDivision</span>(<span class="params">dividend, divisor, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 항상 Promise를 반환한다.</span></span><br><span class="line">  <span class="comment">// 어차피 CPS 패턴을 사용하는 코드라면 Promise로 결과를 받아서 처리하지 않는다.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 비동기로 반환</span></span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = dividend / divisor;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="built_in">isNaN</span>(result) ||</span><br><span class="line">        !<span class="built_in">Number</span>.isFinite(result)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">&#x27;Invalid operands&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">          cb(error);</span><br><span class="line">        &#125; <span class="comment">// 콜백이 있으면, 콜백을 호출한다.</span></span><br><span class="line">        <span class="keyword">return</span> reject(error); <span class="comment">// 콜백이 있든 없든, Promise reject로 catch 체인을 실행한다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, result);</span><br><span class="line">      &#125; <span class="comment">// 콜백이 있으면, 콜백을 결과로 호출한다.</span></span><br><span class="line">      resolve(result); <span class="comment">// Promise resolve로 then 체인을 실행한다.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>장점:</p>
<ul>
<li>Promise, CPS 패턴 사용자 모두에게 기능을 제공할 수 있다.</li>
</ul>
<hr>
<h3 id="비동기와-함수형-자바스크립트"><a href="#비동기와-함수형-자바스크립트" class="headerlink" title="비동기와 함수형 자바스크립트"></a><strong>비동기와 함수형 자바스크립트</strong></h3><p>Javascript는 순수한 함수형 언어가 아니므로, 모든 코드를 함수형 패러다임을 적용해서 작성할 수 없다고 한다. 비동기를 다루는 코드에 있어서는, 특히 async-await 키워드를 사용하여 작성할 때는 명령형 코드가 되므로, 더 함수형과 멀어지게 되는데, 결론적으론 Javascript에서 함수형 패러다임을 실천할 때에는 함수형인 코드 베이스와 그렇지 않은 부분으로 나누는 게 좋다고 한다. 또한 Promise든 Async-Await이든 하나를 택해서 통일하는 게 좋다고 하니 참고 바란다.</p>
<p>전문: <a target="_blank" rel="noopener" href="https://medium.com/@aidobreen/js-promises-async-await-and-functional-programming-f2e5fa66b4ef">JS: Promises, async/await, and functional programming.</a></p>
<hr>
<p><strong>TODO:</strong></p>
<ul>
<li>Generator는 아직도 공부 중이다. Iterable 프로토콜에 대한 얘기도 있고, 비동기 처리 외에 Generator의 쓰임새나 Generator 자체 개념에 대해 더 공부해야 한다.</li>
<li>코루틴에 대해서도 공부해봐야 할 것 같다. 공부 중 접하게 된 키워드이다.</li>
<li>제너레이터에 대한 설명을 보강해야겠다.</li>
<li>이해가 완료되면 자체 제작한 예제 코드로 교체한다.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-08T10:40:00.000Z" title="2021-01-08T10:40:00.000Z">21-01-08</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">7분안에 읽기 (약 1068 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-3-cps-tips/">3장: CPS 패턴 사용 시의 Tip</a></h1><div class="content"><p>Node.js 환경에서 CPS 패턴을 사용할 때 시도할 만한 Tip들을 정리했다.</p>
<hr>
<h3 id="1-Callback-Hell을-조금-해결하는-방법"><a href="#1-Callback-Hell을-조금-해결하는-방법" class="headerlink" title="1. Callback Hell을 조금 해결하는 방법"></a><strong>1. Callback Hell을 조금 해결하는 방법</strong></h3><blockquote>
<p>본인은 Promise 세대여서 Callback Hell을 제대로 경험해 본 적이 없고, 웬만한 개발 환경이라면 Callback Hell을 겪기 어려울 것으로 예상돼 짧게 요약했다.</p>
</blockquote>
<p>들여 쓰기 때문에 가독성이 매우 떨어지게 되고, 변수 이름도 중첩되는 문제가 있다. 만약 Blocking API를 사용해 동일한 내용을 구현했다면 잘 못 이해할 가능성은 거의 없을 것이다.</p>
<p><strong>Pattern</strong>:</p>
<ul>
<li>중첩 수준을 낮게 유지하기 위해, else 문을 사용하지 않는다.</li>
<li>인라인 함수의 이름을 지정하면, 함수 이름을 통해 더 쉽게 디버깅이 가능하다.</li>
<li>함수를 쪼갠다.</li>
</ul>
<p><strong>자주 하는 실수</strong>:</p>
<ul>
<li><p>Callback을 호출한 뒤에도 함수는 계속 실행됨을 잊는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) callback(err);</span><br><span class="line"><span class="comment">// 여기서도 함수는 계속 실행된다.</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>return callback(err)</code> 혹은 <code>return</code>을 callback 호출 이후 수행하여 함수 실행을 종료한다.</li>
</ul>
</li>
</ul>
<h3 id="2-순차적으로-실행시키는-방법"><a href="#2-순차적으로-실행시키는-방법" class="headerlink" title="2. 순차적으로 실행시키는 방법"></a><strong>2. 순차적으로 실행시키는 방법</strong></h3><p>Callback Hell을 겪지 않고 비동기 API를 순차적으로 실행하는 방법:</p>
<ul>
<li>재귀 함수로 실행한다.</li>
<li>재밌는 점은, StackOverFlow가 날 일은 없다는 점이다. 비동기 함수여서 매 번 스택이 초기화되니까.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> length = N;</span><br><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">f</span>) =&gt;</span> f;</span><br><span class="line"><span class="keyword">const</span> iterate = <span class="function">(<span class="params">idx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (idx === length) <span class="keyword">return</span> callback();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> task = tasks[idx];</span><br><span class="line">  task(data[idx], <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    iterate(idx + <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">iterate(<span class="number">0</span>); <span class="comment">// Callback이 재귀적으로 수행돼, N 만큼 수행된다.</span></span><br></pre></td></tr></table></figure>
<p>이 방식의 한계:</p>
<ul>
<li>실행될 작업의 숫자를 알아야 한다.</li>
</ul>
<h3 id="3-JS-경쟁-조건-해결하기"><a href="#3-JS-경쟁-조건-해결하기" class="headerlink" title="3. JS 경쟁 조건 해결하기"></a><strong>3. JS 경쟁 조건 해결하기</strong></h3><ul>
<li><p>Javascript는 단일 스레드로 실행된다.</p>
</li>
<li><p>리소스 동기화는 필요 없지만, 비동기 API 타이밍 문제는 아직 남아있다.</p>
</li>
<li><p>Javascript 역시 호출 시점과 I/O 수행 시점 차이로 중복 작업 등의 예기치 않은 동작을 할 수 있다.</p>
</li>
<li><p>상호 배제로 해결 가능하다.</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 중인 job을 등록한다. 공유 리소스 동기화는 필요 없다.</span></span><br><span class="line"><span class="keyword">const</span> jobs = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">id, data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 이 코드로 타이밍 문제를 해결할 수 있다.</span></span><br><span class="line">  <span class="keyword">if</span> (jobs.has(id))</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback);</span><br><span class="line"></span><br><span class="line">  jobs.set(id, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 정상 분기.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-동시에-수행되는-작업-개수-제한-하기"><a href="#4-동시에-수행되는-작업-개수-제한-하기" class="headerlink" title="4. 동시에 수행되는 작업 개수 제한 하기"></a><strong>4. 동시에 수행되는 작업 개수 제한 하기</strong></h3><p>한 번에 너무 많은 파일을 열려고 하는 등의 경우 리소스 부족으로 뻗어버릴 수 있다. 동시에 실행하는 작업의 수를 제한해 이를 상황을 방지하는 아이디어를 소개한다.</p>
<p>알고리즘:</p>
<ul>
<li>처음에 동시 실행 제한 개수만큼의 작업을 실행</li>
<li>각 작업이 끝날 때, <code>동시 실행 제한 개수 - 현재 실행 개수</code> 만큼의 작업을 실행</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> limit = <span class="number">2</span>; <span class="comment">// 동시 실행 제한 개수</span></span><br><span class="line"><span class="keyword">let</span> running = <span class="number">0</span>,</span><br><span class="line">  completed = <span class="number">0</span>,</span><br><span class="line">  idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> next = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 여유 작업 개수만큼 반복</span></span><br><span class="line">  <span class="keyword">while</span> (running &lt; limit &amp;&amp; idx &lt; tasks.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> task = tasks[idx++];</span><br><span class="line">    task(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 새 작업을 할 수 없음</span></span><br><span class="line">      <span class="keyword">if</span> (completed === tasks.length)</span><br><span class="line">        <span class="keyword">return</span> finish();</span><br><span class="line">      completed++;</span><br><span class="line">      running--;</span><br><span class="line">      next(); <span class="comment">// 새 작업을 할 여유가 있음</span></span><br><span class="line">    &#125;);</span><br><span class="line">    running++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 동시 실행 제한 개수를 채우며 계속 실행함.</span></span><br><span class="line">next();</span><br></pre></td></tr></table></figure>
<p><strong>큐로 구현하는 방법</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue로 구현하는 방식</span></span><br><span class="line"><span class="comment">// 로직은 같은데 Queue를 사용하는 것만 다르다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    <span class="built_in">this</span>.running = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.queue = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// task :: callback =&gt; void; (must call callback)</span></span><br><span class="line">  <span class="comment">// task를 tasks에서 가져오는 게 아니라, Queue에 넣은 것이 나온다.</span></span><br><span class="line">  <span class="comment">// =&gt; 새 작업을 큐에 동적으로 추가할 수 있다.</span></span><br><span class="line">  <span class="function"><span class="title">pushTask</span>(<span class="params">task</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.push(task);</span><br><span class="line">    <span class="built_in">this</span>.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      <span class="built_in">this</span>.running &lt; <span class="built_in">this</span>.limit &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.queue.length</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> task = <span class="built_in">this</span>.queue.shift();</span><br><span class="line">      task(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.running--;</span><br><span class="line">        <span class="built_in">this</span>.next();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="built_in">this</span>.running++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-Async-라이브러리-사용"><a href="#5-Async-라이브러리-사용" class="headerlink" title="5. Async 라이브러리 사용"></a><strong>5. <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/async">Async 라이브러리</a> 사용</strong></h3><p>복잡한 비동기 제어 흐름을 선언적인 방식으로 처리할 수 있게 헬퍼 함수들을 제공하는 라이브러리이다.</p>
<ul>
<li>순차적인 반복</li>
<li>제한된 동시 실행</li>
</ul>
<p>등을 헬퍼 함수를 통해 쉽게 구현 가능하다. CPS 패턴은 주로 사용할 것 같진 않아 따로 정리하진 않았다.</p>
<hr>
<p><strong>TODO</strong>:</p>
<ul>
<li>여러 번 이해하여 좋은 예제를 만들어 이 글 내용 보강하기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-08T01:20:00.000Z" title="2021-01-08T01:20:00.000Z">21-01-08</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">5분안에 읽기 (약 821 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-2-event-emitter/">2장 (3/3): Node.js의 Observer Pattern</a></h1><div class="content"><p>이 글은 Node.js에서 자주 사용되는 Observer Pattern에 대해 소개한다. <a href="https://jsqna.com/ndp-1-reactor-pattern/">리액터 패턴</a>, <a href="https://jsqna.com/ndp-2-cps/">CPS 패턴</a>에 대한 지식을 전제로 작성했으니 참고바란다.</p>
<hr>
<h3 id="1-Observer-Pattern의-정의"><a href="#1-Observer-Pattern의-정의" class="headerlink" title="1. Observer Pattern의 정의"></a><strong>1. Observer Pattern의 정의</strong></h3><blockquote>
<p>Node.js에서 이벤트는 핵심 중 하나라고 한다.</p>
<p>Node.js 코어 모듈과 오픈 소스를 사용하는데도 필수적인 조건이라고 한다.</p>
</blockquote>
<p><strong>Observer Pattern</strong>은 Subject와 Listener 라는 역할로 한 쪽은 등록을, 한 쪽은 통지를 하는 관계이다.</p>
<ul>
<li><p>Subject는 이벤트를 발생시키는 주체로, 스스로 무슨 행위를 할 때, Listener에게 통지를 해야 한다.</p>
</li>
<li><p>Listener는 특정 Subject 객체에 본인의 참조를 등록한다. <code>subject.addListener(this)</code>와 같이 수행한다.</p>
</li>
<li><p><code>foreach (listener : listeners) listener.notify();</code> 와 같이 Listener에게 이벤트 발생을 알린다.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4">옵서버 패턴 | Wiki 백과</a> 참고.</p>
</li>
</ul>
<p>Observer Pattern이 Callback 보다 나은 점이 뭘까?</p>
<table>
<thead>
<tr>
<th>기능</th>
<th>Observer Pattern</th>
<th>Continuous Passing Style</th>
</tr>
</thead>
<tbody><tr>
<td>다중 리스너 지원</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>핸들러 사용 횟수</td>
<td>여러 번(or 주기적으로) 발생하는 경우</td>
<td>한 번 발생하는 경우</td>
</tr>
<tr>
<td>핸들러 함수 제약</td>
<td>없음. <code>onError</code>, <code>onSuccess</code> 로 관심사 분리하므로.</td>
<td>한 함수 <code>(err, data)=&gt; &#123; /* ... */ &#125;</code>로 두 상태 모두 처리</td>
</tr>
<tr>
<td>핸들러 등록 시점</td>
<td>아무 때나</td>
<td>함수 실행 시점에 매개변수로 전달</td>
</tr>
</tbody></table>
<h3 id="2-Event-Emitter"><a href="#2-Event-Emitter" class="headerlink" title="2. Event Emitter"></a><strong>2. Event Emitter</strong></h3><p>Node.js는 Event Emitter라는 미리 구현된 객체를 코어 모듈(<code>events</code>)로 포함하고 있다. 이 객체는 <code>emit</code>, <code>on</code>, <code>once</code>, <code>removeListener</code> 로 구성된 총 4개의 메소드를 갖고 있다. 아래는 각 메소드의 사용 예시이다.</p>
<blockquote>
<p><em>CodeSandBox가 Node.js를 Beta로 지원하고 있으므로 출력이 정상적이지 않을 수 있습니다. 왼쪽의 탭을 드래그해 코드를 확인해주세요.</em></p>
</blockquote>
<iframe src="https://codesandbox.io/embed/setup-basic-nodejs-server-forked-9o5on?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="Setup Basic Node.js Server (forked)"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<p>아래는 File을 읽는 예제이다.</p>
<iframe src="https://codesandbox.io/embed/nodejs-event-emitter-file-read-example-2gx0i?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="Node.js Event Emitter - File Read Example"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<h3 id="3-Event-Emitter-에서의-예외-처리"><a href="#3-Event-Emitter-에서의-예외-처리" class="headerlink" title="3. Event Emitter 에서의 예외 처리"></a><strong>3. Event Emitter 에서의 예외 처리</strong></h3><p>Event Emitter에서도 비동기 이벤트의 경우, CPS와 마찬가지로 예외가 발생하는 경우 기존 스택을 잃기 때문에 (<a href="https://jsqna.com/ndp-1-reactor-pattern/">리액터 패턴</a> 참고) <code>try-catch</code>로 무조건 예외를 처리하여야 한다. 이후 <code>error</code> 이벤트를 발생시켜 리스너들에게 전달함이 일반적이다.</p>
<h3 id="4-Event-Emitter-상속하기"><a href="#4-Event-Emitter-상속하기" class="headerlink" title="4. Event Emitter 상속하기"></a><strong>4. Event Emitter 상속하기</strong></h3><p>아래와 같이 EventEmitter를 상속하여 인스턴스에 대해 <code>.on</code>을 붙이는 등의 작업을 할 수도 있다. 책에서는 일반적인 패턴이라고 하지만, <code>emit</code> 메소드까지 의도치 않게 Public API가 되기 때문에 추천하는 방식은 아니다. <code>위임</code>으로 <code>on</code>, <code>once</code>, <code>removeListener</code>를 따로 API로 내보내는 게 맞다고 생각한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindPattern</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findPattern = <span class="keyword">new</span> FindPattern(<span class="regexp">/hello \w+/g</span>);</span><br><span class="line">findPattern.on(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure>
<h3 id="5-동기-비동기-이벤트-별-리스너-등록-시점"><a href="#5-동기-비동기-이벤트-별-리스너-등록-시점" class="headerlink" title="5. 동기, 비동기 이벤트 별 리스너 등록 시점"></a><strong>5. 동기, 비동기 이벤트 별 리스너 등록 시점</strong></h3><p>이벤트를 동기적으로 발생시키려면, 리스너 등록을 이벤트 발생 이전 시점에 완료하여야 한다.</p>
<p>이벤트를 비동기적으로 발생시키는 경우, 리스너를 동기적으로만 등록한다면 시점이 자유롭다. (<a href="https://jsqna.com/ndp-1-reactor-pattern/">리액터 패턴</a> 참고.)</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-07T03:30:00.000Z" title="2021-01-07T03:30:00.000Z">21-01-07</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Docker/">Docker</a></span><span class="level-item">16분안에 읽기 (약 2338 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/docker-diamol-2-dockerfile-image/">[1 Month Docker] 2. Dockerfile, Docker Image</a></h1><div class="content"><p>Dockerfile과 Docker Image 개념을 소개하고, 핵심적인 내용을 설명한다. <a href="https://jsqna.com/docker-diamol-1-hello-world/">Docker에 대한 간단한 소개</a>의 내용을 기본으로 가정하고 시작한다.</p>
<hr>
<p>저번 글에선 Container와 Docker를 체험해보았다. Container는 어떠한 스택의 애플리케이션이든 배포 측면에서 일관된 경험을 제공하므로 사용하는 것이 좋지 않을까 생각한다.</p>
<p>Docker로 Container를 실행하려면 Docker Image가 필요한데, 이번 글에서는 최종적으로 Image를 직접 생성한다(공식적으로는 build 한다고 표현함.).</p>
<h3 id="1-기초-개념-설명"><a href="#1-기초-개념-설명" class="headerlink" title="1. 기초 개념 설명"></a><strong>1. 기초 개념 설명</strong></h3><p><strong>1. Dockerfile</strong>: 이미지 빌드 명령어의 입력으로 들어가는 스크립트이다. 아래와 같은 내용을 담는다.</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parent Image 지정</span></span><br><span class="line"><span class="comment"># Dockerfile은 이미지를 정의하는 파일이다.</span></span><br><span class="line"><span class="comment"># 새 이미지를 만들 때 다른 이미지의 내용에 기반해 덧씌우는 형태이다.</span></span><br><span class="line"><span class="keyword">FROM</span> diamol/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 환경 변수 3개 설정</span></span><br><span class="line"><span class="comment"># Docker와 같이 컨테이너 환경으로 앱이 배포되는 경우,</span></span><br><span class="line"><span class="comment"># 환경 변수를 arguments로 많이 활용한다.</span></span><br><span class="line"><span class="keyword">ENV</span> TARGET=<span class="string">&quot;blog.sixeyed.com&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> METHOD=<span class="string">&quot;HEAD&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> INTERVAL=<span class="string">&quot;3000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Working Directory를 /web-ping으로 지정 (폴더 생성 후 이동함. mkdir &amp;&amp; cd)</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /web-ping</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Host의 app.js 파일을, Working Directory(.)에 복사</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.js .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># node로 다음의 js를 실행</span></span><br><span class="line"><span class="comment"># CMD 명령어는 컨테이너 실행 시에 1회 수행되는</span></span><br><span class="line"><span class="comment"># container.once(&#x27;start&#x27;, callback)과 같다.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;/web-ping/app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>아마 셸 스크립트에 익숙한 사람은 셸 스크립트와 다름 없다고 생각할 것이다. 맞다. 똑같다. 아마 셸 스크립트가 익숙하지 않으면 Dockerfile에 쉽게 친해질 순 없을텐데, <a target="_blank" rel="noopener" href="https://tacademy.skplanet.com/live/player/onlineLectureDetail.action?seq=185">리눅스 환경 구성 기초 | T 아카데미</a>나 <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1zMf2HhVSR7MGJxafR8zRzqQEuRUBSDfG7yWx-GjBu6Q/edit#slide=id.p">리눅스 커맨드 라인 &amp; 쉘 스크립트 #1 | ABCD DevOps</a>라는 좋은 자료가 있으니 참고하자.</p>
</blockquote>
<p>Dockerfile 안에서만 쓸 수 있는, Dockerfile에서 쓰일 만한, 명령어가 10개 정의돼있다. 이 명령어들이 주축이 돼서 Dockerfile의 내용을 구성하게 된다.</p>
<ul>
<li><p>전체 기능에 대해서는 <a target="_blank" rel="noopener" href="https://medium.com/@iced_burn/dockerfile-cheat-sheet-9f52aa4a99b3">Dockerfile Cheat Sheet</a>를 참고하라.</p>
</li>
<li><p>걔 중 유사한 명령어인 <a target="_blank" rel="noopener" href="https://blog.leocat.kr/notes/2017/01/08/docker-run-vs-cmd-vs-entrypoint">CMD vs RUN vs ENTRYPOINT를 정리한 글</a>도 있으니 참고하기 바란다.</p>
</li>
<li><p>Dockerfile 명령어는 대소문자를 구분하지 않지만 대문자로 쓰는 게 컨벤션이다.</p>
</li>
</ul>
<p><strong>2. Image</strong>: 이미지는 Dockerfile에서 기술한 내용이 실행된 모습을 스냅샷 형태로 담은 파일이다.</p>
<ul>
<li>컨테이너 실행 시 이미지를 통해 Dockerfile에 정의된 내용이 그대로 재현된다.</li>
</ul>
<p><strong>3. Image 받아오기</strong>: 이미지를 직접 생성하지 않고, DockerHub 등의 Docker Registry (이미지 저장 서버)에서 받아올 수도 있다. 단순히 받아오기만 하는 명령어는 <code>docker image pull</code> 이다.</p>
<ul>
<li><code>docker image pull diamol/ch03-web-ping</code> 을 실행해 DockerHub에서 이미지를 받자.</li>
<li><img src="/images/image-1.png"></li>
<li>하나의 이미지를 받는데, 여러 <code>Pull Complete</code>가 표시돼있다. (나중에 설명한다.)</li>
</ul>
<p><strong>4. Image 빌드</strong>: <code>docker image build</code> 명령어를 실행하면, 이미지는 자동으로 빌드된다.</p>
<p>예: <code>docker image build --tag web-ping .</code> =&gt; <code>web-ping</code>이라는 이미지를 생성.</p>
<ul>
<li>(Mandatory) <code>.</code>은 Dockerfile 및 <code>COPY</code> 등에서 Host의 기준 디렉토리로 사용된다.</li>
<li>(Mandatory) <code>--tag</code>는 이미지의 이름을 지정한다.</li>
<li>주의: 파일을 Windows -&gt; Linux로 복사하는 경우, 권한이 <code>rwxrwx</code>로 지정되는데, 이는 서로 권한 정보가 호환되지 않기 때문이다.</li>
<li>로컬에서 직접 빌드된 이미지는 도커 엔진에 캐시돼 보관된다.</li>
<li>새로운 버전을 빌드하려는 경우, <code>--tag web-ping:v2</code>와 같이 <code>:</code>으로 버전을 구분하여 명시하면 된다.</li>
</ul>
<p><img src="/images/image-2.png" alt="Docker Image Build Process Example"></p>
<p><strong>5. Image 실행(컨테이너로)</strong>:</p>
<ul>
<li><code>docker container run &#123;image_name&#125;</code>으로 실행</li>
</ul>
<p><strong>6. Image Layer</strong>:</p>
<p>이미지에는 생성 과정에 대한 메타데이터도 포함된다. 이미지 생성 과정을 통해</p>
<ul>
<li><code>docker image history web-ping</code></li>
<li><img src="/images/image-3.png" alt="Image History Example"></li>
</ul>
<p>Docker Image는 Image Layer라는 더 작은 개념으로 구성되며, Dockerfile의 각 명령(<code>CREATED BY</code>) 마다 Layer가 생성된다.</p>
<ul>
<li>이미지는 각 Layer의 논리적인 집합이다.</li>
<li>Layer는 도커 엔진에 물리적인 파일의 형태로 캐시되는 단위이다.</li>
<li>이미지 간에 Layer가 공유되므로 전체 용량 부하를 낮출 수 있다.<ul>
<li><code>docker image ls</code>로 논리적인 용량을 확인할 수 있지만, <code>docker system df</code>로 이미지가 차지하는 물리적인 용량을 확인할 수 있다.</li>
<li><img src="/images/image-4.png" alt="docker system df"></li>
</ul>
</li>
</ul>
<p>이런 Image Layer 캐시를 활용하려면 조건이 필요한데: Layer 이전의 Layer 들의 내용과 순서가 바뀌지 않아야 한다.</p>
<ul>
<li>이전 내용이 바뀌었는데, 이 명령(Layer)을 실행한 결과가 같음을 보장할 수 없다.</li>
<li>만약 내용을 바꾸는 경우, 이 Layer에 의존하고 있던 모든 이미지에 영향을 끼친다.</li>
<li>그러므로, 이전 Layer가 변경되는 경우, 이후 Layer는 캐시로 사용될 수 없게 되고, 새로 Layer를 생성하게 된다.</li>
</ul>
<p><strong>7. Layer 캐시 최적화 전략</strong>: Layer 캐시 활용을 통해 전체 용량과 이미지 빌드 시간을 줄일 수 있다.</p>
<ul>
<li><p>이미지에서 변하지 않는 부분을 최대한 먼저 실행해 새로 빌드할 Layer 수를 줄인다.</p>
</li>
<li><p>캐시 사용 가능 여부는 Instruction의 내용과 Arguments(명령어 내용일 수도 있지만, <code>COPY</code>와 같은 경우 파일의 내용까지.)로 Hash 값을 만들고 비교하여 결정한다.</p>
</li>
<li><p>Hash가 일치하는 경우 빌드하지 않고 도커 엔진에 캐시된 Layer를 사용한다. 일치하지 않는 경우, 해당 Layer부터 최종 Layer까지 새로 빌드한다. (뒷 Layer의 해시가 같아도, 재사용할 수 없다.)</p>
</li>
<li><p><img src="/images/image-5.png" alt="docker build image cache"></p>
</li>
<li><p><code>app.js</code> 파일을 수정한 후 (<code>nano app.js</code>) 빌드한 모습이다. <code>COPY app.js</code>를 수행하는 <code>step 6</code>가 다시 Layer를 만듦을 확인할 수 있고, 이후 Layer인 <code>step 7</code>은 바뀐 내용이 없지만 앞 Layer가 바뀌어서 다시 만들어짐을 확인할 수 있다.</p>
</li>
</ul>
<p><strong>8. Layer 캐시 최적화 예시</strong>:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> diamol/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시작 시 실행될 명령어를 지정하는 것이므로, 어디에 놓아도 상관 없다.</span></span><br><span class="line"><span class="comment"># 캐시를 위해 앞에 놓는다.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;/web-ping/app.js&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 환경 변수 3개를 한 번에 등록해 Layer 개수를 줄였다.</span></span><br><span class="line"><span class="comment"># 개수를 줄인 것과 캐시 최적화는 큰 연관은 없지만...</span></span><br><span class="line"><span class="keyword">ENV</span> TARGET=<span class="string">&quot;blog.sixeyed.com&quot;</span> \</span><br><span class="line">	METHOD=<span class="string">&quot;HEAD&quot;</span> \</span><br><span class="line">	INTERVAL=<span class="string">&quot;3000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /web-ping</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.js .</span></span><br></pre></td></tr></table></figure>
<p>이제 <code>docker image build -t web-ping:v3</code>를 실행해보자. 환경 변수 개수가 줄어들어 7단계에서 5단계로 줄었음을 확인할 수 있다.</p>
<p>이제부턴 <code>app.js</code>를 수정해도 마지막 Layer만 바뀐다.</p>
<hr>
<h3 id="2-실습"><a href="#2-실습" class="headerlink" title="2. 실습"></a><strong>2. 실습</strong></h3><p><strong>1. 목표</strong>:</p>
<p><code>diamol/ch03-lab</code> 폴더의 이미지에서 <code>/diamol/ch03.txt</code> 파일을 수정하고 새 Image를 생성하라. 이 때 Dockerfile을 수정해서는 안 된다.</p>
<p><strong>2. 힌트</strong>:</p>
<ul>
<li><code>-it</code>으로 컨테이너에 키보드 I/O 가능</li>
<li>컨테이너 파일 시스템이 Exit 상태에도 제거되지 않음을 활용</li>
<li><code>docker container --help</code>로 모르는 명령어에 대해 공부할 것</li>
</ul>
<p><strong>3. 처음 생각한 접근 방법</strong>:</p>
<ol>
<li>Container에서 일단 파일을 수정한다.</li>
<li>컨테이너로 이미지를 생성해낸다. 명령어를 찾아보자.</li>
</ol>
<p><strong>4. 실제 수행 과정</strong>:</p>
<hr>
<p><strong>1. 일단 이미지를 빌드함</strong></p>
<p><code>cd ../../lab</code> (빌드를 위해 lab 폴더로 이동)</p>
<p><code>docker build image -t ch03-lab .</code> (빌드 성공)</p>
<hr>
<p><strong>2. 이제 컨테이너를 실행해야 함</strong></p>
<p><code>docker container run ch03-lab</code> (실패)</p>
<p><code>docker container ls</code> (없었음)</p>
<p><code>cat Dockerfile</code> (<code>CMD</code> 등 명령어 실행이 없고, <code>COPY</code> 뿐이었음)</p>
<hr>
<p><strong>3. 컨테이너에서 수행할 명령어로 주어 실행해야 함</strong></p>
<p><code>docker container run ch03-lab /bin/bash</code> (실패)</p>
<p><code>docker container run ch03-lab /bin/sh</code> (이미지에 bash가 없었음..)</p>
<p><code>vi ch03.txt</code> (텍스트 파일 수정)</p>
<p><code>exit</code> (sh 나옴)</p>
<hr>
<p><strong>4. 정지된 컨테이너를 이미지로 빌드해야 함</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/commit/">Docker Commit Reference</a>를 참고해서 빌드 명령어 학습</p>
<p><code>docker container ls --all</code> 로 종료된 컨테이너 ID 확인 (<code>67a</code>)</p>
<p><code>docker image commit 67a ch03-lab:v2</code> (무슨 해시값이 출력됨..)</p>
<p><code>docker image ls</code> (v2로 생성됨을 확인)</p>
<p><code>docker container run ch03-lab:v2 cat ch03.txt</code> (파일 갱신됨을 확인)</p>
<p><strong>끝!</strong></p>
<hr>
<p><strong>Lab 하면서 배운 점:</strong></p>
<p><code>docker commit</code> 명령어로 컨테이너 내용으로 이미지를 빌드할 수 있다는 점.</p>
<ul>
<li>다만 이렇게 되면 Dockerfile은 없는게 아닌가?</li>
</ul>
<p><code>docker container run &#123;IMAGE&#125; &#123;COMMAND&#125;</code>로 명령어를 실행할 수 있음</p>
<ul>
<li>다만 이는 이미지에서 수행하는 명령어가 없는 경우에 한한 것 같고, <code>docker container exec</code>으로 셸을 띄우는 것이 일반적인 것 같다.</li>
</ul>
<p><strong>TO DO</strong>:</p>
<ul>
<li>컨테이너에서 Commit으로 생성한 이미지에서 Dockerfile을 추출할 수 있을지 확인해보기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-04T01:00:00.000Z" title="2021-01-04T01:00:00.000Z">21-01-04</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/CI-CD/">CI/CD</a></span><span class="level-item">14분안에 읽기 (약 2118 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ci-1-github-actions-nodejs/">10분 만에 기반 지식 없이 Node.js를 위한 Github Actions CI 구축하기</a></h1><div class="content"><h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a><strong>목표</strong></h3><ul>
<li>10분 만에 Github Actions를 통한 CI를 구축한다.</li>
<li>master에 Merge 시에 ESLint와 테스트를 자동으로 수행하고, 결과에 따라 Merge할 수 없게 한다.</li>
</ul>
<hr>
<h3 id="1-기본-개념-설명"><a href="#1-기본-개념-설명" class="headerlink" title="1. 기본 개념 설명"></a><strong>1. 기본 개념 설명</strong></h3><p>기본 개념 몇 가지를 소개하고 넘어간다.</p>
<h4 id="1-CI"><a href="#1-CI" class="headerlink" title="1. CI"></a><strong>1. CI</strong></h4><p>Continuous Integration. 각자의 코드를 병합하기 전에 검토하는 절차를 말한다.</p>
<p>보통 자동화된 상태를 지칭하며, <code>master(or main)</code> 등의 특정 브랜치에 <code>Push(or Merge) Request</code>가 올라오면 코드를 검토한다.</p>
<h4 id="2-GitHub-Actions"><a href="#2-GitHub-Actions" class="headerlink" title="2. GitHub Actions"></a><strong>2. GitHub Actions</strong></h4><p>GitHub에서 특정 작업을 할 때 마다, 이벤트를 발생시키는데, 이를 구독해 특정 작업을 실행하는 것을 Github Actions라고 한다. (<a target="_blank" rel="noopener" href="https://pjh3749.tistory.com/266">옵저버 패턴</a> 참고)</p>
<h4 id="3-Worflow-File"><a href="#3-Worflow-File" class="headerlink" title="3. Worflow File"></a><strong>3. Worflow File</strong></h4><p>GitHub Actions의 이벤트에 대해 무엇을 실행할 지에 대해 기록해 놓은 명령서를 <code>workflow</code> 파일이라고 한다.</p>
<h4 id="4-Github-Actions-사용-시의-CI-흐름"><a href="#4-Github-Actions-사용-시의-CI-흐름" class="headerlink" title="4. Github Actions 사용 시의 CI 흐름"></a><strong>4. Github Actions 사용 시의 CI 흐름</strong></h4><p><em>PR Created(EVENT!)</em> &gt; Build &gt; Test &gt; <em>PR Merged(EVENT!)</em> &gt; Deploy (배포 자동화는 다음에)</p>
<ul>
<li>PR을 생성할 때 CI 수행</li>
<li>Merge할 때 CD 수행</li>
</ul>
<p>CI 과정에서 빌드가 성공했을 때만 Merge가 가능하게 설정하자.</p>
<h3 id="2-Node-js-App-으로-CI-구축-시작"><a href="#2-Node-js-App-으로-CI-구축-시작" class="headerlink" title="2. Node.js App 으로 CI 구축 시작"></a><strong>2. Node.js App 으로 CI 구축 시작</strong></h3><p>이 챕터에서 구축을 완료하고, 결과를 확인한다.</p>
<p>아주 간단한 과정이어서 CI라고 하긴 부끄럽지만, 아래 과정을 수행한다.</p>
<ul>
<li>npm module 설치</li>
<li>ESLint를 통한 코드 스타일 체크</li>
<li>테스트 실행</li>
</ul>
<h4 id="1-필요한-자료"><a href="#1-필요한-자료" class="headerlink" title="1. 필요한 자료"></a><strong>1. 필요한 자료</strong></h4><ul>
<li><p>ESLint가 설치된, 스택에 상관 없는 Node.js 샘플 앱</p>
</li>
<li><p>샘플 앱을 올린 Public Repo가 필요하다.</p>
</li>
<li><p>(이 글에서 코드를 따로 제공하지는 않는다.)</p>
</li>
<li><p>글쓴이는 토이 작업 중인 <a target="_blank" rel="noopener" href="https://github.com/seongbin9786/study-nodejs-typescript">이 레포</a>를 활용하였다.</p>
</li>
</ul>
<p>글에서 Jest를 설치하고, ESLint와 연동할 것이다.</p>
<hr>
<h4 id="2-Node-js-템플릿-가져와서-사용하기"><a href="#2-Node-js-템플릿-가져와서-사용하기" class="headerlink" title="2. Node.js 템플릿 가져와서 사용하기"></a><strong>2. Node.js 템플릿 가져와서 사용하기</strong></h4><p>아래는 레포지토리에서 Actions 탭을 눌러, Get started with GitHub Actions 아래에 있는 Node.js 템플릿을 가져온 것이다.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Node.js</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 구독할 이벤트</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">master</span>]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">master</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># jobs 단위로 개별 서버(정확히는 Docker 컨테이너 단위라고 한다.)에서 작업이 수행된다.</span></span><br><span class="line"><span class="comment"># 각 작업은 병렬로 실행 된다고 하는데, needs: build와 같이 표시해서 기다릴 수도 있다.</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># Ubuntu, Windows, MacOS를 지원한다.</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 영상에서도 소개됐는데, 변수 개념으로 생각하면 된다.</span></span><br><span class="line">    <span class="comment"># node-version 과 같이 배열로 돼있으면, 해당 원소를 순회하면서 작업이 반복해서 실행된다.</span></span><br><span class="line">    <span class="comment"># matrix 때문인지 배열만 되는 것 같다. (TODO)</span></span><br><span class="line">    <span class="comment"># 응용해서 runs-on에 여러 OS에서 돌릴 수도 있다.</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">node-version:</span> [<span class="number">14.</span><span class="string">x</span>] <span class="comment"># 템플릿 기본값: [10.x, 12.x, 14.x]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># uses 개념은 다른 사람이 작성한 내용을 실행하는 개념이다.</span></span><br><span class="line">    <span class="comment"># actions/checkout: GitHub의 마지막 커밋으로 Checkout 한다.</span></span><br><span class="line">    <span class="comment"># actions/setup-node: Node.js를 설치한다.</span></span><br><span class="line">    <span class="comment"># run 개념은 명령어를 실행한다. 셸 스크립트와 동일하다.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="comment"># npm ci는 npm install과 같은 기능을 수행한다. 자세한 내용은 아래 링크 참조.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">      <span class="comment"># --if-present 옵션은 npm 스크립트가 존재할 때만 실행시키라는 의미이다.</span></span><br><span class="line">      <span class="comment"># 만약 build 스크립트가 없는 경우, 오류 없이 지나간다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="string">--if-present</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci">npm ci에 대한 스택 오버 플로우 설명</a> (속도가 2배 가량 빠르다고 한다. 캐싱에 대한 내용도 있으면 좋겠다)</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50683885/how-to-check-if-npm-script-exists">–if-present 옵션에 대한 스택 오버 플로우 설명</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/actions/checkout">GitHub Actions Checkout ?</a></p>
<hr>
<p>프로젝트에 이 파일을 <code>.github/workflows/ci.yml</code>로 저장한다.</p>
<p>이후 Push 하면 Actions 탭을 눌렀을 때 해당 빌드 과정이 수행됨을 볼 수 있다.</p>
<p>단, 아직 설정이 다 끝나지 않았으므로, 이 파일의 구조만 확인하기 바란다.</p>
<h4 id="2-기본-제공-Workflow에-Lint-Test-추가"><a href="#2-기본-제공-Workflow에-Lint-Test-추가" class="headerlink" title="2. 기본 제공 Workflow에 Lint, Test 추가"></a><strong>2. 기본 제공 Workflow에 Lint, Test 추가</strong></h4><p>Lint와 Test 과정을 추가한다. 각 과정은 실패 없이 진행돼야 빌드가 성공한다.</p>
<p>Lint 과정에선 error로 설정된 Rule을 위반한 경우 빌드가 실패하게 된다.</p>
<hr>
<p><strong>1. Lint</strong>: <code>node_modules</code> 에 있는 ESLint를 수행하는 스크립트가 필요하다. 아래 내용을 추가하자.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &quot;lint&quot;: &quot;./node_modules/.bin/eslint .&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>ci.yaml 파일에 <code>npm run lint</code>를 추가하자.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="string">--if-present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">lint</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>2. Test</strong>: Jest를 설치하고, 아래 내용을 추가하자.</p>
<p>폴더를 <code>/tests</code>로 설정했는데, 굳이 그럴 필요가 없다면 생략해도 된다.</p>
<p>Test가 하나라도 실패하면 당연히 빌드는 실패하게 된다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &quot;test&quot;: &quot;./node_modules/.bin/jest --verbose ./tests&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52637116/specify-jest-test-files-directory">Jest 폴더 설정 스택 오버플로우 설명</a></p>
<hr>
<p>Jest는 글로벌로 API를 expose하기 때문에 ESLint error가 나지 않으려면 플러그인을 설치해줘야 한다.</p>
<p><code>npm i --save-dev eslint-plugin-jest</code> 로 ESLint-Plugin-Jest를 설치한다.</p>
<p><code>eslintrc.yml</code> 파일에 아래의 내용을 추가한다.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//...</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="string">//...</span></span><br><span class="line">  <span class="attr">jest:</span> <span class="literal">true</span> <span class="comment"># Jest 글로벌</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">jest</span> <span class="comment"># Jest 테스트를 위해 플러그인이 필요하다.</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="string">//...</span></span><br><span class="line">  <span class="comment"># Jest Eslint 옵션은 0,1,2 (off, warn, error) 만 옵션으로 사용 가능하다.</span></span><br><span class="line">  <span class="attr">jest/no-disabled-tests:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">jest/no-focused-tests:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">jest/no-identical-title:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">jest/prefer-to-have-length:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">jest/valid-expect:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31629389/how-to-use-eslint-with-jest">ESLint 설정 스택오버플로우 설명</a></p>
<h4 id="3-빌드-성공-전에-Merge-Button을-누를-수-없게-하기"><a href="#3-빌드-성공-전에-Merge-Button을-누를-수-없게-하기" class="headerlink" title="3. 빌드 성공 전에 Merge Button을 누를 수 없게 하기"></a><strong>3. 빌드 성공 전에 Merge Button을 누를 수 없게 하기</strong></h4><p>GitHub에서 Branch Protection Rule이라는 기능을 제공한다. 레포지토리 &gt; Settings 탭 &gt; Branches 탭 &gt; Branch protection rules 탭 &gt; Add Rule 버튼 클릭 후 아래와 같이 설정하였다.</p>
<p><img src="/images/github-branch-protection.png"></p>
<h4 id="4-끝"><a href="#4-끝" class="headerlink" title="4. 끝!"></a><strong>4. 끝!</strong></h4><ul>
<li>ci.yml 파일을 Push 하자.</li>
<li>Master에 Push하거나 Pull Request를 올리자</li>
<li>CI가 동작함을 확인하자.</li>
</ul>
<p>글쓴이는 아래처럼 잘 동작함을 확인했다.</p>
<p><img src="/images/github-actions-lint-and-test.png"></p>
<p><img src="/images/github-actions-merge-button.png"></p>
<p><img src="/images/github-actions-done.png"></p>
<p>코드 베이스가 작고, 테스트가 사실상 전무하지만, 그래도 Node 설치부터 실행까지 20초밖에 걸리지 않는다는 점은 신기하고 인상적이다. Public 레포로 작업하면 좋은 성능의 CI를 무료로 사용할 수 있어 좋은 것 같다.</p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><ol>
<li><p>CD 과정도 구축하기. Docker 레지스트리 배포가 일반적인 듯하다. (쿠버네티스가 사용되는듯)</p>
</li>
<li><p>Jobs에서 build 하나만으로 괜찮은 것 같긴 한데, 나누는 case는 뭐가 있을지 확인해보기</p>
</li>
<li><p><code>npm run build</code> 명령어로 무엇을 실행할지 고민해보기. Node.js로 프로덕션 배포를 해 본 적이 없어서 뭐가 필요한지 아직 파악하지 못 했다.</p>
</li>
<li><p>GitHub Actions에 대해 이론적으로 더 공부해보고, 할 수 있는 것들 더 많이 배우기</p>
</li>
<li><p>Git Hooks라는 개념도 있다고 한다. 로컬 수준에서도 프로세스를 자동화할 수 있는 것 같은데, 한 번 알아봐야겠다.</p>
</li>
</ol>
<hr>
<h3 id="기타-내용-정리"><a href="#기타-내용-정리" class="headerlink" title="기타 내용 정리"></a><strong>기타 내용 정리</strong></h3><h4 id="Why-is-it-free"><a href="#Why-is-it-free" class="headerlink" title="Why is it free?"></a><strong>Why is it free?</strong></h4><p>public은 무료, private은 사용량 만큼 낸다고 한다.</p>
<p>왜 무료일지 확인해봤는데, <a target="_blank" rel="noopener" href="https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/">출처</a>에 따르면 Open Source 프로젝트 지원이라는 명목이다.</p>
<blockquote>
<p>We want every open source project to be productive and use best practices, so Actions is free for the 40 million developers on GitHub to use with public repositories. For private repositories, Actions offers simple, pay-as-you-go pricing. (…)</p>
</blockquote>
<h4 id="Supported-OS"><a href="#Supported-OS" class="headerlink" title="Supported OS"></a><strong>Supported OS</strong></h4><p>위에서 언급했듯, Ubuntu, Windows, MacOS 이다. Docker 컨테이너로 작동한다고 하며, 매 번 Fresh한 Docker Container가 제공된다고 한다.</p>
<h4 id="계기가-된-Video"><a href="#계기가-된-Video" class="headerlink" title="계기가 된 Video"></a><strong>계기가 된 Video</strong></h4><p>참고한 유튜브 비디오. 간단하게 Github Actions이 뭔지 영상을 보기만 해도 파악이 가능하다.</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana">https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana</a></p>
<p>글쓴이는 도커 기본 개념과 컨테이너 개념에 조금 익숙한 상태로 봐서 쉽다고 느꼈지만, 정말 아무것도 모른다면 조금 어려울 수도 있다. 영상에서도 언급했듯 Github Actions의 설정 파일은 Docker와 비슷하다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-02T12:30:00.000Z" title="2021-01-02T12:30:00.000Z">21-01-02</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Docker/">Docker</a></span><span class="level-item">13분안에 읽기 (약 1933 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/docker-diamol-1-hello-world/">[1 Month Docker] 1. Docker의 기본 컨셉과 Hello World</a></h1><div class="content"><p>Docker의 기본 컨셉을 다루고, 간단한 Hello World를 실습한다.</p>
<hr>
<p><strong><em>build, share, run</em></strong>:</p>
<ul>
<li>build: (생략)</li>
<li>share: <em>DockerHub</em>에서 이미지를 공유할 수 있다.</li>
<li>run: 공유된 이미지를 통해 누구나 컨테이너를 실행할 수 있다.</li>
</ul>
<p><strong>이미지?</strong> 일단 Docker의 재사용 단위라고 생각하자.</p>
<p><strong>도커 컨테이너?</strong> 애플리케이션을 담은 박스.</p>
<ul>
<li><p>이 박스에는 기기명, IP 주소, 스토리지가 딸린, Docker에서 만들어낸 논리적인 가상 컴퓨터가 있다.</p>
</li>
<li><p>애플리케이션은 이 컴퓨터에서 실행된다.</p>
</li>
<li><p>박스 안의 애플리케이션은 박스 밖을 볼 수 없다.</p>
</li>
<li><p>이 박스는 여러 개가 동시에 실행될 수도 있다.</p>
</li>
<li><p>박스는 같은 실제 컴퓨터를 공유하면서 격리된 환경을 갖는다.</p>
</li>
</ul>
<p><strong>일관된 작업 방식</strong>: 아무리 애플리케이션이 복잡하더라도 Docker Image 단위로 Share, Run 만 하면 된다. 몇 개의, 어떤 컴포넌트, 설정 파일, 라이브러리를 사용하는지는 중요하지 않다.</p>
<p><strong>Portability</strong>: Docker가 있는 컴퓨터에선 명령어 하나로 곧바로 설치가 가능하다.</p>
<p><strong>효율적인 자원 활용</strong>: 도커는 VM이 그렇듯, 여러 애플리케이션을 동시에 실행하는 것으로 컴퓨터 자원을 최대한 활용할 수 있다. 다만 VM보다 나은 점을 아래 표로 정리했다.</p>
<table>
<thead>
<tr>
<th align="center">사용 자원</th>
<th align="center">Docker</th>
<th align="center">VM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Guest OS 사용 여부</td>
<td align="center">No (커널 공유)</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">가상화 리소스 비용</td>
<td align="center">매우 낮음 (커널 공유)</td>
<td align="center">독립적인 OS 수준</td>
</tr>
<tr>
<td align="center">Gust OS Update 다운로드</td>
<td align="center">Base Image 교체</td>
<td align="center">수동 설치</td>
</tr>
<tr>
<td align="center">아주 작은 앱 띄우기</td>
<td align="center">Yes</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">인수인계/배포 비용</td>
<td align="center">A Dockerfile</td>
<td align="center">hours of installation</td>
</tr>
</tbody></table>
<p>책에서는 Guest OS License 비용 문제에서도 차이가 난다고 언급했지만, Docker Image 형태로 쓴다고 해서 License 비용이 낮아지거나 사라지지는 않을 것 같다. 반대로 대수가 늘어나기 때문에 Open Source 기반으로 사용하지 않을까 생각이 든다.</p>
<p><a target="_blank" rel="noopener" href="https://indico.cern.ch/event/384358/contributions/909221/attachments/1170419/1689415/151014_hepix_wataru_takase.pdf">네이티브 vs Docker vs KVM(VM 계열) 벤치마크</a> p.19 참고</p>
<p><strong>주요 도커 명령어</strong>:</p>
<table>
<thead>
<tr>
<th align="left">명령어</th>
<th>기능</th>
</tr>
</thead>
<tbody><tr>
<td align="left">docker container ls</td>
<td>실행 중인 컨테이너의 목록 표시</td>
</tr>
<tr>
<td align="left">docker container ls –all</td>
<td>전체 컨테이너의 목록 표시 (종료된 것 포함)</td>
</tr>
<tr>
<td align="left">docker container run –detach {IMG}</td>
<td>컨테이너를 백그라운드로 실행</td>
</tr>
<tr>
<td align="left">docker container run –publish 8088:80 {IMG}</td>
<td>Host의 8088 포트로 Listen하여 컨테이너의 80포트로 전달</td>
</tr>
<tr>
<td align="left">docker container inspect {ID}</td>
<td>컨테이너의 상세 정보를 JSON으로 출력</td>
</tr>
<tr>
<td align="left">docker container stats {ID}</td>
<td>컨테이너가 사용하는 Host 자원 출력</td>
</tr>
<tr>
<td align="left">docker container rm (–force) {ID}</td>
<td>컨테이너를 완전히 제거 (실행 중인 경우 force)</td>
</tr>
<tr>
<td align="left">docker container rm –force $(docker container ls –all – quiet)</td>
<td>모든 컨테이너를 강제 제거</td>
</tr>
</tbody></table>
<p>종료된 컨테이너는 제거된 것이 아니어서 계속 용량을 차지하며, 아래 작업이 가능하다.</p>
<ul>
<li>그대로 다시 실행</li>
<li>컨테이너 내의 App이 생성한 로그를 확인</li>
<li>파일을 Host에서 or Host로 복사</li>
</ul>
<p><strong>컨테이너의 네트워크</strong>:</p>
<ul>
<li><p>기본적으로, 각 컨테이너는 Host 네트워크에 대해 격리된다. 컨테이너는 Host 내의 가상 사설망으로 구성된다.</p>
</li>
<li><p>Docker는 Host의 네트워크 트래픽을 가로채 컨테이너로 보낼 수 있다.</p>
</li>
</ul>
<p><strong>Docker가 컨테이너를 실행하는 방법</strong>:</p>
<p><strong>Docker Engine</strong>은 Docker Backend이다. Docker API(HTTP 기반의 REST API)를 제공한다. 이미지 재사용에 관한 기능은 직접 하고, 컨테이너는 <code>containerd</code>에 기반해 관리한다고 한다. containerd는 CNCF에 의해 관리되는 오픈소스 프로젝트이다.</p>
<p><strong>Docker CLI</strong>: Docker의 Frontend이다. Docker Engine과 소통하는 방법을 제공한다.</p>
<p><strong>기타 정보</strong>:</p>
<p>Docker는 가장 인기가 많은 컨테이너 플랫폼이지만, 다른 기술도 있으며 컨테이너 기술로 인해 플랫폼에 락인될 걱정은 하지 않아도 된다.</p>
<p>Docker는 이미지를 사용해 컨테이너를 실행한다. 이 때 이미지가 로컬에 있어야 한다. <code>docker container run</code>을 할 때에 없으면 <code>docker pull</code>을 받게 된다. 한 번 다운로드한 이미지는 재사용한다.</p>
<p>도커 컨테이너 Id는 컨테이너의 hostname이 된다.</p>
<p>컨테이너를 선택할 때, 이름 앞 몇글자만 입력해도 된다. 예: <code>f1695...</code>일 때, <code>docker container top f1</code>만 해도 된다.</p>
<hr>
<h3 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h3><p><a target="_blank" rel="noopener" href="https://github.com/sixeyed/diamol/tree/master/ch02/lab">솔루션</a></p>
<p><strong>목표</strong>: 실행 중인 Apache 컨테이너에서 index.html을 변경하라.</p>
<p><strong>힌트</strong>:</p>
<ul>
<li><p>컨테이너는 독립된 파일 시스템을 가지며, 컨테이너 내의 웹 서버 또한 컨테이너의 파일 시스템의 파일을 제공한다.</p>
</li>
<li><p><code>docker container</code> 명령어를 통해 컨테이너에서 수행할 수 있는 명령어 목록을 볼 수 있다.</p>
</li>
<li><p><code>docker &#123;command&#125; --help</code>를 통해 해당 명령어의 상세 설명을 확인할 수 있다.</p>
</li>
<li><p><code>diamol/ch02-hello-diamol-web</code> 이미지는 <code>/usr/local/apache2/htdocs</code> 폴더 내의 파일을 정적으로 제공한다. (윈도우의 경우, <code>C:\user\local\apache2\htdocs</code> 폴더.)</p>
</li>
</ul>
<hr>
<h3 id="내-풀이"><a href="#내-풀이" class="headerlink" title="내 풀이"></a>내 풀이</h3><p>풀이 과정을 서술함.</p>
<p><strong>1. 제공된 컨테이너 트러블 슈팅</strong>: 일단 <code>ch02-hello-diamol-web</code> 의 기본 포트인 8088은 접속할 수가 없었다. 그래서 DockerHub 가서 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/httpd">Apache 이미지</a>를 받아서 실행해봤다. 8080 포트로 잘 되더라. 이 때 명령어가 <code>$ docker run -dit --name my-apache-app -p 8080:80 -v &quot;$PWD&quot;:/usr/local/apache2/htdocs/ httpd:2.4</code> 였는데, 배운 점:</p>
<ul>
<li><code>-dit</code>: <code>--detach --interactive</code>의 약자인데, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41916435/practically-what-is-the-difference-between-docker-run-dit-itd-vs-docker-run">-dit가 필요한 이유</a>를 보면, bash 스크립트가 엔트리 포인트인 경우 <code>-d</code>만 하면 정지된 상태에서 아무것도 못한다고 한다. <code>-it</code>를 줘서 셸이 있어야 스크립트가 실행된다고 한다.</li>
<li><code>-p</code>: <code>--publish</code>의 약자이다.</li>
<li><code>-v</code>: 아직 안 배웠지만, 볼륨 개념일 것으로 추정된다.</li>
</ul>
<p>도커 자체의 네트워크 문제가 아님을 알고, 80으로 하니까 잘 됐는데, 이유는 모르겠다.</p>
<p><strong>2. 컨테이너 셸 접속</strong>: 일단 <code>docker container exec -it --tty &#123;id&#125; /bin/bash</code> 로 접속할 순 있었다. (나오는건 exit 치면 된다.)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22272401/what-does-it-mean-to-attach-a-tty-std-in-out-to-dockers-or-lxc"><code>--tty</code> 옵션에 대한 글</a> 참고</li>
</ul>
<p><strong>3. 직접 파일 수정</strong>: 무슨 망할 기반 이미지를 쓰는지 vi 밖에 지원을 하지 않아서 직접 수정은 포기했다. 파일을 복사해야 하는데, 어떻게 하는지 모르겠다.</p>
<p><strong>4. 파일 복사 방법</strong>: Dockerfile을 수정하는 게 가장 쉬울 것 같았지만, 제공되지 않아서 할 수 없었다. 복사를 해야 하는데, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22907231/how-to-copy-files-from-host-to-docker-container">호스트에서 컨테이너로 파일 복사하기</a>로 <code>docker cp</code> 명령어를 배워서 수행했고, 성공했다.</p>
<hr>
<p>매우 작은 작업이었지만 너무 오랜 기간이 걸렸다. 아무래도 기록하면서 하니까 오래 걸리고, 책의 내용을 요약했음에도 불구하고 며칠만에 다시 보는거여서 오래 걸렸다.</p>
<p>많이 헤맨 덕분에, <code>docker container ls</code>, <code>docker container rm</code>, <code>docker container exec</code>, <code>docker container run</code>은 정말 많이 사용해서 다행이다.</p>
<hr>
<p>참고 자료: Docker In A Month of Lunches (Manning, 2020)</p>
<hr>
<p>추가로 읽을 것: <a target="_blank" rel="noopener" href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">Docker와 VM</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-01T06:30:00.000Z" title="2021-01-01T06:30:00.000Z">21-01-01</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">10분안에 읽기 (약 1450 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-2-module/">2장 (2/3): Node.js의 모듈 시스템</a></h1><div class="content"><p>이 글은 Node.js의 모듈 시스템에 대해 소개한다.</p>
<hr>
<h3 id="1-모듈-시스템의-필요성과-Javascript의-방식"><a href="#1-모듈-시스템의-필요성과-Javascript의-방식" class="headerlink" title="1. 모듈 시스템의 필요성과 Javascript의 방식"></a>1. 모듈 시스템의 필요성과 Javascript의 방식</h3><p>모듈 시스템은 프로그램의 구성 요소들 간의 역할을 분리하고, 의존 관계와 구현 상세를 격리하는데 필수적이다. 모듈 시스템의 문법으로 보면, 소스 파일간의 import, export를 하는 것인데, 개념 상 Java의 접근 제한자 - <code>private, protected, public</code> - 도 모듈의 역할 중 일부를 수행 한다고 할 수 있다.</p>
<p>Javascript 모듈 시스템으로는 대표적으로 ESM, CommonJs 라는 두 개의 기술이 있는데, 현재의 Node.js는 ESM, CommonJs를 모두 지원한다.</p>
<table>
<thead>
<tr>
<th align="center">종류</th>
<th align="center">ESM</th>
<th align="center">CommonJS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">제정 시기</td>
<td align="center">ES6에 제정됨</td>
<td align="center">ESM 이전의 대표적인 비표준</td>
</tr>
<tr>
<td align="center">문법(Node 기준)</td>
<td align="center"><code>import / export</code></td>
<td align="center"><code>require / module.export</code></td>
</tr>
<tr>
<td align="center">Node.js 지원 여부</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">Browser 지원 여부</td>
<td align="center">최신 브라우저에서 지원</td>
<td align="center">CommonJs.js 로딩 필요</td>
</tr>
</tbody></table>
<p>자세한 역사와 기타 모듈 시스템의 종류는 <a target="_blank" rel="noopener" href="https://d2.naver.com/helloworld/12864">JavaScript 표준을 위한 움직임: CommonJS와 AMD | Naver D2</a>를 참고.</p>
<hr>
<h3 id="2-Revealing-Module-Pattern"><a href="#2-Revealing-Module-Pattern" class="headerlink" title="2. Revealing Module Pattern"></a>2. Revealing Module Pattern</h3><p>Javascript에는 접근 제한자가 없다. 접근을 원천적으로 제한하는 방법 중, 공개할 부분만 객체로 담아 내보내는 패턴이 있다. Private 변수는 클로저를 통해 접근할 수 있으므로, 꽤 괜찮은 방법이다.</p>
<p>Revealing Module 패턴을 구현하는 방법은 대표적으로 <code>IIFE</code>(즉시 실행 함수 표현식)가 있다. IIFE는 익명 함수를 ()로 감싼 후 즉시 실행하는 함수 호출 방식이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> privateFoo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* private functionality */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> privateCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increase = <span class="function">() =&gt;</span> ++privateCounter;</span><br><span class="line">  <span class="keyword">const</span> decrease = <span class="function">() =&gt;</span> --privateCounter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이 객체를 반환하므로, 외부에선 privateFoo, Bar에 접근할 수 없다.</span></span><br><span class="line">  <span class="keyword">return</span> &#123; increase, decrease &#125;;</span><br><span class="line">&#125;)(); <span class="comment">// 즉시 실행하여, &#123; increase, decrease &#125; 객체가 반환된다.</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-CommonJs의-require-방식에-대해"><a href="#3-CommonJs의-require-방식에-대해" class="headerlink" title="3. CommonJs의 require 방식에 대해"></a>3. CommonJs의 require 방식에 대해</h3><p>CommonJs는 <code>const moduleA = require(&#39;./moduleA&#39;);</code>와 같이 모듈을 로딩하는 문법을 제공한다. <code>require</code>는 <strong>동기로</strong> 작동하고, 한 번 로딩한 모듈은 캐시된다. 내보낼 때에는 각 모듈별로 제공되는 <code>exports</code> 객체에 필드를 할당하는 방식으로 진행한다.</p>
<p>모듈은 캐싱되므로 항상 동일한 객체를 반환한다.</p>
<p>아래는 <code>require</code>의 수도 코드이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="function">(<span class="params">modulePath</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// path를 가져오고, unique한 id로 활용한다.</span></span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">require</span>.resolveAbsolutePath(</span><br><span class="line">    modulePath,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 캐시된 모듈은 캐시를 반환한다.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">require</span>.cache[id])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>.cache[id].exports;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 처음 로딩하는 경우 새 exports 객체가 필요하다.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">    id,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 객체는 캐시한다.</span></span><br><span class="line">  <span class="built_in">require</span>.cache[id] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이 함수가 소스 코드를 읽어 exports 객체에 export 내용들을 할당한다.</span></span><br><span class="line">  readFileAndEvaluate(id, <span class="built_in">module</span>, <span class="built_in">require</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.cache = &#123;&#125;;</span><br><span class="line"><span class="built_in">require</span>.resolveAbsolutePath = <span class="function">(<span class="params">modulePath</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* implementation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>어느 범위까지 같은 인스턴스가 반환될까?</strong></p>
<ol>
<li><p>같은 패키지로 빌드된다면 하나의 인스턴스를 공유할 것이다.</p>
</li>
<li><p><code>package.json</code>별로 독립적으로 dependency를 관리하기 때문에, 각 패키지간에 제 3의 모듈의 객체를 주고 받는 경우, 해당 객체는 버전 불일치가 있을 수 있다.</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://medium.com/learnwithrahul/understanding-npm-dependency-resolution-84a24180901b">A Simple Explanation | Medium (EN)</a></p>
<hr>
<h3 id="4-비동기-모듈-초기화"><a href="#4-비동기-모듈-초기화" class="headerlink" title="4. 비동기 모듈 초기화"></a>4. 비동기 모듈 초기화</h3><p>비동기로 객체를 초기화할 순 없다. require 함수가 동기로 작동하기 때문인데, 아무래도 <code>initialize</code>와 같은 메소드를 호출하는 형태로 비동기 API를 만들어서 활용하는 수 밖에 없을 듯하다.</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/29490138/nodejs-async-module-initialization-code">관련 스택 오버 플로우</a> 참고.</p>
<hr>
<h3 id="5-순환-참조가-있는-경우"><a href="#5-순환-참조가-있는-경우" class="headerlink" title="5. 순환 참조가 있는 경우"></a>5. 순환 참조가 있는 경우</h3><p>Node.js 환경에서 순환 참조를 하는 경우 한 모듈이 먼저 로딩되기 때문에, 동기로 로딩하는 경우, 한 쪽에서는 null, 한 쪽에서는 정상 로딩이 될 수 밖에 없다. 아니면 명확한 순서를 지정해준다면 해결할 수도 있겠지만(A[A.B = null]-&gt;B[B.A = A]-&gt;[A.B = B]), 순서를 명시하는 API가 따로 있는지 잘 모르겠다.</p>
<ol>
<li><p>한 쪽에서 느린 초기화를 진행한다. (Lazy-Init) - 순서 정하기와 사실상 동일함.</p>
</li>
<li><p>순환 참조 관계에 있는 두 객체를 제 3의 객체에 의존하도록 한다. <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1450997/resolving-circular-dependencies-with-dependency-injection">관련 스택 오버 플로우</a> - 이 부분은 잘 이해하지 못 했다.</p>
</li>
</ol>
<hr>
<h3 id="어떻게-export-해야-좋은-모듈일까"><a href="#어떻게-export-해야-좋은-모듈일까" class="headerlink" title="어떻게 export 해야 좋은 모듈일까?"></a>어떻게 export 해야 좋은 모듈일까?</h3><h4 id="1-Substack-패턴"><a href="#1-Substack-패턴" class="headerlink" title="1. Substack 패턴"></a>1. Substack 패턴</h4><p>모듈의 기능을 객체가 아닌 함수 단위로 노출한다. 진입점이자 주가 되는 함수를 <code>module.exports</code>로 내보내는데, 따라서 <code>const logger = require(&#39;./logger&#39;)</code>와 같이 바로 사용할 수 있는 함수가 된다. 또한, <code>logger.verbose(msg);</code> 와 같이 서브 함수들도 내보내, 사용하는 입장에서 기능의 중요도를 쉽게 파악할 수 있게 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = mainFn;</span><br><span class="line"><span class="built_in">exports</span>.subFn1 = subFn1;</span><br><span class="line"><span class="comment">// 2...N-1</span></span><br><span class="line"><span class="built_in">exports</span>.subFnN = subFnN;</span><br></pre></td></tr></table></figure>
<p>(ex)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 메인 함수</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">msg</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 서브 함수 1</span></span><br><span class="line"><span class="built_in">exports</span>.verbose = <span class="function">(<span class="params">msg</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[verbose] <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-생성자-내보내기"><a href="#2-생성자-내보내기" class="headerlink" title="2. 생성자 내보내기"></a>2. 생성자 내보내기</h4><p>prototype 기반으로 생성자를 만들거나, ES6 Class를 활용하여 생성자를 만들어, 생성자를 내보낸다. 사용하는 입장에선 객체의 기능을 확장할 수도 있고, 쉽게 인스턴스를 생성할 수도 있고, 사용하기도 깔끔한 방법이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">log</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">verbose</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`[verbose] <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-인스턴스-내보내기"><a href="#3-인스턴스-내보내기" class="headerlink" title="3. 인스턴스 내보내기"></a>3. 인스턴스 내보내기</h4><p>생성자 내보내기와 거의 같지만, 싱글톤이 자동으로 구현되는 셈이므로 쉽게 활용하기 좋다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">log</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">verbose</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`[verbose] <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Logger(<span class="string">&#x27;App&#x27;</span>);</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-01T02:00:00.000Z" title="2021-01-01T02:00:00.000Z">21-01-01</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">5분안에 읽기 (약 776 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-2-cps/">2장 (1/3): CPS 패턴</a></h1><div class="content"><p>이 글은 CPS 패턴과 CPS가 Node.js에서 어떻게 사용되고, 어떤 점을 주의해야 하는지 다룬다.</p>
<hr>
<h3 id="1-CPS-패턴"><a href="#1-CPS-패턴" class="headerlink" title="1. CPS 패턴"></a>1. CPS 패턴</h3><p>Node.js는 1장에서 살펴봤듯 비동기 특성을 가지며, 따라서 Node.js 앱은 대부분의 일을 비동기로 처리할 수 밖에 없다. 비동기를 처리하는 방법 중 CPS, Continous Passing Style을 소개한다.</p>
<p>CPS: 비동기 API를 사용할 때, 콜백 함수를 인자로 넘기는 패턴이다.</p>
<ul>
<li><strong>왜 사용하는가</strong>: 비동기 API는 return을 할 수 없는데, 함수의 실행이 끝나기 전에 제어권이 넘어가기 때문이다. 이를 해결하기 위해선 결과를 다른 함수에 넘기면 된다.</li>
<li><strong>장점</strong>: 간단하고 효과적이다.</li>
<li><strong>단점</strong>: 호출 깊이가 깊어지면 가독성이 감소된다. Callback Hell이라고 불린다.</li>
</ul>
<hr>
<h3 id="2-Node-js에서의-CPS-패턴"><a href="#2-Node-js에서의-CPS-패턴" class="headerlink" title="2. Node.js에서의 CPS 패턴"></a>2. Node.js에서의 CPS 패턴</h3><p>Node.js는 CPS 패턴을 사용할 때 일관된 규칙을 따라야 한다.</p>
<ul>
<li>argument 순서에 관한 규칙: <code>(...params, callback)</code> 과 같이, callback 함수를 마지막 인자로 넘겨야 한다.</li>
<li>callback 함수의 argument에 관한 규칙: <code>(err, ...args)</code> 와 같이, err가 첫 인자여야 한다.</li>
<li><code>err</code> 인자의 경우, 항상 <code>Error()</code> 객체여야 한다. <strong>(이 부분은 잘 지켜지지 않는 듯 하다.)</strong></li>
</ul>
<hr>
<h3 id="3-CPS-패턴의-콜-스택"><a href="#3-CPS-패턴의-콜-스택" class="headerlink" title="3. CPS 패턴의 콜 스택"></a>3. CPS 패턴의 콜 스택</h3><p>Node.js에서 비동기 API를 호출하는 경우, callback 함수는 프로그래머가 예상한 호출 순서로 구성된 스택을 갖지 않는다. 비동기 API가 완료됐을 때, 이벤트 루프에 의해 단일 함수로 Queue에 쌓인 후 다른 타이밍에 실행되기 때문에 새로운 스택에서 실행된다. 비동기 함수에서 예외를 던지면, <code>Error</code>를 반환하며 프로세스가 종료된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readJsonThrows = <span class="function">(<span class="params">filename, cb</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);</span><br><span class="line">      cb(<span class="literal">null</span>, <span class="built_in">JSON</span>.parse(data));</span><br><span class="line">      <span class="comment">// cb이 없거나, data가 불량인 경우 exception 발생 가능.</span></span><br><span class="line">      <span class="comment">// 콜백 함수 내에서 try-catch하지 않는 경우 프로세스가 죽는다.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 여기서도 catch할 수 없음. 호출 스택은 fs.readFile에서 끝나고,</span></span><br><span class="line">    <span class="comment">// cb은 별개의 새 스택에서 실행되기 때문</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 JSON.parse에서 오류나는 경우, 프로세스가 종료된다.</span></span><br><span class="line">readJsonThrows(<span class="string">&#x27;C./test.json&#x27;</span>, <span class="function">(<span class="params">f</span>) =&gt;</span> f);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">SyntaxError: Unexcepted end of JSON input</span></span><br><span class="line"><span class="comment">    at JSON.parse</span></span><br><span class="line"><span class="comment">    at FSReqCallback.readFileAfterClose (internal/...)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-Node-js에서-비동기를-처리할-때-절대-하지-말아야-할-점들"><a href="#4-Node-js에서-비동기를-처리할-때-절대-하지-말아야-할-점들" class="headerlink" title="4. Node.js에서 비동기를 처리할 때 절대 하지 말아야 할 점들"></a>4. Node.js에서 비동기를 처리할 때 절대 하지 말아야 할 점들</h3><h4 id="1-결괏값을-동기-비동기-2가지-방식으로-전달하지-않는다"><a href="#1-결괏값을-동기-비동기-2가지-방식으로-전달하지-않는다" class="headerlink" title="1. 결괏값을 동기, 비동기 2가지 방식으로 전달하지 않는다."></a>1. 결괏값을 동기, 비동기 2가지 방식으로 전달하지 않는다.</h4><ul>
<li><p>결괏값이 비동기일것을 기대하고 이벤트 리스너를 등록할 때, 동기로 결괏값이 제공되는 경우 이벤트 리스너가 동작하지 않는다.</p>
</li>
<li><p>동기 반환값을 비동기화 한다. <code>setTimeout, setImmediate, nextTick, Promise</code> 등이 가능하다.</p>
</li>
</ul>
<h4 id="2-Callback-함수를-argument로-받는-동기-함수를-작성하지-않는다"><a href="#2-Callback-함수를-argument로-받는-동기-함수를-작성하지-않는다" class="headerlink" title="2. Callback 함수를 argument로 받는 동기 함수를 작성하지 않는다."></a>2. Callback 함수를 argument로 받는 동기 함수를 작성하지 않는다.</h4><ul>
<li>동기 API는 바로 결괏값을 받는 형태로 코드를 작성하면 된다.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-12-27T03:13:00.000Z" title="2020-12-27T03:13:00.000Z">20-12-27</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">9분안에 읽기 (약 1360 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-1-reactor-pattern/">1장: Reactor 패턴 (내용 검증 필요)</a></h1><div class="content"><p>1장은 Node.js에 대한 소개하는 챕터이다.</p>
<hr>
<p>주의!<br>해당 글의 내용은 부정확한 내용이 아주 많을 수 있습니다. 책의 설명이 추상적이고 OS 개념이 많이 필요하므로 추후 정리가 완료되는 경우 따로 표시하겠습니다.</p>
<hr>
<h3 id="Node-js-철학-Node-Way"><a href="#Node-js-철학-Node-Way" class="headerlink" title="Node.js 철학 (Node Way)"></a>Node.js 철학 (Node Way)</h3><p>최소 기능: 기능 개수를 최소한되므로, 개발자, 사용자 모두에게 간단함</p>
<ol>
<li> Node.js 자체 뿐만 아니라 node 기반 모듈을 설계할 때도 동일하게 적용</li>
<li> KISS 원칙: 부족하더라도 복잡함보다 단순함이 더 낫다</li>
</ol>
<hr>
<h3 id="Reactor-패턴과-Node-js-이벤트-루프"><a href="#Reactor-패턴과-Node-js-이벤트-루프" class="headerlink" title="Reactor 패턴과 Node.js 이벤트 루프"></a>Reactor 패턴과 Node.js 이벤트 루프</h3><p><strong>Reactor 패턴</strong>은 Node.js의 비동기 특성 - Node.js에서 여러 요청이 동시에 있는 경우는 항상 비동기 방식으로 작업을 처리한다 - 의 원인이자, 비동기 방식으로 작업을 처리하는 방법에 해당한다. Reactor 패턴을 배우기 전에, 동시성을 처리하는 2가지 방법에 대해서 알아보자.</p>
<p><strong>Blocking I/O</strong> : <u>느린 I/O</u>를 <u>기다리는</u> 방식</p>
<ol>
<li><p><strong>많은 스레드 개수</strong>: 소켓의 데이터를 매번 기다리게 되면 각 연결 별로 스레드가 적어도 하나씩 돌아야 한다. 기다리는 시간에 타 사용자가 기다리지 않게 하기 위해서이다.</p>
</li>
<li><p><strong>비효율적인 대기 시간</strong>: I/O가 CPU에 비해 매우 느리기 때문에 블로킹 API는 스레드의 유휴 시간이 처리 시간에 비해 압도적으로 길 수 밖에 없다. 스레드가 아무 일을 하지 않은 상태로 긴 시간 존재한다.</p>
</li>
<li><p><strong>스레드의 비용</strong>: 스레드는 그 비용이 싸지 않다. 아주 많은 스레드가 있는 경우, Context Switching만 해도 비용이 매우 클 것이고, 적은 스레드가 있는 경우 사용자를 처리하지 못하므로 비즈니스적으로 비용이 매우 클 것이다.</p>
</li>
</ol>
<p><strong>Non-blocking I/O</strong>: 비동기 API를 호출 시 바로 제어권을 반환(내부적으로 특정 상수를 반환)하여 CPU 유휴 시간을 최소화한다.</p>
<ol>
<li><p><strong>Polling</strong>: 비효율적으로 I/O를 처리하는 방식으로, 리소스는 데이터가 없을 때 읽기 조작을 요청 받는 경우 <code>EAGAIN</code>을 반환하는데, 이 때문에 값이 필요한 입장에선 리소스를 계속 확인해야 한다. 이걸 <code>BUSY_WAITING</code>이라고 하는데, CPU를 계속 활용하므로 효율적이지 못하다.</p>
</li>
<li><p><strong>동기 이벤트 디멀티플렉서</strong>: 논블로킹을 처리하는 효율적인 방법으로, 이벤트가 완료될 때마다 큐에 이벤트를 쌓아놓고 처리를 수행하는 객체. 이벤트가 없으면 Block 상태로 대기한다.</p>
<ol>
<li><p><strong>이벤트 통지자</strong>가 감시 대상 리소스의 자원이 읽기가 가능할 때(즉, 이벤트가 완료되었을 때) Demultiplexer에게 통지한다. (이벤트 통지자 역할로 IOCP, epoll/kqueue 등이 있는 것 같다.)</p>
</li>
<li><p>Event가 발생하면 <strong>Event Demultiplexer</strong>가 깨어나 Queue에서 이벤트를 읽어들여 처리하면 됨. 이 시점에서 리소스의 I/O 작업은 (1)에서 이미 완료되어있으므로 동기식으로 처리하면 됨. 또한 처리 방식이 싱글 스레드이므로 공유 자원 문제도 존재하지 않는다.</p>
</li>
</ol>
</li>
</ol>
<p><strong>리액터 패턴</strong>: 이벤트 디멀티플렉서 + 이벤트 루프 + 이벤트 큐 + 실행 환경(<code>V8, 싱글 스레드!</code>)</p>
<ol>
<li><p>이벤트 디멀티플렉서는 I/O 처리가 끝나면 (완료된) 이벤트를 이벤트 큐에 넣어줌</p>
</li>
<li><p>이벤트 루프는 실행 환경 상에서 스택이 비는 경우(즉 모든 동기 코드가 실행이 끝났을 때 - 노드 환경에서 동기 코드는 얼마 없어서 최초의 동기 코드는 금방 끝나기 마련.), 이벤트 큐에서 이벤트를 꺼내어 실행 환경에 이벤트 핸들러를 올리고, 인자로 이벤트를 넘겨 수행함.</p>
<ol>
<li>만약 async 내에 async가 있다면 해당 이벤트는 또 이 과정을 거침.</li>
</ol>
</li>
</ol>
<p><strong>이벤트 디멀티플렉서의 구현체</strong></p>
<p><strong>libuv</strong>: 크로스 플랫폼으로(가상머신 느낌으로 각 OS에 대응되는 이벤트 통지자를 활용) 비동기 작업을 처리함. 단, libuv는 이벤트 디멀티플렉서 역할만 하는 게 아니라 이벤트 루프도 구현함.</p>
<p>참고: libuv에 이벤트루프가 포함돼있음: <img src="/images/libuv_arch.png"></p>
<p><strong>더 정확한 이벤트 디멀티플렉서, 이벤트 루프 구현 상세에 관한 글, 영상</strong></p>
<p><a target="_blank" rel="noopener" href="https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/">로우 레벨로 살펴보는 Node.js 이벤트 루프 | Evans Library</a></p>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/">Node.js 이벤트 루프, 타이머, <code>process.nextTick()</code> | Node.js</a> (놀랍게도 이 문서가 더 어려운 것 같다…)</p>
<p>브라우저 환경에서의 이벤트 루프(자막 있음, 자세함!):<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=cCOL7MC4Pl0&ab_channel=JSConf">Jake Archibald: In The Loop | JSConf.Asia</a></p>
<p>아마도 이벤트 루프에 대한 가장 유명하고, 쉬운 설명:<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&ab_channel=JSConf">What the heck is the event loop anyway? | JSConf EU</a></p>
<hr>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-10T11:00:00.000Z" title="2019-09-10T11:00:00.000Z">19-09-10</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">함수형 자바스크립트</a></span><span class="level-item">8분안에 읽기 (약 1135 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/fjs-5-composition/">함수형 패러다임의 꽃: 함수 합성(composition)</a></h1><div class="content"><p>함수형 패러다임에서 최우선 설계 원칙으로 삼아진다고 하는 <strong>함수들의 합성</strong>에 대해서 설명한다.</p>
<h3 id="합성"><a href="#합성" class="headerlink" title="합성"></a>합성</h3><p>이전에 설명했던 <code>compose</code> 함수를 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span></span><br><span class="line">  fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    f(g(...args)),</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<h3 id="합성은-왜-하는걸까"><a href="#합성은-왜-하는걸까" class="headerlink" title="합성은 왜 하는걸까?"></a>합성은 왜 하는걸까?</h3><p>프로그램을 간결하고 실용적으로 작성할 수 있게 한다. 합성이 되므로 함수를 부담 없이 나눌 수 있게 되어 더 작고 의미있는 단위의 함수를 더 편하게 작성할 수 있다. 이렇게 합성된 함수는 가독성이 좋다. 아무래도 객체지향 패러다임을 강하게 지원하는 언어들에선 함수 합성이 쉽지 않다. 애초에 순수 함수를 작성하기도 쉽지 않다. <code>public static</code>으로 도배할 순 없기 때문이다.</p>
<h3 id="합성함수의-결합법칙"><a href="#합성함수의-결합법칙" class="headerlink" title="합성함수의 결합법칙"></a>합성함수의 결합법칙</h3><p>함수 합성은 <code>수학에서의 합성함수</code>와 같이 결합법칙이 성립한다. <code>compose(f, compose(g, h)) === compose(compose(f, g), h)</code>가 성립한다. Javascript 상에서 생성되는 함수가 동일하다는 것이 아니라, 그 실행 결과가 언제나 같다는 뜻이다.</p>
<h3 id="결합법칙이-무슨-소용일까"><a href="#결합법칙이-무슨-소용일까" class="headerlink" title="결합법칙이 무슨 소용일까"></a>결합법칙이 무슨 소용일까</h3><p>합성한 함수들을 재귀적으로 합성한 경우, <code>결합법칙</code>을 적용하면 결과 예측과 리팩토링 시에 유용하다.</p>
<p>그 예로, 아래 세가지 <code>loudLastUpper</code> 함수는 동일하다. 더 작고 더 의미있는 함수로 정의할수록 재사용성과 가독성은 높아진다.</p>
<p>버전 1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loudLastUpper = compose(</span><br><span class="line">  exclaim,</span><br><span class="line">  toUpperCase,</span><br><span class="line">  head,</span><br><span class="line">  reverse,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>버전 2 (리팩토링)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> last = compose(head, reverse);</span><br><span class="line"><span class="keyword">const</span> loudLastUpper = compose(</span><br><span class="line">  exclaim,</span><br><span class="line">  toUpperCase,</span><br><span class="line">  last,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>버전 3 (리팩토링)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> last = compose(head, reverse);</span><br><span class="line"><span class="keyword">const</span> angry = compose(exclaim, toUpperCase);</span><br><span class="line"><span class="keyword">const</span> loudLastUpper = compose(angry, last);</span><br></pre></td></tr></table></figure>
<h3 id="쓸모있고-재미있는-디버깅-방법"><a href="#쓸모있고-재미있는-디버깅-방법" class="headerlink" title="쓸모있고 재미있는 디버깅 방법"></a>쓸모있고 재미있는 디버깅 방법</h3><p>합성 함수를 디버깅하는 재밌는 방법이 있다. 흔히 <code>trace</code>라 부르는 유명한 함수인데, 항등함수(<code>const pass = x =&gt; x;</code>)에 <code>console.log</code>만 추가한 함수이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trace = <span class="function">(<span class="params">tag</span>) =&gt;</span> <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tag, x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 자동 커리</span></span><br><span class="line"><span class="keyword">const</span> trace = curry(<span class="function">(<span class="params">tag, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tag, x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용 예시</span></span><br><span class="line"><span class="keyword">const</span> toDebug = compose(</span><br><span class="line">  replace,</span><br><span class="line">  trace(<span class="string">&#x27;after A&#x27;</span>),</span><br><span class="line">  applyA,</span><br><span class="line">  trace(<span class="string">&#x27;after B&#x27;</span>),</span><br><span class="line">  applyB,</span><br><span class="line">  trace(<span class="string">&#x27;after last&#x27;</span>),</span><br><span class="line">  last,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>당연하게도 <code>trace</code> 함수는 순수하지 않다. <code>console</code>를 사용하기 때문이다.</p>
<h2 id="간단한-함수-합성-예제"><a href="#간단한-함수-합성-예제" class="headerlink" title="간단한 함수 합성 예제"></a>간단한 함수 합성 예제</h2><p>이하의 예제 코드는 아래의 <code>cars</code> 객체를 대상으로 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;Aston Martin One-77&#x27;</span>,</span><br><span class="line">    horsepower: <span class="number">750</span>,</span><br><span class="line">    dollar_value: <span class="number">1850000</span>,</span><br><span class="line">    in_stock: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="예제-1"><a href="#예제-1" class="headerlink" title="예제 1"></a>예제 1</h3><p>각 함수들의 정의는 <a target="_blank" rel="noopener" href="https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/appendix_c.md">이 문서</a>를 참고하라. 이 문서는 <a target="_blank" rel="noopener" href="https://ramdajs.com/docs/">ramdajs documentation</a>과도 호환된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isLastInStock = <span class="function">(<span class="params">cars</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> lastCar = last(cars);</span><br><span class="line">  <span class="keyword">return</span> prop(<span class="string">&#x27;in_stock&#x27;</span>, lastCar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after compose:</span></span><br><span class="line"><span class="keyword">const</span> isLastInStock = compose(</span><br><span class="line">  prop(<span class="string">&#x27;in_stock&#x27;</span>),</span><br><span class="line">  last,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="예제-2"><a href="#예제-2" class="headerlink" title="예제 2"></a>예제 2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> average = <span class="function">(<span class="params">xs</span>) =&gt;</span></span><br><span class="line">  reduce(add, <span class="number">0</span>, xs) / xs.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> averageDollarValue = <span class="function">(<span class="params">cars</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dollarValues = map(</span><br><span class="line">    (c) =&gt; c.dollar_value,</span><br><span class="line">    cars,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> average(dollarValues);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after compose:</span></span><br><span class="line"><span class="keyword">const</span> averageDollarValue = compose(</span><br><span class="line">  average,</span><br><span class="line">  map(prop(<span class="string">&#x27;dollar_value&#x27;</span>)),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="예제-3"><a href="#예제-3" class="headerlink" title="예제 3"></a>예제 3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fastestCar = <span class="function">(<span class="params">cars</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sorted = sortBy(<span class="function">(<span class="params">car</span>) =&gt;</span> car.horsepower);</span><br><span class="line">  <span class="keyword">const</span> fastest = last(sorted);</span><br><span class="line">  <span class="keyword">return</span> concat(fastest.name, <span class="string">&#x27; is the fastest&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after compose:</span></span><br><span class="line"><span class="keyword">const</span> fastestCar = compose(</span><br><span class="line">  append(<span class="string">&#x27; is the fastest&#x27;</span>),</span><br><span class="line">  prop(<span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">  last,</span><br><span class="line">  sortBy(prop(<span class="string">&#x27;horsepower&#x27;</span>)),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="함수-합성-예제-프로그램"><a href="#함수-합성-예제-프로그램" class="headerlink" title="함수 합성 예제 프로그램"></a>함수 합성 예제 프로그램</h2><h3 id="스펙"><a href="#스펙" class="headerlink" title="스펙"></a>스펙</h3><ol>
<li><p>검색어에 대응하는 URL을 생성한다.</p>
</li>
<li><p>flicker API를 호출한다.</p>
</li>
<li><p>결과 JSON에서 이미지 링크를 추출한다.</p>
</li>
<li><p>이미지를 HTML에 표시한다.</p>
</li>
</ol>
<h3 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h3><p>예제의 스펙에서 보았듯, 2단계 API 호출과 4단계 이미지 표시는 순수하지 않다. 일단 순수하지 않은 함수를 같이 사용하면서 예제를 구현한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 유틸 함수 선언</span></span><br><span class="line"><span class="keyword">const</span> prop = curry(<span class="function">(<span class="params">p, obj</span>) =&gt;</span> obj[p]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 순수하지 않은 함수</span></span><br><span class="line"><span class="comment">// Impure 객체로 접근하도록 하여 사용자에게 주의를 준다.</span></span><br><span class="line"><span class="keyword">const</span> Impure = &#123;</span><br><span class="line">  getJSON: curry(<span class="function">(<span class="params">callback, url</span>) =&gt;</span></span><br><span class="line">    $.getJSON(url, callback),</span><br><span class="line">  ),</span><br><span class="line">  setHtml: curry(<span class="function">(<span class="params">sel, html</span>) =&gt;</span></span><br><span class="line">    $(sel).html(html),</span><br><span class="line">  ),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  참고: 서버의 응답이 아래와 같은 형태로 구성됨</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    items: [</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        media: &#123;</span></span><br><span class="line"><span class="comment">          m: &#x27;&lt;image-link&gt;&#x27;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      &#123; ... &#125;,</span></span><br><span class="line"><span class="comment">      &#123; ... &#125;,</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&#x27;api.flicker.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;/services/feeds/photos-public.gne&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> query = <span class="function">(<span class="params">t</span>) =&gt;</span></span><br><span class="line">  <span class="string">`?tags=<span class="subst">$&#123;t&#125;</span>&amp;format=json&amp;jsoncallback=?`</span>;</span><br><span class="line"><span class="keyword">const</span> url = <span class="function">(<span class="params">t</span>) =&gt;</span></span><br><span class="line">  <span class="string">`https://<span class="subst">$&#123;host&#125;</span><span class="subst">$&#123;path&#125;</span><span class="subst">$&#123;query(t)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mediaUrl = compose(</span><br><span class="line">  prop(<span class="string">&#x27;m&#x27;</span>),</span><br><span class="line">  prop(<span class="string">&#x27;media&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mediaUrls = compose(</span><br><span class="line">  map(mediaUrl),</span><br><span class="line">  prop(<span class="string">&#x27;items&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="function">(<span class="params">src</span>) =&gt;</span> <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;src&#125;</span>&quot; /&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = compose(</span><br><span class="line">  Impure.setHtml(<span class="string">&#x27;#root&#x27;</span>),</span><br><span class="line">  map(img),</span><br><span class="line">  mediaUrls,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = compose(Impure.getJSON(render), url);</span><br><span class="line"></span><br><span class="line">app(<span class="string">&#x27;cat&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="compose와-map-리팩토링"><a href="#compose와-map-리팩토링" class="headerlink" title="compose와 map 리팩토링"></a>compose와 map 리팩토링</h3><p>아주 간단한 리팩토링이다. 같은 배열에 대해 <code>map</code>을 여러 번 실행하기보다, 순서를 유지한 채로 매 원소에 대해 <code>map</code>할 함수를 합성해서 한 번에 실행하게 되면 반복 횟수를 줄일 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line">compose(map(img), map(mediaUrl));</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">compose(map(compose(img, mediaUrl)));</span><br></pre></td></tr></table></figure>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p><a target="_blank" rel="noopener" href="https://github.com/MostlyAdequate/mostly-adequate-guide">mostly-adequate-guide (EN)</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">이전</a></div><div class="pagination-next"><a href="/page/4/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">34</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-04T12:35:00.000Z">21-04-04</time></p><p class="title"><a href="/linux-user-and-sudo/">리눅스에서의 sudo와 권한 관리 (1)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-28T14:58:00.000Z">21-03-28</time></p><p class="title"><a href="/linux-how-to-find-files/">리눅스에서 파일을 찾는 방법</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-26T08:00:00.000Z">21-03-26</time></p><p class="title"><a href="/ndp-5-stream-5/">Stream 생태계 정리</a></p><p class="categories"><a href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-25T06:00:00.000Z">21-03-25</time></p><p class="title"><a href="/ndp-5-stream-4/">5장 Stream API 디자인 패턴 - Pipe, Fork, Merge, Mux/Demux</a></p><p class="categories"><a href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-21T13:00:00.000Z">21-03-21</time></p><p class="title"><a href="/linux-shell-1/">리눅스 셸(bash) 기본 기능 소개</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"a5b0a2c99ffc3e96272db5353f20f4e3","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
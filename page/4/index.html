<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T10:55:00.000Z" title="2021-01-15T10:55:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">7분안에 읽기 (약 1070 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-generator/">Javascript의 Generator</a></h1><div class="content"><p>이 글은 자바스크립트의 제너레이터 문법에 대해 간략히 소개한다.</p>
<hr>
<h3 id="정의"><a href="#정의" class="headerlink" title="정의"></a><strong>정의</strong></h3><p>JavaScript의 제너레이터는 <code>function*</code> 으로 정의된 제너레이터 함수가 반환한 객체이다. 이 객체는 이터레이터(iterator)이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo()로 생성된 제너레이터를 순회하며 값을 읽어간다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-객체와-함수-팩토리"><a href="#Generator-객체와-함수-팩토리" class="headerlink" title="Generator 객체와 함수(팩토리)"></a><strong>Generator 객체와 함수(팩토리)</strong></h3><p><u>제너레이터 함수</u>를 호출하면 <u>제너레이터 객체</u>를 반환하고 끝난다.</p>
<p>제너레이터 객체의 <code>next(...args)</code>를 통해 제너레이터의 본문을 일정 부분 실행할 수 있다.</p>
<ul>
<li>이터레이터는 <code>next()</code> 함수로 파라미터를 전달할 수 없다.</li>
<li>제너레이터가 값을 읽을 수 있기 때문에 <u><strong>협력적 멀티 태스킹</strong></u>이 가능하다.</li>
</ul>
<h3 id="Generator-기반-협력적-멀티-태스킹"><a href="#Generator-기반-협력적-멀티-태스킹" class="headerlink" title="Generator 기반 협력적 멀티 태스킹"></a><strong>Generator 기반 협력적 멀티 태스킹</strong></h3><p>협력적 멀티 태스킹은 코루틴에 나오는 개념이다. (추후 정리할 예정이다.)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">go(<span class="function"><span class="keyword">function</span>* <span class="title">producer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> write(i);</span><br><span class="line">    <span class="keyword">yield</span> sleep(<span class="number">100</span>); <span class="comment">// -- sleep이 가능해진다!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">go(<span class="function"><span class="keyword">function</span>* <span class="title">consumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> v;</span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    <span class="keyword">typeof</span> (v = <span class="keyword">yield</span> read()) !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;read:&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>이 코드의 <code>go</code>와 같은 함수를 <strong>제너레이터 실행기</strong>라고 한다. <code>co</code> 라이브러리가 훌륭한 제너레이터 실행기를 제공한다.</p>
<p>제너레이터 실행기는 원래 동기적으로 수행되는 제너레이터를 비동기 호출을 수행하게 만든 다음 callback을 통해 다시 제너레이터를 호출하게끔 하여 비동기 코드를 동기 코드처럼 작성할 수 있게 하는 목적의 함수이다.</p>
<h3 id="제너레이터-실행기"><a href="#제너레이터-실행기" class="headerlink" title="제너레이터 실행기"></a><strong>제너레이터 실행기</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 제너레이터 실행기</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grun</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> it = g();</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x = it.next(val);</span><br><span class="line">    <span class="keyword">if</span> (!x.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        x.value</span><br><span class="line">          .then(iterate)</span><br><span class="line">          .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> it.throw(err));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(iterate, <span class="number">0</span>, x.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 실행기를 사용한 모습.</span></span><br><span class="line"><span class="comment">// 꽤 async-await과 같이 가독성이 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">theFutureIsNow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    data = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;a.txt&#x27;</span>),</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;b.txt&#x27;</span>),</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;c.txt&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;Unable to read one or more input files: &#x27;</span> +</span><br><span class="line">        err.message,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> ptimeout(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> nfcall(</span><br><span class="line">      fs.writeFile,</span><br><span class="line">      <span class="string">&#x27;d.txt&#x27;</span>,</span><br><span class="line">      data[<span class="number">0</span>] + data[<span class="number">1</span>] + data[<span class="number">2</span>],</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;Unable to write output file: &#x27;</span> +</span><br><span class="line">        err.message,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-직접-만들어보기"><a href="#Generator-직접-만들어보기" class="headerlink" title="Generator 직접 만들어보기"></a><strong>Generator 직접 만들어보기</strong></h3><p>자료 중 재밌는 것이 있었다: <a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/babel%EC%9D%80-generator%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%82%98-c78523645cd7">Babel은 Generator를 어떻게 바꾸나</a>. 지금 나한테는 바로 이해하긴 어렵다. 직접 만들어보면 이해에 큰 도움이 될 듯 하다.</p>
<h3 id="Generator의-단점-Iterable은-가변-인자가-아니다"><a href="#Generator의-단점-Iterable은-가변-인자가-아니다" class="headerlink" title="Generator의 단점: Iterable은 가변 인자가 아니다"></a><strong>Generator의 단점: Iterable은 가변 인자가 아니다</strong></h3><p>제너레이터 객체는 위에서 말했듯 Iterable이지만, 이는 <u><strong>가변 인자와는 달라</strong></u>서, Math.min같은 함수를 이용할 때 spead 연산자로 배열로 만들어 넘겨야 하므로, 인자 전달 부분에서 아쉽다고 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 객체만 넘길 순 없음.</span></span><br><span class="line"><span class="comment">// 굳이 제너레이터 객체를 넘길거면, 받는 함수 입장에서 이터레이터를 써야 할 듯?</span></span><br><span class="line"><span class="comment">// for-of 문으로.</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// spread 연산자로 넘겨줘야 함.</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...foo());</span><br></pre></td></tr></table></figure>
<h3 id="Generator의-콜-스택"><a href="#Generator의-콜-스택" class="headerlink" title="Generator의 콜 스택?"></a><strong>Generator의 콜 스택?</strong></h3><blockquote>
<p>Calling <code>.next()</code> method just pushes that call on the top of the stack. It will then run the code inside the generator function.</p>
<p><strong><u>difference</u></strong>: it has to remember the state of all local variables, but engines already know how to do that from the implementation of closures. A generator call will restore the state so that it can continue where it left off.</p>
</blockquote>
<p>일반적인 콜 스택과 동일하다고 한다. 다만 제너레이터 내에서 제너레이터를 호출하는 경우 복잡하다고 하는데, 거기까지 알 필요는 없을 듯 하다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48873128/javascript-stack-model-for-generators">Javascript stack model for generators | StackOverFlow</a></p>
<p>출처: <a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%9E%AC%EB%AF%B8-246553cadfbd">Javascript Generator의 재미 (2016.12)</a></p>
<p>출처: Learning Javascript, O Reilly</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><strong>TODO</strong>:</h3><p>부족한 내용 보충하기. 제너레이터가 개념 뿐 아니라 사용이 중요한 개념이어서 정리가 난잡한데 다음주 중으로 정리하려고 한다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T10:54:00.000Z" title="2021-01-15T10:54:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">3분안에 읽기 (약 426 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-promise-all/">Promise.all은 Parallel로 실행되는가?</a></h1><div class="content"><p>Javascript의 모든 코드는 이벤트 루프에서 처리된다. 그리고 Node.js의 이벤트 루프 구현체로 libuv가 사용 된다는 사실은 널리 알려져 있다. 그런데 이상하지 않은가?</p>
<h3 id="Promise-all은-Parallel로-실행되는가"><a href="#Promise-all은-Parallel로-실행되는가" class="headerlink" title="Promise.all은 Parallel로 실행되는가?"></a><strong>Promise.all은 Parallel로 실행되는가?</strong></h3><p>이벤트 루프 모델을 이해했다면 자바스크립트에 병렬 실행은 없다는 것을 이해했을 것이다. 파일, 네트워크 I/O는 자바스크립트 코드가 직접 처리하는 것이 아니고, 콜백은 이벤트 루프에 의해 호출되어 순차적으로 실행된다.</p>
<blockquote>
<p>그럼, Promise.all은 어떤가?</p>
</blockquote>
<p>음… 애초에 자바스크립트 코드가 병렬적으로 실행될 수 있는가?</p>
<h4 id="Promise-all을-잘-몰라서-생긴-일"><a href="#Promise-all을-잘-몰라서-생긴-일" class="headerlink" title="Promise.all을 잘 몰라서 생긴 일"></a><strong>Promise.all을 잘 몰라서 생긴 일</strong></h4><p><code>Promise.all</code>은 Promise의 호출 순서와는 전혀 관계가 없다. Promise의 기본 동작을 하나도 건드리지 않는다.</p>
<p>Promise.all이 제공하는 기능이란, 트랜잭션과 같이 하나라도 실패하면 catch 훅으로 넘어가게 하는 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3, p4, p5])</span><br><span class="line">  .then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="오히려-순차적으로-Promise를-실행하는-것이-더-특별하다"><a href="#오히려-순차적으로-Promise를-실행하는-것이-더-특별하다" class="headerlink" title="오히려 순차적으로 Promise를 실행하는 것이 더 특별하다."></a><strong>오히려 순차적으로 Promise를 실행하는 것이 더 특별하다.</strong></h4><p><code>reduce</code>를 사용해 <code>iterable.reduce((p, fn) =&gt; p.then(fn), Promise.resolve())</code>로 순차적으로 실행시킬 수 있다. (웬만하면 <code>then</code>으로 직접 잇겠지만.)</p>
<p><a href="https://jsqna.com/js-async-1">Async Functions in Javascript 1</a>를 참고해도 좋을 것 같다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://medium.com/@sandeepv68/how-does-promise-all-works-internally-978ee82f3348">How does Promise.all all works interanlly</a></p>
<p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30823653/is-node-js-native-promise-all-processing-in-parallel-or-sequentially">Is Node.js native Promise.all processing in parallel or sequentially? | StackOverFlow</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T09:05:00.000Z" title="2021-01-15T09:05:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">3분안에 읽기 (약 385 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-event-loop-browser-vs-node/">이벤트 루프는 환경마다 다를까?</a></h1><div class="content"><p>Javascript의 모든 코드는 이벤트 루프에서 처리된다. 그리고 Node.js의 이벤트 루프 구현체로 libuv가 사용 된다는 사실은 널리 알려져 있다. 그런데 이상하지 않은가?</p>
<blockquote>
<p>왜 Node.js를 설명할 때 이벤트 루프의 <u>구현체</u>라며 따로 소개하는 걸까?</p>
</blockquote>
<p>과연 브라우저 상의 이벤트 루프와 Node.js의 이벤트 루프는 동일하다고 생각해도 될까?</p>
<p>이벤트 루프 <u>구현체가 다르다</u>는 것을 어떻게 생각하면 좋을까?</p>
<hr>
<h3 id="원인은-환경-차이"><a href="#원인은-환경-차이" class="headerlink" title="원인은 환경 차이"></a><strong>원인은 환경 차이</strong></h3><p>이벤트 루프의 처리 방식은 스펙으로 결정돼있지만 벤더마다 약간씩 다르게 구현하는 부분이 있다고 한다. Node.js 또한 예외는 아니다.</p>
<table>
<thead>
<tr>
<th>기능</th>
<th>브라우저</th>
<th>NodeJs</th>
</tr>
</thead>
<tbody><tr>
<td>File, Network I/O</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Event의 종류</td>
<td>Mouse, Keyboard Events</td>
<td>File, Network I/O</td>
</tr>
<tr>
<td>이벤트 루프 구현체</td>
<td><a target="_blank" rel="noopener" href="https://libevent.org/">libevent</a> (크롬 기준)</td>
<td><a target="_blank" rel="noopener" href="https://libuv.org/">libuv</a></td>
</tr>
<tr>
<td>자바스크립트 엔진</td>
<td>V8 (크롬 기준)</td>
<td>V8</td>
</tr>
<tr>
<td>process.nextTick (process 모듈 자체 API)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>setImmediate (<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate">ECMA 표준 아님</a>)</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>위 표 이외에 처리 순서의 차이가 약간 있긴 하지만 Node v11부터는 그 차이마저 적은 편이다.</p>
<blockquote>
<p><em>결론: 환경의 차이 때문에 약간의 구현 상의 차이가 있다 정도로 받아들이자.</em></p>
</blockquote>
<p>출처: <a target="_blank" rel="noopener" href="https://blog.insiderattack.net/javascript-event-loop-vs-node-js-event-loop-aea2b1b85f5c">JavaScript Event Loop vs Node JS Event Loop</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T06:45:00.000Z" title="2021-01-15T06:45:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">9분안에 읽기 (약 1381 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-license/">Javascript의 라이센스</a></h1><div class="content"><p>이 글은 자바스크립트의 라이센스 - 소유권과 결정권에 대한 내용과 근거를 찾아 정리한 글이다.</p>
<hr>
<h3 id="1-Javascript의-라이센스"><a href="#1-Javascript의-라이센스" class="headerlink" title="1. Javascript의 라이센스"></a><strong>1. Javascript의 라이센스</strong></h3><p>Javascript 이해관계자는 크게 언어 명세을 결정하는 쪽과 언어를 개발하는 쪽으로 나뉜다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>소유자</th>
<th>라이센스</th>
<th>생명 주기</th>
</tr>
</thead>
<tbody><tr>
<td>언어 명세(ECMA 262)</td>
<td>TC39</td>
<td>수정 하지 않는 선에서 사용 가능</td>
<td>매년</td>
</tr>
<tr>
<td>런타임(SW)</td>
<td>각 벤더</td>
<td>개별적으로 다름</td>
<td>상시 업데이트</td>
</tr>
</tbody></table>
<p>재밌는 점은 TC39에 벤더들이 참여한다는 점이다.</p>
<p>Trademark(유사 상표권)는 Oracle에 있는데, <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/135905/legal-ramifications-of-use-of-the-javascript-trademark">명칭하는 데 사용하는 것은 문제가 되지 않는다</a>고 한다.</p>
<p>언어 명세(구현 코드가 아님)은 ECMA International(TC39의 상위 개념)에서 제정한다. 언어 표준의 라이센스는 <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/238724/what-license-is-html-released-under">이 글 | StackExchange</a>을 참고</p>
<p>언어 - 인터프리터, 컴파일러, 런타임 - 구현의 몫은 각 벤더사에 있으며 벤더사가 적용하는 라이센스에 따라 각자 라이센스를 가질 수 있다.</p>
<p>아래는 역사를 요약 설명한 내용이다.</p>
<blockquote>
<p>in 1995, Netscape decided to add a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scripting_language">scripting language</a> to Navigator. They pursued two routes to achieve this: collaborating with <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems</a> to embed the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Programming_language">programming language</a>, while also hiring <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Brendan_Eich">Brendan Eich</a> to embed the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> language.</p>
<p>Netscape management soon decided that the best option was for Eich to devise a new language, with syntax similar to Java and less like Scheme or other extant scripting languages. Although the new language and its <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a> implementation were officially called LiveScript when first shipped as part of a Navigator release in September 1995, the name was changed to JavaScript three months later.</p>
</blockquote>
<p>1995: Netscape Navigator라는 브라우저의 기능으로 스크립트 언어를 내장하기로 개발</p>
<blockquote>
<p>In November 1996, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netscape">Netscape</a> submitted JavaScript to <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ecma_International">ECMA International</a>, as the starting point for a standard specification that all browser vendors could conform to. This led to the official release of the first <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a> language specification in June 1997.</p>
</blockquote>
<p>1996: Netscape -&gt; ECMA International로 소유권 이양 (이후 특정 기업의 소유는 아니게 됨)</p>
<p>출처: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JavaScript">Javascript | Wikipedia</a></p>
<h3 id="2-TC39-소개"><a href="#2-TC39-소개" class="headerlink" title="2. TC39 소개"></a><strong>2. TC39 소개</strong></h3><blockquote>
<p>Ecma International’s TC39 is a group of JavaScript developers, implementers, academics, and more, collaborating with the community to maintain and evolve the definition of JavaScript.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://tc39.es/">TC39</a>에서는 미팅 회의록을 공개하는데, <a target="_blank" rel="noopener" href="https://github.com/tc39/notes/blob/master/meetings/2020-11/nov-16.md">최근 미팅</a>을 보니 주요 브라우저 벤더사만 참여하는 것은 아니고 회의마다 여러 주체나 외부 인사도 참여하는 듯 하다. TC39에서 Javascript의 스펙을 결정한다고 한다.</p>
<blockquote>
<p>This Standard defines the ECMAScript 2021 general-purpose programming language.</p>
</blockquote>
<p>TC39는 <a target="_blank" rel="noopener" href="https://tc39.es/ecma262/">가장 최신의 Javascript 스펙 문서</a>를 온라인으로 유지한다. 현재는 ECMAScript 2021이며 이 문서는 Living Standard로 주기적으로 갱신되는 듯하다.</p>
<p>TC39이 표준을 제정하는 방식에 대해선 <a target="_blank" rel="noopener" href="https://ahnheejong.name/articles/ecmascript-tc39/">ECMAScript와 TC39 | ahn.heejong</a>을 참고하라.</p>
<h3 id="3-WHATWG-소개"><a href="#3-WHATWG-소개" class="headerlink" title="3. WHATWG 소개"></a><strong>3. WHATWG 소개</strong></h3><blockquote>
<p>The WHATWG was formed in response to the slow development of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium">World Wide Web Consortium</a> (W3C) <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Web_standards">Web standards</a> (…) On 28 May 2019, the W3C announced that WHATWG would be the sole publisher of the HTML and DOM standards.</p>
</blockquote>
<p>WHATWG는 W3C이 제정하는 표준 중 HTML, DOM 표준을 독자적으로 제정하는 그룹이다. WHATWG는 주요 브라우저 벤더로 구성된다. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HTML5#W3C_and_WHATWG_conflict">자세한 내용</a></p>
<p>WHATWG에서 제정한 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/introduction.html">HTML 5 스펙</a>은 HTML 뿐만 아니라 - HTML5라고 해서 HTML만을 다루지는 않는다 - (현대) 웹 기술의 전반에 대해 표준화된 문서이다.</p>
<h3 id="4-번외-구글은-왜-Chrome-V8을-오픈소스화했을까"><a href="#4-번외-구글은-왜-Chrome-V8을-오픈소스화했을까" class="headerlink" title="4. 번외: 구글은 왜 Chrome, V8을 오픈소스화했을까?"></a><strong>4. 번외: 구글은 왜 Chrome, V8을 오픈소스화했을까?</strong></h3><blockquote>
<p>[Chromium Release Announcement 발췌]</p>
<p>With a richer set of APIs we can build more interesting apps allowing people to do more online. The more people do online, the more they can use our services. […]</p>
<p>We believe that open source works not only because it allows people to join us and improve our products, but also (and more importantly) because it means other projects are able to use the code we’ve developed.</p>
</blockquote>
<blockquote>
<p>[StackExchange 답변 중]</p>
<p>they just needed the web as a whole to become more attractive. Their decision to open-source V8 led to one such effect: the NodeJS system was built on V8 … The web has become so attractive as a development environment that it is even displacing native apps, e.g. Electron is based on Chromium.</p>
</blockquote>
<p>공유되는 일부 내용을 정리해보자면, 크롬을 통해 구글은 웹 시장을 키우고 싶었고, 오픈소스화(2008)로 웹의 기능을 늘리고 늘어난 기능이 널리 퍼지는 것을 유도했다(다른 크로미움 기반 브라우저를 통해). 오픈소스를 활용해 크롬을 개발했으며, V8기반의 NodeJS(2011)를 통해 Javascript 생태계가 커졌다. (숙련된 개발자가 많아질 수 있는 환경 조성)</p>
<p>출처: <a target="_blank" rel="noopener" href="https://opensource.stackexchange.com/questions/10644/why-did-google-make-chromium-open-source">Why did Google make Chromium Open Source? | StackExchange</a></p>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><strong>TODO</strong>:</h4><p><em>Q. Netscape은 왜 넘겼을까? 돈이 안 돼서 그런걸까? 독자적인 기능으로 탑재했다면 더 성공할 수 있지 않았을까?</em></p>
<p><em>Q. 굳이 <u>오픈소스화</u> 하지 않아도 경쟁을 통해 기능은 늘어났을 것이고 크롬 출시연도인 2009년에 이미 2위 브라우저로 시작해 2012년엔 1위 브라우저가 됐는데 오픈 소스화가 여기서 얼마나 큰 역할을 했는지는 잘 모르겠다. 좀 더 찾아봐야 할 듯.</em></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-11T11:00:00.000Z" title="2021-01-11T11:00:00.000Z">21-01-11</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-25T11:21:13.860Z" title="2021-01-25T11:21:13.860Z">21-01-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">13분안에 읽기 (약 1935 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-async-1/">JS Async Functionality 1 - Intro</a></h1><div class="content"><p>이 글은 자바스크립트에서 비동기를 다룰 때 마주치는 개념들인 Promise, Generator, Async-Await을 큰 범위에서 다룬다. 중간 중간에 재밌는 패턴들도 수록했다.</p>
<hr>
<h3 id="Why-Promise"><a href="#Why-Promise" class="headerlink" title="Why Promise?"></a><strong>Why Promise?</strong></h3><blockquote>
<p><strong><u>What’s Promise?</u></strong><br>Promise는 순차적인 비동기 코드를 깔끔하게 짤 수 있게 하는 문법이다. 문법에 포함된 <code>Promise 객체</code>로 처리한다. Promise로 거의 모든 비동기를 처리한다고 해도 과언이 아니다.</p>
<p>Promise가 익숙하지 않다면 MDN을 참고:<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a> &gt; <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises</a></p>
</blockquote>
<p>비동기 작업 시 순차적인 흐름을 많이 구현해야 하는데, <u>CPS 방식으론 간결하게 짤 수 없다</u>. <a href="https://jsqna.com/ndp-3-cps-tips/">CPS 패턴 사용 시의 Tip | JSQnA</a> 참고.</p>
<p><strong>Promise의 장점</strong>: (콜백과 관련한 비교에 대한 내용은 <a href="https://jsqna.com/ndp-2-cps/">CPS 패턴</a> 참고.)</p>
<ul>
<li>프로미스 체인을 사용하면 작업들을 순차 실행시키는 일은 그리 어렵지 않다.</li>
<li><code>throw</code>를 프로미스 체인에서 사용할 수 있다.</li>
<li>catch 될 때까지 전체 체인에 오류를 자동으로 전파할 수 있다. 비동기 오류가 누락될 확률이 줄어든다.</li>
<li>동기적으로 값을 반환해도 비동기적인 호출을 보장한다. 함수가 동기, 비동기 반환을 섞어서 하는 것은 나쁘다.</li>
<li><code>Promise.all</code> 함수를 통해 비동기 작업을 병렬로 실행할 수 있다. (이건 CPS도 가능)</li>
<li><code>Promise.race</code> 함수를 통해 비동기 작업 중 가장 먼저 수행이 끝난 결과만 사용할 수 있다. (CPS에선 직접 구현해야 함.)</li>
</ul>
<p><strong>Promise로 함수 배열을 순차적으로 실행하는 패턴</strong> (현재 이해 부족으로 인해 수정 필요함.):</p>
<p>책에 재밌는 코드가 있어 가져왔다. Promise로 함수의 배열을 순차적으로 실행하는 방법이 있을까?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sequential :: Array(() =&gt; Promise) =&gt; Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequential</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 빈 값을 반환하는 Promise를 생성한다.</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  tasks.forEach(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// promise에 then으로 체인을 걸고,</span></span><br><span class="line">    <span class="comment">// 다음 순번의 &#x27;이전 작업&#x27;이 되기 위해 promise 변수로 할당한다.</span></span><br><span class="line">    <span class="comment">// UPDATE: task는 Promise를 반환하는 함수여야 한다.</span></span><br><span class="line">    promise = promise.then(task);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 최종 Promise를 반환한다.</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reduce로도 가능하다:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> promise = tasks.reduce(</span><br><span class="line">  (prev, task) =&gt; prev.then(task),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> retreive result</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>제한된 개수로 병렬 실행하기</strong>: (현재 이해 부족으로 인해, 추후 삽입 예정)</p>
<hr>
<h3 id="ES8-비동기-함수"><a href="#ES8-비동기-함수" class="headerlink" title="ES8 비동기 함수"></a><strong>ES8 비동기 함수</strong></h3><p>정의에 대한 자세한 내용은 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN async function</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">MDN AsyncFunction 생성자</a>를 참고하라.</p>
<p>ES7 비동기 함수는 비동기적으로 동작하는, <code>async</code>, <code>await</code> 문법이 활용된 함수이다.</p>
<p>(설명 보충 예정.)</p>
<hr>
<h3 id="Why-Generator"><a href="#Why-Generator" class="headerlink" title="Why Generator?"></a><strong>Why Generator?</strong></h3><blockquote>
<p><u><strong>What’s Generator?</strong></u></p>
<p>Generator는 시작 지점이 여러 개이며 중간에 실행을 정지/재개할 수 있는 함수이다.</p>
<ul>
<li><u>시작 지점이 여러 개</u>: 다른 시작 지점에 대해 매번 새로운 arguments로 호출할 수 있다.</li>
<li><u>정지/재개할 수 있다</u>: 제너레이터 함수는 실행 후 값을 반환할 때 정지한다. 이후 호출하면 다시 재개된다.</li>
</ul>
<p>Generator가 익숙하지 않다면 MDN을 참고:</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function</a>*</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator</a></p>
<p>시작하기 전에 아래 두 코드의 결과를 모르겠다면 이후 내용을 이해하기 어려우므로, Generator에 대해 추가적으로 공부를 하기 바란다.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator Example 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fruitGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;watermelon&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFruitGenerator = fruitGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator Example 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iteratorGenerator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = iteratorGenerator([</span><br><span class="line">  <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;orange&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;watermelon&#x27;</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">let</span> currentItem = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!currentItem.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(currentItem.value);</span><br><span class="line">  currentItem = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Generator-with-CPS-into-Async-Await"><a href="#Generator-with-CPS-into-Async-Await" class="headerlink" title="Generator with CPS into Async-Await:"></a><strong>Generator with CPS into Async-Await:</strong></h4><p>놀랍게도 Generator에 약간의 양념을 치면 ES7 비동기 함수를 만들어낼 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터로 비동기 흐름을 구현하는 방법이다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFlow</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// callback 함수는 비동기 함수에 CPS 패턴으로 넘겨져서, 결괏값으로 다시 제너레이터를 호출하는 데 사용된다.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> generator.throw(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> results = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    generator.next(</span><br><span class="line">      results.length &gt; <span class="number">1</span> ? results : results[<span class="number">0</span>],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> generator = generatorFunction(callback);</span><br><span class="line">  generator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncFlow, callback을 감추고, yield를 await으로 바꾼다면 async-await과 같은 문법을 지닌다.</span></span><br><span class="line">asyncFlow(<span class="function"><span class="keyword">function</span>* (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fileName = path.basename(__filename);</span><br><span class="line">  <span class="keyword">const</span> myself = <span class="keyword">yield</span> fs.readFile(</span><br><span class="line">    fileName,</span><br><span class="line">    <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">yield</span> fs.writeFile(</span><br><span class="line">    <span class="string">`clone_of_<span class="subst">$&#123;fileName&#125;</span>`</span>,</span><br><span class="line">    myself,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Clone created&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a><strong>try-catch</strong></h4><p>Async-Await과 유사하게, 제너레이터에는 <code>throw</code> API가 있는데, 제너레이터 함수 내에서 <code>try-catch</code>로 이를 처리할 수 있다:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> twoWay = twoWayGenerator();</span><br><span class="line">twoWay.next(args); <span class="comment">// args를 전달</span></span><br><span class="line">twoWay.throw(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">// throw로 Error 객체 전달. 제너레이터 함수 내의 catch 절로 이동하게 된다.</span></span><br></pre></td></tr></table></figure>
<p>참고자료 전문: <a target="_blank" rel="noopener" href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2">Async-Await ≈ Generators + Promises</a></p>
<p>참고 2: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36196608/difference-between-async-await-and-es6-yield-with-generators">Difference between async/await and ES6 yield with generators | StackOverFlow</a></p>
<p>참고 3: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31483342/es2017-async-vs-yield">ES2017 - Async vs. Yield | StackOverFlow</a></p>
<hr>
<h4 id="하나의-API로-CPS와-Promise-모두-지원하는-방법"><a href="#하나의-API로-CPS와-Promise-모두-지원하는-방법" class="headerlink" title="하나의 API로 CPS와 Promise 모두 지원하는 방법"></a><strong>하나의 API로 CPS와 Promise 모두 지원하는 방법</strong></h4><p><u>mongoose</u>와 같은 많은 라이브러리는 CPS와 Promise 방식을 모두 지원한다. 어떻게 한 함수로 동시에 지원할 수 있을까? 아래 코드와 같이 구현한다면 가능하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 마지막 인자로 callback 함수를 받는다.</span></span><br><span class="line"><span class="comment">// Promise로 사용하는 경우 callback 함수를 넘기지 않으니, 상관 없다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncDivision</span>(<span class="params">dividend, divisor, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 항상 Promise를 반환한다.</span></span><br><span class="line">  <span class="comment">// 어차피 CPS 패턴을 사용하는 코드라면 Promise로 결과를 받아서 처리하지 않는다.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 비동기로 반환</span></span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = dividend / divisor;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="built_in">isNaN</span>(result) ||</span><br><span class="line">        !<span class="built_in">Number</span>.isFinite(result)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">&#x27;Invalid operands&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">          cb(error);</span><br><span class="line">        &#125; <span class="comment">// 콜백이 있으면, 콜백을 호출한다.</span></span><br><span class="line">        <span class="keyword">return</span> reject(error); <span class="comment">// 콜백이 있든 없든, Promise reject로 catch 체인을 실행한다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, result);</span><br><span class="line">      &#125; <span class="comment">// 콜백이 있으면, 콜백을 결과로 호출한다.</span></span><br><span class="line">      resolve(result); <span class="comment">// Promise resolve로 then 체인을 실행한다.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>장점:</p>
<ul>
<li>Promise, CPS 패턴 사용자 모두에게 기능을 제공할 수 있다.</li>
</ul>
<hr>
<h3 id="비동기와-함수형-자바스크립트"><a href="#비동기와-함수형-자바스크립트" class="headerlink" title="비동기와 함수형 자바스크립트"></a><strong>비동기와 함수형 자바스크립트</strong></h3><p>Javascript는 순수한 함수형 언어가 아니므로, 모든 코드를 함수형 패러다임을 적용해서 작성할 수 없다고 한다. 비동기를 다루는 코드에 있어서는, 특히 async-await 키워드를 사용하여 작성할 때는 명령형 코드가 되므로, 더 함수형과 멀어지게 되는데, 결론적으론 Javascript에서 함수형 패러다임을 실천할 때에는 함수형인 코드 베이스와 그렇지 않은 부분으로 나누는 게 좋다고 한다. 또한 Promise든 Async-Await이든 하나를 택해서 통일하는 게 좋다고 하니 참고 바란다.</p>
<p>전문: <a target="_blank" rel="noopener" href="https://medium.com/@aidobreen/js-promises-async-await-and-functional-programming-f2e5fa66b4ef">JS: Promises, async/await, and functional programming.</a></p>
<hr>
<p><strong>TODO:</strong></p>
<ul>
<li>Generator는 아직도 공부 중이다. Iterable 프로토콜에 대한 얘기도 있고, 비동기 처리 외에 Generator의 쓰임새나 Generator 자체 개념에 대해 더 공부해야 한다.</li>
<li>코루틴에 대해서도 공부해봐야 할 것 같다. 공부 중 접하게 된 키워드이다.</li>
<li>제너레이터에 대한 설명을 보강해야겠다.</li>
<li>이해가 완료되면 자체 제작한 예제 코드로 교체한다.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-08T10:40:00.000Z" title="2021-01-08T10:40:00.000Z">21-01-08</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">7분안에 읽기 (약 1068 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-3-cps-tips/">3장: CPS 패턴 사용 시의 Tip</a></h1><div class="content"><p>Node.js 환경에서 CPS 패턴을 사용할 때 시도할 만한 Tip들을 정리했다.</p>
<hr>
<h3 id="1-Callback-Hell을-조금-해결하는-방법"><a href="#1-Callback-Hell을-조금-해결하는-방법" class="headerlink" title="1. Callback Hell을 조금 해결하는 방법"></a><strong>1. Callback Hell을 조금 해결하는 방법</strong></h3><blockquote>
<p>본인은 Promise 세대여서 Callback Hell을 제대로 경험해 본 적이 없고, 웬만한 개발 환경이라면 Callback Hell을 겪기 어려울 것으로 예상돼 짧게 요약했다.</p>
</blockquote>
<p>들여 쓰기 때문에 가독성이 매우 떨어지게 되고, 변수 이름도 중첩되는 문제가 있다. 만약 Blocking API를 사용해 동일한 내용을 구현했다면 잘 못 이해할 가능성은 거의 없을 것이다.</p>
<p><strong>Pattern</strong>:</p>
<ul>
<li>중첩 수준을 낮게 유지하기 위해, else 문을 사용하지 않는다.</li>
<li>인라인 함수의 이름을 지정하면, 함수 이름을 통해 더 쉽게 디버깅이 가능하다.</li>
<li>함수를 쪼갠다.</li>
</ul>
<p><strong>자주 하는 실수</strong>:</p>
<ul>
<li><p>Callback을 호출한 뒤에도 함수는 계속 실행됨을 잊는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) callback(err);</span><br><span class="line"><span class="comment">// 여기서도 함수는 계속 실행된다.</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>return callback(err)</code> 혹은 <code>return</code>을 callback 호출 이후 수행하여 함수 실행을 종료한다.</li>
</ul>
</li>
</ul>
<h3 id="2-순차적으로-실행시키는-방법"><a href="#2-순차적으로-실행시키는-방법" class="headerlink" title="2. 순차적으로 실행시키는 방법"></a><strong>2. 순차적으로 실행시키는 방법</strong></h3><p>Callback Hell을 겪지 않고 비동기 API를 순차적으로 실행하는 방법:</p>
<ul>
<li>재귀 함수로 실행한다.</li>
<li>재밌는 점은, StackOverFlow가 날 일은 없다는 점이다. 비동기 함수여서 매 번 스택이 초기화되니까.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> length = N;</span><br><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">f</span>) =&gt;</span> f;</span><br><span class="line"><span class="keyword">const</span> iterate = <span class="function">(<span class="params">idx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (idx === length) <span class="keyword">return</span> callback();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> task = tasks[idx];</span><br><span class="line">  task(data[idx], <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    iterate(idx + <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">iterate(<span class="number">0</span>); <span class="comment">// Callback이 재귀적으로 수행돼, N 만큼 수행된다.</span></span><br></pre></td></tr></table></figure>
<p>이 방식의 한계:</p>
<ul>
<li>실행될 작업의 숫자를 알아야 한다.</li>
</ul>
<h3 id="3-JS-경쟁-조건-해결하기"><a href="#3-JS-경쟁-조건-해결하기" class="headerlink" title="3. JS 경쟁 조건 해결하기"></a><strong>3. JS 경쟁 조건 해결하기</strong></h3><ul>
<li><p>Javascript는 단일 스레드로 실행된다.</p>
</li>
<li><p>리소스 동기화는 필요 없지만, 비동기 API 타이밍 문제는 아직 남아있다.</p>
</li>
<li><p>Javascript 역시 호출 시점과 I/O 수행 시점 차이로 중복 작업 등의 예기치 않은 동작을 할 수 있다.</p>
</li>
<li><p>상호 배제로 해결 가능하다.</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 중인 job을 등록한다. 공유 리소스 동기화는 필요 없다.</span></span><br><span class="line"><span class="keyword">const</span> jobs = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">id, data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 이 코드로 타이밍 문제를 해결할 수 있다.</span></span><br><span class="line">  <span class="keyword">if</span> (jobs.has(id))</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback);</span><br><span class="line"></span><br><span class="line">  jobs.set(id, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 정상 분기.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-동시에-수행되는-작업-개수-제한-하기"><a href="#4-동시에-수행되는-작업-개수-제한-하기" class="headerlink" title="4. 동시에 수행되는 작업 개수 제한 하기"></a><strong>4. 동시에 수행되는 작업 개수 제한 하기</strong></h3><p>한 번에 너무 많은 파일을 열려고 하는 등의 경우 리소스 부족으로 뻗어버릴 수 있다. 동시에 실행하는 작업의 수를 제한해 이를 상황을 방지하는 아이디어를 소개한다.</p>
<p>알고리즘:</p>
<ul>
<li>처음에 동시 실행 제한 개수만큼의 작업을 실행</li>
<li>각 작업이 끝날 때, <code>동시 실행 제한 개수 - 현재 실행 개수</code> 만큼의 작업을 실행</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> limit = <span class="number">2</span>; <span class="comment">// 동시 실행 제한 개수</span></span><br><span class="line"><span class="keyword">let</span> running = <span class="number">0</span>,</span><br><span class="line">  completed = <span class="number">0</span>,</span><br><span class="line">  idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> next = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 여유 작업 개수만큼 반복</span></span><br><span class="line">  <span class="keyword">while</span> (running &lt; limit &amp;&amp; idx &lt; tasks.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> task = tasks[idx++];</span><br><span class="line">    task(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 새 작업을 할 수 없음</span></span><br><span class="line">      <span class="keyword">if</span> (completed === tasks.length)</span><br><span class="line">        <span class="keyword">return</span> finish();</span><br><span class="line">      completed++;</span><br><span class="line">      running--;</span><br><span class="line">      next(); <span class="comment">// 새 작업을 할 여유가 있음</span></span><br><span class="line">    &#125;);</span><br><span class="line">    running++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 동시 실행 제한 개수를 채우며 계속 실행함.</span></span><br><span class="line">next();</span><br></pre></td></tr></table></figure>
<p><strong>큐로 구현하는 방법</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue로 구현하는 방식</span></span><br><span class="line"><span class="comment">// 로직은 같은데 Queue를 사용하는 것만 다르다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    <span class="built_in">this</span>.running = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.queue = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// task :: callback =&gt; void; (must call callback)</span></span><br><span class="line">  <span class="comment">// task를 tasks에서 가져오는 게 아니라, Queue에 넣은 것이 나온다.</span></span><br><span class="line">  <span class="comment">// =&gt; 새 작업을 큐에 동적으로 추가할 수 있다.</span></span><br><span class="line">  <span class="function"><span class="title">pushTask</span>(<span class="params">task</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.push(task);</span><br><span class="line">    <span class="built_in">this</span>.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      <span class="built_in">this</span>.running &lt; <span class="built_in">this</span>.limit &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.queue.length</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> task = <span class="built_in">this</span>.queue.shift();</span><br><span class="line">      task(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.running--;</span><br><span class="line">        <span class="built_in">this</span>.next();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="built_in">this</span>.running++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-Async-라이브러리-사용"><a href="#5-Async-라이브러리-사용" class="headerlink" title="5. Async 라이브러리 사용"></a><strong>5. <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/async">Async 라이브러리</a> 사용</strong></h3><p>복잡한 비동기 제어 흐름을 선언적인 방식으로 처리할 수 있게 헬퍼 함수들을 제공하는 라이브러리이다.</p>
<ul>
<li>순차적인 반복</li>
<li>제한된 동시 실행</li>
</ul>
<p>등을 헬퍼 함수를 통해 쉽게 구현 가능하다. CPS 패턴은 주로 사용할 것 같진 않아 따로 정리하진 않았다.</p>
<hr>
<p><strong>TODO</strong>:</p>
<ul>
<li>여러 번 이해하여 좋은 예제를 만들어 이 글 내용 보강하기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-08T01:20:00.000Z" title="2021-01-08T01:20:00.000Z">21-01-08</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">5분안에 읽기 (약 821 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-2-event-emitter/">2장 (3/3): Node.js의 Observer Pattern</a></h1><div class="content"><p>이 글은 Node.js에서 자주 사용되는 Observer Pattern에 대해 소개한다. <a href="https://jsqna.com/ndp-1-reactor-pattern/">리액터 패턴</a>, <a href="https://jsqna.com/ndp-2-cps/">CPS 패턴</a>에 대한 지식을 전제로 작성했으니 참고바란다.</p>
<hr>
<h3 id="1-Observer-Pattern의-정의"><a href="#1-Observer-Pattern의-정의" class="headerlink" title="1. Observer Pattern의 정의"></a><strong>1. Observer Pattern의 정의</strong></h3><blockquote>
<p>Node.js에서 이벤트는 핵심 중 하나라고 한다.</p>
<p>Node.js 코어 모듈과 오픈 소스를 사용하는데도 필수적인 조건이라고 한다.</p>
</blockquote>
<p><strong>Observer Pattern</strong>은 Subject와 Listener 라는 역할로 한 쪽은 등록을, 한 쪽은 통지를 하는 관계이다.</p>
<ul>
<li><p>Subject는 이벤트를 발생시키는 주체로, 스스로 무슨 행위를 할 때, Listener에게 통지를 해야 한다.</p>
</li>
<li><p>Listener는 특정 Subject 객체에 본인의 참조를 등록한다. <code>subject.addListener(this)</code>와 같이 수행한다.</p>
</li>
<li><p><code>foreach (listener : listeners) listener.notify();</code> 와 같이 Listener에게 이벤트 발생을 알린다.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4">옵서버 패턴 | Wiki 백과</a> 참고.</p>
</li>
</ul>
<p>Observer Pattern이 Callback 보다 나은 점이 뭘까?</p>
<table>
<thead>
<tr>
<th>기능</th>
<th>Observer Pattern</th>
<th>Continuous Passing Style</th>
</tr>
</thead>
<tbody><tr>
<td>다중 리스너 지원</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>핸들러 사용 횟수</td>
<td>여러 번(or 주기적으로) 발생하는 경우</td>
<td>한 번 발생하는 경우</td>
</tr>
<tr>
<td>핸들러 함수 제약</td>
<td>없음. <code>onError</code>, <code>onSuccess</code> 로 관심사 분리하므로.</td>
<td>한 함수 <code>(err, data)=&gt; &#123; /* ... */ &#125;</code>로 두 상태 모두 처리</td>
</tr>
<tr>
<td>핸들러 등록 시점</td>
<td>아무 때나</td>
<td>함수 실행 시점에 매개변수로 전달</td>
</tr>
</tbody></table>
<h3 id="2-Event-Emitter"><a href="#2-Event-Emitter" class="headerlink" title="2. Event Emitter"></a><strong>2. Event Emitter</strong></h3><p>Node.js는 Event Emitter라는 미리 구현된 객체를 코어 모듈(<code>events</code>)로 포함하고 있다. 이 객체는 <code>emit</code>, <code>on</code>, <code>once</code>, <code>removeListener</code> 로 구성된 총 4개의 메소드를 갖고 있다. 아래는 각 메소드의 사용 예시이다.</p>
<blockquote>
<p><em>CodeSandBox가 Node.js를 Beta로 지원하고 있으므로 출력이 정상적이지 않을 수 있습니다. 왼쪽의 탭을 드래그해 코드를 확인해주세요.</em></p>
</blockquote>
<iframe src="https://codesandbox.io/embed/setup-basic-nodejs-server-forked-9o5on?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="Setup Basic Node.js Server (forked)"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<p>아래는 File을 읽는 예제이다.</p>
<iframe src="https://codesandbox.io/embed/nodejs-event-emitter-file-read-example-2gx0i?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="Node.js Event Emitter - File Read Example"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<h3 id="3-Event-Emitter-에서의-예외-처리"><a href="#3-Event-Emitter-에서의-예외-처리" class="headerlink" title="3. Event Emitter 에서의 예외 처리"></a><strong>3. Event Emitter 에서의 예외 처리</strong></h3><p>Event Emitter에서도 비동기 이벤트의 경우, CPS와 마찬가지로 예외가 발생하는 경우 기존 스택을 잃기 때문에 (<a href="https://jsqna.com/ndp-1-reactor-pattern/">리액터 패턴</a> 참고) <code>try-catch</code>로 무조건 예외를 처리하여야 한다. 이후 <code>error</code> 이벤트를 발생시켜 리스너들에게 전달함이 일반적이다.</p>
<h3 id="4-Event-Emitter-상속하기"><a href="#4-Event-Emitter-상속하기" class="headerlink" title="4. Event Emitter 상속하기"></a><strong>4. Event Emitter 상속하기</strong></h3><p>아래와 같이 EventEmitter를 상속하여 인스턴스에 대해 <code>.on</code>을 붙이는 등의 작업을 할 수도 있다. 책에서는 일반적인 패턴이라고 하지만, <code>emit</code> 메소드까지 의도치 않게 Public API가 되기 때문에 추천하는 방식은 아니다. <code>위임</code>으로 <code>on</code>, <code>once</code>, <code>removeListener</code>를 따로 API로 내보내는 게 맞다고 생각한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindPattern</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findPattern = <span class="keyword">new</span> FindPattern(<span class="regexp">/hello \w+/g</span>);</span><br><span class="line">findPattern.on(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure>
<h3 id="5-동기-비동기-이벤트-별-리스너-등록-시점"><a href="#5-동기-비동기-이벤트-별-리스너-등록-시점" class="headerlink" title="5. 동기, 비동기 이벤트 별 리스너 등록 시점"></a><strong>5. 동기, 비동기 이벤트 별 리스너 등록 시점</strong></h3><p>이벤트를 동기적으로 발생시키려면, 리스너 등록을 이벤트 발생 이전 시점에 완료하여야 한다.</p>
<p>이벤트를 비동기적으로 발생시키는 경우, 리스너를 동기적으로만 등록한다면 시점이 자유롭다. (<a href="https://jsqna.com/ndp-1-reactor-pattern/">리액터 패턴</a> 참고.)</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-07T03:30:00.000Z" title="2021-01-07T03:30:00.000Z">21-01-07</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Docker/">Docker</a></span><span class="level-item">16분안에 읽기 (약 2338 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/docker-diamol-2-dockerfile-image/">[1 Month Docker] 2. Dockerfile, Docker Image</a></h1><div class="content"><p>Dockerfile과 Docker Image 개념을 소개하고, 핵심적인 내용을 설명한다. <a href="https://jsqna.com/docker-diamol-1-hello-world/">Docker에 대한 간단한 소개</a>의 내용을 기본으로 가정하고 시작한다.</p>
<hr>
<p>저번 글에선 Container와 Docker를 체험해보았다. Container는 어떠한 스택의 애플리케이션이든 배포 측면에서 일관된 경험을 제공하므로 사용하는 것이 좋지 않을까 생각한다.</p>
<p>Docker로 Container를 실행하려면 Docker Image가 필요한데, 이번 글에서는 최종적으로 Image를 직접 생성한다(공식적으로는 build 한다고 표현함.).</p>
<h3 id="1-기초-개념-설명"><a href="#1-기초-개념-설명" class="headerlink" title="1. 기초 개념 설명"></a><strong>1. 기초 개념 설명</strong></h3><p><strong>1. Dockerfile</strong>: 이미지 빌드 명령어의 입력으로 들어가는 스크립트이다. 아래와 같은 내용을 담는다.</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parent Image 지정</span></span><br><span class="line"><span class="comment"># Dockerfile은 이미지를 정의하는 파일이다.</span></span><br><span class="line"><span class="comment"># 새 이미지를 만들 때 다른 이미지의 내용에 기반해 덧씌우는 형태이다.</span></span><br><span class="line"><span class="keyword">FROM</span> diamol/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 환경 변수 3개 설정</span></span><br><span class="line"><span class="comment"># Docker와 같이 컨테이너 환경으로 앱이 배포되는 경우,</span></span><br><span class="line"><span class="comment"># 환경 변수를 arguments로 많이 활용한다.</span></span><br><span class="line"><span class="keyword">ENV</span> TARGET=<span class="string">&quot;blog.sixeyed.com&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> METHOD=<span class="string">&quot;HEAD&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> INTERVAL=<span class="string">&quot;3000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Working Directory를 /web-ping으로 지정 (폴더 생성 후 이동함. mkdir &amp;&amp; cd)</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /web-ping</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Host의 app.js 파일을, Working Directory(.)에 복사</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.js .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># node로 다음의 js를 실행</span></span><br><span class="line"><span class="comment"># CMD 명령어는 컨테이너 실행 시에 1회 수행되는</span></span><br><span class="line"><span class="comment"># container.once(&#x27;start&#x27;, callback)과 같다.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;/web-ping/app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>아마 셸 스크립트에 익숙한 사람은 셸 스크립트와 다름 없다고 생각할 것이다. 맞다. 똑같다. 아마 셸 스크립트가 익숙하지 않으면 Dockerfile에 쉽게 친해질 순 없을텐데, <a target="_blank" rel="noopener" href="https://tacademy.skplanet.com/live/player/onlineLectureDetail.action?seq=185">리눅스 환경 구성 기초 | T 아카데미</a>나 <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1zMf2HhVSR7MGJxafR8zRzqQEuRUBSDfG7yWx-GjBu6Q/edit#slide=id.p">리눅스 커맨드 라인 &amp; 쉘 스크립트 #1 | ABCD DevOps</a>라는 좋은 자료가 있으니 참고하자.</p>
</blockquote>
<p>Dockerfile 안에서만 쓸 수 있는, Dockerfile에서 쓰일 만한, 명령어가 10개 정의돼있다. 이 명령어들이 주축이 돼서 Dockerfile의 내용을 구성하게 된다.</p>
<ul>
<li><p>전체 기능에 대해서는 <a target="_blank" rel="noopener" href="https://medium.com/@iced_burn/dockerfile-cheat-sheet-9f52aa4a99b3">Dockerfile Cheat Sheet</a>를 참고하라.</p>
</li>
<li><p>걔 중 유사한 명령어인 <a target="_blank" rel="noopener" href="https://blog.leocat.kr/notes/2017/01/08/docker-run-vs-cmd-vs-entrypoint">CMD vs RUN vs ENTRYPOINT를 정리한 글</a>도 있으니 참고하기 바란다.</p>
</li>
<li><p>Dockerfile 명령어는 대소문자를 구분하지 않지만 대문자로 쓰는 게 컨벤션이다.</p>
</li>
</ul>
<p><strong>2. Image</strong>: 이미지는 Dockerfile에서 기술한 내용이 실행된 모습을 스냅샷 형태로 담은 파일이다.</p>
<ul>
<li>컨테이너 실행 시 이미지를 통해 Dockerfile에 정의된 내용이 그대로 재현된다.</li>
</ul>
<p><strong>3. Image 받아오기</strong>: 이미지를 직접 생성하지 않고, DockerHub 등의 Docker Registry (이미지 저장 서버)에서 받아올 수도 있다. 단순히 받아오기만 하는 명령어는 <code>docker image pull</code> 이다.</p>
<ul>
<li><code>docker image pull diamol/ch03-web-ping</code> 을 실행해 DockerHub에서 이미지를 받자.</li>
<li><img src="/images/image-1.png"></li>
<li>하나의 이미지를 받는데, 여러 <code>Pull Complete</code>가 표시돼있다. (나중에 설명한다.)</li>
</ul>
<p><strong>4. Image 빌드</strong>: <code>docker image build</code> 명령어를 실행하면, 이미지는 자동으로 빌드된다.</p>
<p>예: <code>docker image build --tag web-ping .</code> =&gt; <code>web-ping</code>이라는 이미지를 생성.</p>
<ul>
<li>(Mandatory) <code>.</code>은 Dockerfile 및 <code>COPY</code> 등에서 Host의 기준 디렉토리로 사용된다.</li>
<li>(Mandatory) <code>--tag</code>는 이미지의 이름을 지정한다.</li>
<li>주의: 파일을 Windows -&gt; Linux로 복사하는 경우, 권한이 <code>rwxrwx</code>로 지정되는데, 이는 서로 권한 정보가 호환되지 않기 때문이다.</li>
<li>로컬에서 직접 빌드된 이미지는 도커 엔진에 캐시돼 보관된다.</li>
<li>새로운 버전을 빌드하려는 경우, <code>--tag web-ping:v2</code>와 같이 <code>:</code>으로 버전을 구분하여 명시하면 된다.</li>
</ul>
<p><img src="/images/image-2.png" alt="Docker Image Build Process Example"></p>
<p><strong>5. Image 실행(컨테이너로)</strong>:</p>
<ul>
<li><code>docker container run &#123;image_name&#125;</code>으로 실행</li>
</ul>
<p><strong>6. Image Layer</strong>:</p>
<p>이미지에는 생성 과정에 대한 메타데이터도 포함된다. 이미지 생성 과정을 통해</p>
<ul>
<li><code>docker image history web-ping</code></li>
<li><img src="/images/image-3.png" alt="Image History Example"></li>
</ul>
<p>Docker Image는 Image Layer라는 더 작은 개념으로 구성되며, Dockerfile의 각 명령(<code>CREATED BY</code>) 마다 Layer가 생성된다.</p>
<ul>
<li>이미지는 각 Layer의 논리적인 집합이다.</li>
<li>Layer는 도커 엔진에 물리적인 파일의 형태로 캐시되는 단위이다.</li>
<li>이미지 간에 Layer가 공유되므로 전체 용량 부하를 낮출 수 있다.<ul>
<li><code>docker image ls</code>로 논리적인 용량을 확인할 수 있지만, <code>docker system df</code>로 이미지가 차지하는 물리적인 용량을 확인할 수 있다.</li>
<li><img src="/images/image-4.png" alt="docker system df"></li>
</ul>
</li>
</ul>
<p>이런 Image Layer 캐시를 활용하려면 조건이 필요한데: Layer 이전의 Layer 들의 내용과 순서가 바뀌지 않아야 한다.</p>
<ul>
<li>이전 내용이 바뀌었는데, 이 명령(Layer)을 실행한 결과가 같음을 보장할 수 없다.</li>
<li>만약 내용을 바꾸는 경우, 이 Layer에 의존하고 있던 모든 이미지에 영향을 끼친다.</li>
<li>그러므로, 이전 Layer가 변경되는 경우, 이후 Layer는 캐시로 사용될 수 없게 되고, 새로 Layer를 생성하게 된다.</li>
</ul>
<p><strong>7. Layer 캐시 최적화 전략</strong>: Layer 캐시 활용을 통해 전체 용량과 이미지 빌드 시간을 줄일 수 있다.</p>
<ul>
<li><p>이미지에서 변하지 않는 부분을 최대한 먼저 실행해 새로 빌드할 Layer 수를 줄인다.</p>
</li>
<li><p>캐시 사용 가능 여부는 Instruction의 내용과 Arguments(명령어 내용일 수도 있지만, <code>COPY</code>와 같은 경우 파일의 내용까지.)로 Hash 값을 만들고 비교하여 결정한다.</p>
</li>
<li><p>Hash가 일치하는 경우 빌드하지 않고 도커 엔진에 캐시된 Layer를 사용한다. 일치하지 않는 경우, 해당 Layer부터 최종 Layer까지 새로 빌드한다. (뒷 Layer의 해시가 같아도, 재사용할 수 없다.)</p>
</li>
<li><p><img src="/images/image-5.png" alt="docker build image cache"></p>
</li>
<li><p><code>app.js</code> 파일을 수정한 후 (<code>nano app.js</code>) 빌드한 모습이다. <code>COPY app.js</code>를 수행하는 <code>step 6</code>가 다시 Layer를 만듦을 확인할 수 있고, 이후 Layer인 <code>step 7</code>은 바뀐 내용이 없지만 앞 Layer가 바뀌어서 다시 만들어짐을 확인할 수 있다.</p>
</li>
</ul>
<p><strong>8. Layer 캐시 최적화 예시</strong>:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> diamol/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시작 시 실행될 명령어를 지정하는 것이므로, 어디에 놓아도 상관 없다.</span></span><br><span class="line"><span class="comment"># 캐시를 위해 앞에 놓는다.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;/web-ping/app.js&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 환경 변수 3개를 한 번에 등록해 Layer 개수를 줄였다.</span></span><br><span class="line"><span class="comment"># 개수를 줄인 것과 캐시 최적화는 큰 연관은 없지만...</span></span><br><span class="line"><span class="keyword">ENV</span> TARGET=<span class="string">&quot;blog.sixeyed.com&quot;</span> \</span><br><span class="line">	METHOD=<span class="string">&quot;HEAD&quot;</span> \</span><br><span class="line">	INTERVAL=<span class="string">&quot;3000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /web-ping</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.js .</span></span><br></pre></td></tr></table></figure>
<p>이제 <code>docker image build -t web-ping:v3</code>를 실행해보자. 환경 변수 개수가 줄어들어 7단계에서 5단계로 줄었음을 확인할 수 있다.</p>
<p>이제부턴 <code>app.js</code>를 수정해도 마지막 Layer만 바뀐다.</p>
<hr>
<h3 id="2-실습"><a href="#2-실습" class="headerlink" title="2. 실습"></a><strong>2. 실습</strong></h3><p><strong>1. 목표</strong>:</p>
<p><code>diamol/ch03-lab</code> 폴더의 이미지에서 <code>/diamol/ch03.txt</code> 파일을 수정하고 새 Image를 생성하라. 이 때 Dockerfile을 수정해서는 안 된다.</p>
<p><strong>2. 힌트</strong>:</p>
<ul>
<li><code>-it</code>으로 컨테이너에 키보드 I/O 가능</li>
<li>컨테이너 파일 시스템이 Exit 상태에도 제거되지 않음을 활용</li>
<li><code>docker container --help</code>로 모르는 명령어에 대해 공부할 것</li>
</ul>
<p><strong>3. 처음 생각한 접근 방법</strong>:</p>
<ol>
<li>Container에서 일단 파일을 수정한다.</li>
<li>컨테이너로 이미지를 생성해낸다. 명령어를 찾아보자.</li>
</ol>
<p><strong>4. 실제 수행 과정</strong>:</p>
<hr>
<p><strong>1. 일단 이미지를 빌드함</strong></p>
<p><code>cd ../../lab</code> (빌드를 위해 lab 폴더로 이동)</p>
<p><code>docker build image -t ch03-lab .</code> (빌드 성공)</p>
<hr>
<p><strong>2. 이제 컨테이너를 실행해야 함</strong></p>
<p><code>docker container run ch03-lab</code> (실패)</p>
<p><code>docker container ls</code> (없었음)</p>
<p><code>cat Dockerfile</code> (<code>CMD</code> 등 명령어 실행이 없고, <code>COPY</code> 뿐이었음)</p>
<hr>
<p><strong>3. 컨테이너에서 수행할 명령어로 주어 실행해야 함</strong></p>
<p><code>docker container run ch03-lab /bin/bash</code> (실패)</p>
<p><code>docker container run ch03-lab /bin/sh</code> (이미지에 bash가 없었음..)</p>
<p><code>vi ch03.txt</code> (텍스트 파일 수정)</p>
<p><code>exit</code> (sh 나옴)</p>
<hr>
<p><strong>4. 정지된 컨테이너를 이미지로 빌드해야 함</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/commit/">Docker Commit Reference</a>를 참고해서 빌드 명령어 학습</p>
<p><code>docker container ls --all</code> 로 종료된 컨테이너 ID 확인 (<code>67a</code>)</p>
<p><code>docker image commit 67a ch03-lab:v2</code> (무슨 해시값이 출력됨..)</p>
<p><code>docker image ls</code> (v2로 생성됨을 확인)</p>
<p><code>docker container run ch03-lab:v2 cat ch03.txt</code> (파일 갱신됨을 확인)</p>
<p><strong>끝!</strong></p>
<hr>
<p><strong>Lab 하면서 배운 점:</strong></p>
<p><code>docker commit</code> 명령어로 컨테이너 내용으로 이미지를 빌드할 수 있다는 점.</p>
<ul>
<li>다만 이렇게 되면 Dockerfile은 없는게 아닌가?</li>
</ul>
<p><code>docker container run &#123;IMAGE&#125; &#123;COMMAND&#125;</code>로 명령어를 실행할 수 있음</p>
<ul>
<li>다만 이는 이미지에서 수행하는 명령어가 없는 경우에 한한 것 같고, <code>docker container exec</code>으로 셸을 띄우는 것이 일반적인 것 같다.</li>
</ul>
<p><strong>TO DO</strong>:</p>
<ul>
<li>컨테이너에서 Commit으로 생성한 이미지에서 Dockerfile을 추출할 수 있을지 확인해보기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-04T01:00:00.000Z" title="2021-01-04T01:00:00.000Z">21-01-04</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/CI-CD/">CI/CD</a></span><span class="level-item">14분안에 읽기 (약 2118 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ci-1-github-actions-nodejs/">10분 만에 기반 지식 없이 Node.js를 위한 Github Actions CI 구축하기</a></h1><div class="content"><h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a><strong>목표</strong></h3><ul>
<li>10분 만에 Github Actions를 통한 CI를 구축한다.</li>
<li>master에 Merge 시에 ESLint와 테스트를 자동으로 수행하고, 결과에 따라 Merge할 수 없게 한다.</li>
</ul>
<hr>
<h3 id="1-기본-개념-설명"><a href="#1-기본-개념-설명" class="headerlink" title="1. 기본 개념 설명"></a><strong>1. 기본 개념 설명</strong></h3><p>기본 개념 몇 가지를 소개하고 넘어간다.</p>
<h4 id="1-CI"><a href="#1-CI" class="headerlink" title="1. CI"></a><strong>1. CI</strong></h4><p>Continuous Integration. 각자의 코드를 병합하기 전에 검토하는 절차를 말한다.</p>
<p>보통 자동화된 상태를 지칭하며, <code>master(or main)</code> 등의 특정 브랜치에 <code>Push(or Merge) Request</code>가 올라오면 코드를 검토한다.</p>
<h4 id="2-GitHub-Actions"><a href="#2-GitHub-Actions" class="headerlink" title="2. GitHub Actions"></a><strong>2. GitHub Actions</strong></h4><p>GitHub에서 특정 작업을 할 때 마다, 이벤트를 발생시키는데, 이를 구독해 특정 작업을 실행하는 것을 Github Actions라고 한다. (<a target="_blank" rel="noopener" href="https://pjh3749.tistory.com/266">옵저버 패턴</a> 참고)</p>
<h4 id="3-Worflow-File"><a href="#3-Worflow-File" class="headerlink" title="3. Worflow File"></a><strong>3. Worflow File</strong></h4><p>GitHub Actions의 이벤트에 대해 무엇을 실행할 지에 대해 기록해 놓은 명령서를 <code>workflow</code> 파일이라고 한다.</p>
<h4 id="4-Github-Actions-사용-시의-CI-흐름"><a href="#4-Github-Actions-사용-시의-CI-흐름" class="headerlink" title="4. Github Actions 사용 시의 CI 흐름"></a><strong>4. Github Actions 사용 시의 CI 흐름</strong></h4><p><em>PR Created(EVENT!)</em> &gt; Build &gt; Test &gt; <em>PR Merged(EVENT!)</em> &gt; Deploy (배포 자동화는 다음에)</p>
<ul>
<li>PR을 생성할 때 CI 수행</li>
<li>Merge할 때 CD 수행</li>
</ul>
<p>CI 과정에서 빌드가 성공했을 때만 Merge가 가능하게 설정하자.</p>
<h3 id="2-Node-js-App-으로-CI-구축-시작"><a href="#2-Node-js-App-으로-CI-구축-시작" class="headerlink" title="2. Node.js App 으로 CI 구축 시작"></a><strong>2. Node.js App 으로 CI 구축 시작</strong></h3><p>이 챕터에서 구축을 완료하고, 결과를 확인한다.</p>
<p>아주 간단한 과정이어서 CI라고 하긴 부끄럽지만, 아래 과정을 수행한다.</p>
<ul>
<li>npm module 설치</li>
<li>ESLint를 통한 코드 스타일 체크</li>
<li>테스트 실행</li>
</ul>
<h4 id="1-필요한-자료"><a href="#1-필요한-자료" class="headerlink" title="1. 필요한 자료"></a><strong>1. 필요한 자료</strong></h4><ul>
<li><p>ESLint가 설치된, 스택에 상관 없는 Node.js 샘플 앱</p>
</li>
<li><p>샘플 앱을 올린 Public Repo가 필요하다.</p>
</li>
<li><p>(이 글에서 코드를 따로 제공하지는 않는다.)</p>
</li>
<li><p>글쓴이는 토이 작업 중인 <a target="_blank" rel="noopener" href="https://github.com/seongbin9786/study-nodejs-typescript">이 레포</a>를 활용하였다.</p>
</li>
</ul>
<p>글에서 Jest를 설치하고, ESLint와 연동할 것이다.</p>
<hr>
<h4 id="2-Node-js-템플릿-가져와서-사용하기"><a href="#2-Node-js-템플릿-가져와서-사용하기" class="headerlink" title="2. Node.js 템플릿 가져와서 사용하기"></a><strong>2. Node.js 템플릿 가져와서 사용하기</strong></h4><p>아래는 레포지토리에서 Actions 탭을 눌러, Get started with GitHub Actions 아래에 있는 Node.js 템플릿을 가져온 것이다.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Node.js</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 구독할 이벤트</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">master</span>]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">master</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># jobs 단위로 개별 서버(정확히는 Docker 컨테이너 단위라고 한다.)에서 작업이 수행된다.</span></span><br><span class="line"><span class="comment"># 각 작업은 병렬로 실행 된다고 하는데, needs: build와 같이 표시해서 기다릴 수도 있다.</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># Ubuntu, Windows, MacOS를 지원한다.</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 영상에서도 소개됐는데, 변수 개념으로 생각하면 된다.</span></span><br><span class="line">    <span class="comment"># node-version 과 같이 배열로 돼있으면, 해당 원소를 순회하면서 작업이 반복해서 실행된다.</span></span><br><span class="line">    <span class="comment"># matrix 때문인지 배열만 되는 것 같다. (TODO)</span></span><br><span class="line">    <span class="comment"># 응용해서 runs-on에 여러 OS에서 돌릴 수도 있다.</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">node-version:</span> [<span class="number">14.</span><span class="string">x</span>] <span class="comment"># 템플릿 기본값: [10.x, 12.x, 14.x]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># uses 개념은 다른 사람이 작성한 내용을 실행하는 개념이다.</span></span><br><span class="line">    <span class="comment"># actions/checkout: GitHub의 마지막 커밋으로 Checkout 한다.</span></span><br><span class="line">    <span class="comment"># actions/setup-node: Node.js를 설치한다.</span></span><br><span class="line">    <span class="comment"># run 개념은 명령어를 실행한다. 셸 스크립트와 동일하다.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="comment"># npm ci는 npm install과 같은 기능을 수행한다. 자세한 내용은 아래 링크 참조.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">      <span class="comment"># --if-present 옵션은 npm 스크립트가 존재할 때만 실행시키라는 의미이다.</span></span><br><span class="line">      <span class="comment"># 만약 build 스크립트가 없는 경우, 오류 없이 지나간다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="string">--if-present</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci">npm ci에 대한 스택 오버 플로우 설명</a> (속도가 2배 가량 빠르다고 한다. 캐싱에 대한 내용도 있으면 좋겠다)</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50683885/how-to-check-if-npm-script-exists">–if-present 옵션에 대한 스택 오버 플로우 설명</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/actions/checkout">GitHub Actions Checkout ?</a></p>
<hr>
<p>프로젝트에 이 파일을 <code>.github/workflows/ci.yml</code>로 저장한다.</p>
<p>이후 Push 하면 Actions 탭을 눌렀을 때 해당 빌드 과정이 수행됨을 볼 수 있다.</p>
<p>단, 아직 설정이 다 끝나지 않았으므로, 이 파일의 구조만 확인하기 바란다.</p>
<h4 id="2-기본-제공-Workflow에-Lint-Test-추가"><a href="#2-기본-제공-Workflow에-Lint-Test-추가" class="headerlink" title="2. 기본 제공 Workflow에 Lint, Test 추가"></a><strong>2. 기본 제공 Workflow에 Lint, Test 추가</strong></h4><p>Lint와 Test 과정을 추가한다. 각 과정은 실패 없이 진행돼야 빌드가 성공한다.</p>
<p>Lint 과정에선 error로 설정된 Rule을 위반한 경우 빌드가 실패하게 된다.</p>
<hr>
<p><strong>1. Lint</strong>: <code>node_modules</code> 에 있는 ESLint를 수행하는 스크립트가 필요하다. 아래 내용을 추가하자.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &quot;lint&quot;: &quot;./node_modules/.bin/eslint .&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>ci.yaml 파일에 <code>npm run lint</code>를 추가하자.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="string">--if-present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">lint</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>2. Test</strong>: Jest를 설치하고, 아래 내용을 추가하자.</p>
<p>폴더를 <code>/tests</code>로 설정했는데, 굳이 그럴 필요가 없다면 생략해도 된다.</p>
<p>Test가 하나라도 실패하면 당연히 빌드는 실패하게 된다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &quot;test&quot;: &quot;./node_modules/.bin/jest --verbose ./tests&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52637116/specify-jest-test-files-directory">Jest 폴더 설정 스택 오버플로우 설명</a></p>
<hr>
<p>Jest는 글로벌로 API를 expose하기 때문에 ESLint error가 나지 않으려면 플러그인을 설치해줘야 한다.</p>
<p><code>npm i --save-dev eslint-plugin-jest</code> 로 ESLint-Plugin-Jest를 설치한다.</p>
<p><code>eslintrc.yml</code> 파일에 아래의 내용을 추가한다.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//...</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="string">//...</span></span><br><span class="line">  <span class="attr">jest:</span> <span class="literal">true</span> <span class="comment"># Jest 글로벌</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">jest</span> <span class="comment"># Jest 테스트를 위해 플러그인이 필요하다.</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="string">//...</span></span><br><span class="line">  <span class="comment"># Jest Eslint 옵션은 0,1,2 (off, warn, error) 만 옵션으로 사용 가능하다.</span></span><br><span class="line">  <span class="attr">jest/no-disabled-tests:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">jest/no-focused-tests:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">jest/no-identical-title:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">jest/prefer-to-have-length:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">jest/valid-expect:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31629389/how-to-use-eslint-with-jest">ESLint 설정 스택오버플로우 설명</a></p>
<h4 id="3-빌드-성공-전에-Merge-Button을-누를-수-없게-하기"><a href="#3-빌드-성공-전에-Merge-Button을-누를-수-없게-하기" class="headerlink" title="3. 빌드 성공 전에 Merge Button을 누를 수 없게 하기"></a><strong>3. 빌드 성공 전에 Merge Button을 누를 수 없게 하기</strong></h4><p>GitHub에서 Branch Protection Rule이라는 기능을 제공한다. 레포지토리 &gt; Settings 탭 &gt; Branches 탭 &gt; Branch protection rules 탭 &gt; Add Rule 버튼 클릭 후 아래와 같이 설정하였다.</p>
<p><img src="/images/github-branch-protection.png"></p>
<h4 id="4-끝"><a href="#4-끝" class="headerlink" title="4. 끝!"></a><strong>4. 끝!</strong></h4><ul>
<li>ci.yml 파일을 Push 하자.</li>
<li>Master에 Push하거나 Pull Request를 올리자</li>
<li>CI가 동작함을 확인하자.</li>
</ul>
<p>글쓴이는 아래처럼 잘 동작함을 확인했다.</p>
<p><img src="/images/github-actions-lint-and-test.png"></p>
<p><img src="/images/github-actions-merge-button.png"></p>
<p><img src="/images/github-actions-done.png"></p>
<p>코드 베이스가 작고, 테스트가 사실상 전무하지만, 그래도 Node 설치부터 실행까지 20초밖에 걸리지 않는다는 점은 신기하고 인상적이다. Public 레포로 작업하면 좋은 성능의 CI를 무료로 사용할 수 있어 좋은 것 같다.</p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><ol>
<li><p>CD 과정도 구축하기. Docker 레지스트리 배포가 일반적인 듯하다. (쿠버네티스가 사용되는듯)</p>
</li>
<li><p>Jobs에서 build 하나만으로 괜찮은 것 같긴 한데, 나누는 case는 뭐가 있을지 확인해보기</p>
</li>
<li><p><code>npm run build</code> 명령어로 무엇을 실행할지 고민해보기. Node.js로 프로덕션 배포를 해 본 적이 없어서 뭐가 필요한지 아직 파악하지 못 했다.</p>
</li>
<li><p>GitHub Actions에 대해 이론적으로 더 공부해보고, 할 수 있는 것들 더 많이 배우기</p>
</li>
<li><p>Git Hooks라는 개념도 있다고 한다. 로컬 수준에서도 프로세스를 자동화할 수 있는 것 같은데, 한 번 알아봐야겠다.</p>
</li>
</ol>
<hr>
<h3 id="기타-내용-정리"><a href="#기타-내용-정리" class="headerlink" title="기타 내용 정리"></a><strong>기타 내용 정리</strong></h3><h4 id="Why-is-it-free"><a href="#Why-is-it-free" class="headerlink" title="Why is it free?"></a><strong>Why is it free?</strong></h4><p>public은 무료, private은 사용량 만큼 낸다고 한다.</p>
<p>왜 무료일지 확인해봤는데, <a target="_blank" rel="noopener" href="https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/">출처</a>에 따르면 Open Source 프로젝트 지원이라는 명목이다.</p>
<blockquote>
<p>We want every open source project to be productive and use best practices, so Actions is free for the 40 million developers on GitHub to use with public repositories. For private repositories, Actions offers simple, pay-as-you-go pricing. (…)</p>
</blockquote>
<h4 id="Supported-OS"><a href="#Supported-OS" class="headerlink" title="Supported OS"></a><strong>Supported OS</strong></h4><p>위에서 언급했듯, Ubuntu, Windows, MacOS 이다. Docker 컨테이너로 작동한다고 하며, 매 번 Fresh한 Docker Container가 제공된다고 한다.</p>
<h4 id="계기가-된-Video"><a href="#계기가-된-Video" class="headerlink" title="계기가 된 Video"></a><strong>계기가 된 Video</strong></h4><p>참고한 유튜브 비디오. 간단하게 Github Actions이 뭔지 영상을 보기만 해도 파악이 가능하다.</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana">https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana</a></p>
<p>글쓴이는 도커 기본 개념과 컨테이너 개념에 조금 익숙한 상태로 봐서 쉽다고 느꼈지만, 정말 아무것도 모른다면 조금 어려울 수도 있다. 영상에서도 언급했듯 Github Actions의 설정 파일은 Docker와 비슷하다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-02T12:30:00.000Z" title="2021-01-02T12:30:00.000Z">21-01-02</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Docker/">Docker</a></span><span class="level-item">13분안에 읽기 (약 1933 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/docker-diamol-1-hello-world/">[1 Month Docker] 1. Docker의 기본 컨셉과 Hello World</a></h1><div class="content"><p>Docker의 기본 컨셉을 다루고, 간단한 Hello World를 실습한다.</p>
<hr>
<p><strong><em>build, share, run</em></strong>:</p>
<ul>
<li>build: (생략)</li>
<li>share: <em>DockerHub</em>에서 이미지를 공유할 수 있다.</li>
<li>run: 공유된 이미지를 통해 누구나 컨테이너를 실행할 수 있다.</li>
</ul>
<p><strong>이미지?</strong> 일단 Docker의 재사용 단위라고 생각하자.</p>
<p><strong>도커 컨테이너?</strong> 애플리케이션을 담은 박스.</p>
<ul>
<li><p>이 박스에는 기기명, IP 주소, 스토리지가 딸린, Docker에서 만들어낸 논리적인 가상 컴퓨터가 있다.</p>
</li>
<li><p>애플리케이션은 이 컴퓨터에서 실행된다.</p>
</li>
<li><p>박스 안의 애플리케이션은 박스 밖을 볼 수 없다.</p>
</li>
<li><p>이 박스는 여러 개가 동시에 실행될 수도 있다.</p>
</li>
<li><p>박스는 같은 실제 컴퓨터를 공유하면서 격리된 환경을 갖는다.</p>
</li>
</ul>
<p><strong>일관된 작업 방식</strong>: 아무리 애플리케이션이 복잡하더라도 Docker Image 단위로 Share, Run 만 하면 된다. 몇 개의, 어떤 컴포넌트, 설정 파일, 라이브러리를 사용하는지는 중요하지 않다.</p>
<p><strong>Portability</strong>: Docker가 있는 컴퓨터에선 명령어 하나로 곧바로 설치가 가능하다.</p>
<p><strong>효율적인 자원 활용</strong>: 도커는 VM이 그렇듯, 여러 애플리케이션을 동시에 실행하는 것으로 컴퓨터 자원을 최대한 활용할 수 있다. 다만 VM보다 나은 점을 아래 표로 정리했다.</p>
<table>
<thead>
<tr>
<th align="center">사용 자원</th>
<th align="center">Docker</th>
<th align="center">VM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Guest OS 사용 여부</td>
<td align="center">No (커널 공유)</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">가상화 리소스 비용</td>
<td align="center">매우 낮음 (커널 공유)</td>
<td align="center">독립적인 OS 수준</td>
</tr>
<tr>
<td align="center">Gust OS Update 다운로드</td>
<td align="center">Base Image 교체</td>
<td align="center">수동 설치</td>
</tr>
<tr>
<td align="center">아주 작은 앱 띄우기</td>
<td align="center">Yes</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">인수인계/배포 비용</td>
<td align="center">A Dockerfile</td>
<td align="center">hours of installation</td>
</tr>
</tbody></table>
<p>책에서는 Guest OS License 비용 문제에서도 차이가 난다고 언급했지만, Docker Image 형태로 쓴다고 해서 License 비용이 낮아지거나 사라지지는 않을 것 같다. 반대로 대수가 늘어나기 때문에 Open Source 기반으로 사용하지 않을까 생각이 든다.</p>
<p><a target="_blank" rel="noopener" href="https://indico.cern.ch/event/384358/contributions/909221/attachments/1170419/1689415/151014_hepix_wataru_takase.pdf">네이티브 vs Docker vs KVM(VM 계열) 벤치마크</a> p.19 참고</p>
<p><strong>주요 도커 명령어</strong>:</p>
<table>
<thead>
<tr>
<th align="left">명령어</th>
<th>기능</th>
</tr>
</thead>
<tbody><tr>
<td align="left">docker container ls</td>
<td>실행 중인 컨테이너의 목록 표시</td>
</tr>
<tr>
<td align="left">docker container ls –all</td>
<td>전체 컨테이너의 목록 표시 (종료된 것 포함)</td>
</tr>
<tr>
<td align="left">docker container run –detach {IMG}</td>
<td>컨테이너를 백그라운드로 실행</td>
</tr>
<tr>
<td align="left">docker container run –publish 8088:80 {IMG}</td>
<td>Host의 8088 포트로 Listen하여 컨테이너의 80포트로 전달</td>
</tr>
<tr>
<td align="left">docker container inspect {ID}</td>
<td>컨테이너의 상세 정보를 JSON으로 출력</td>
</tr>
<tr>
<td align="left">docker container stats {ID}</td>
<td>컨테이너가 사용하는 Host 자원 출력</td>
</tr>
<tr>
<td align="left">docker container rm (–force) {ID}</td>
<td>컨테이너를 완전히 제거 (실행 중인 경우 force)</td>
</tr>
<tr>
<td align="left">docker container rm –force $(docker container ls –all – quiet)</td>
<td>모든 컨테이너를 강제 제거</td>
</tr>
</tbody></table>
<p>종료된 컨테이너는 제거된 것이 아니어서 계속 용량을 차지하며, 아래 작업이 가능하다.</p>
<ul>
<li>그대로 다시 실행</li>
<li>컨테이너 내의 App이 생성한 로그를 확인</li>
<li>파일을 Host에서 or Host로 복사</li>
</ul>
<p><strong>컨테이너의 네트워크</strong>:</p>
<ul>
<li><p>기본적으로, 각 컨테이너는 Host 네트워크에 대해 격리된다. 컨테이너는 Host 내의 가상 사설망으로 구성된다.</p>
</li>
<li><p>Docker는 Host의 네트워크 트래픽을 가로채 컨테이너로 보낼 수 있다.</p>
</li>
</ul>
<p><strong>Docker가 컨테이너를 실행하는 방법</strong>:</p>
<p><strong>Docker Engine</strong>은 Docker Backend이다. Docker API(HTTP 기반의 REST API)를 제공한다. 이미지 재사용에 관한 기능은 직접 하고, 컨테이너는 <code>containerd</code>에 기반해 관리한다고 한다. containerd는 CNCF에 의해 관리되는 오픈소스 프로젝트이다.</p>
<p><strong>Docker CLI</strong>: Docker의 Frontend이다. Docker Engine과 소통하는 방법을 제공한다.</p>
<p><strong>기타 정보</strong>:</p>
<p>Docker는 가장 인기가 많은 컨테이너 플랫폼이지만, 다른 기술도 있으며 컨테이너 기술로 인해 플랫폼에 락인될 걱정은 하지 않아도 된다.</p>
<p>Docker는 이미지를 사용해 컨테이너를 실행한다. 이 때 이미지가 로컬에 있어야 한다. <code>docker container run</code>을 할 때에 없으면 <code>docker pull</code>을 받게 된다. 한 번 다운로드한 이미지는 재사용한다.</p>
<p>도커 컨테이너 Id는 컨테이너의 hostname이 된다.</p>
<p>컨테이너를 선택할 때, 이름 앞 몇글자만 입력해도 된다. 예: <code>f1695...</code>일 때, <code>docker container top f1</code>만 해도 된다.</p>
<hr>
<h3 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h3><p><a target="_blank" rel="noopener" href="https://github.com/sixeyed/diamol/tree/master/ch02/lab">솔루션</a></p>
<p><strong>목표</strong>: 실행 중인 Apache 컨테이너에서 index.html을 변경하라.</p>
<p><strong>힌트</strong>:</p>
<ul>
<li><p>컨테이너는 독립된 파일 시스템을 가지며, 컨테이너 내의 웹 서버 또한 컨테이너의 파일 시스템의 파일을 제공한다.</p>
</li>
<li><p><code>docker container</code> 명령어를 통해 컨테이너에서 수행할 수 있는 명령어 목록을 볼 수 있다.</p>
</li>
<li><p><code>docker &#123;command&#125; --help</code>를 통해 해당 명령어의 상세 설명을 확인할 수 있다.</p>
</li>
<li><p><code>diamol/ch02-hello-diamol-web</code> 이미지는 <code>/usr/local/apache2/htdocs</code> 폴더 내의 파일을 정적으로 제공한다. (윈도우의 경우, <code>C:\user\local\apache2\htdocs</code> 폴더.)</p>
</li>
</ul>
<hr>
<h3 id="내-풀이"><a href="#내-풀이" class="headerlink" title="내 풀이"></a>내 풀이</h3><p>풀이 과정을 서술함.</p>
<p><strong>1. 제공된 컨테이너 트러블 슈팅</strong>: 일단 <code>ch02-hello-diamol-web</code> 의 기본 포트인 8088은 접속할 수가 없었다. 그래서 DockerHub 가서 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/httpd">Apache 이미지</a>를 받아서 실행해봤다. 8080 포트로 잘 되더라. 이 때 명령어가 <code>$ docker run -dit --name my-apache-app -p 8080:80 -v &quot;$PWD&quot;:/usr/local/apache2/htdocs/ httpd:2.4</code> 였는데, 배운 점:</p>
<ul>
<li><code>-dit</code>: <code>--detach --interactive</code>의 약자인데, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41916435/practically-what-is-the-difference-between-docker-run-dit-itd-vs-docker-run">-dit가 필요한 이유</a>를 보면, bash 스크립트가 엔트리 포인트인 경우 <code>-d</code>만 하면 정지된 상태에서 아무것도 못한다고 한다. <code>-it</code>를 줘서 셸이 있어야 스크립트가 실행된다고 한다.</li>
<li><code>-p</code>: <code>--publish</code>의 약자이다.</li>
<li><code>-v</code>: 아직 안 배웠지만, 볼륨 개념일 것으로 추정된다.</li>
</ul>
<p>도커 자체의 네트워크 문제가 아님을 알고, 80으로 하니까 잘 됐는데, 이유는 모르겠다.</p>
<p><strong>2. 컨테이너 셸 접속</strong>: 일단 <code>docker container exec -it --tty &#123;id&#125; /bin/bash</code> 로 접속할 순 있었다. (나오는건 exit 치면 된다.)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22272401/what-does-it-mean-to-attach-a-tty-std-in-out-to-dockers-or-lxc"><code>--tty</code> 옵션에 대한 글</a> 참고</li>
</ul>
<p><strong>3. 직접 파일 수정</strong>: 무슨 망할 기반 이미지를 쓰는지 vi 밖에 지원을 하지 않아서 직접 수정은 포기했다. 파일을 복사해야 하는데, 어떻게 하는지 모르겠다.</p>
<p><strong>4. 파일 복사 방법</strong>: Dockerfile을 수정하는 게 가장 쉬울 것 같았지만, 제공되지 않아서 할 수 없었다. 복사를 해야 하는데, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22907231/how-to-copy-files-from-host-to-docker-container">호스트에서 컨테이너로 파일 복사하기</a>로 <code>docker cp</code> 명령어를 배워서 수행했고, 성공했다.</p>
<hr>
<p>매우 작은 작업이었지만 너무 오랜 기간이 걸렸다. 아무래도 기록하면서 하니까 오래 걸리고, 책의 내용을 요약했음에도 불구하고 며칠만에 다시 보는거여서 오래 걸렸다.</p>
<p>많이 헤맨 덕분에, <code>docker container ls</code>, <code>docker container rm</code>, <code>docker container exec</code>, <code>docker container run</code>은 정말 많이 사용해서 다행이다.</p>
<hr>
<p>참고 자료: Docker In A Month of Lunches (Manning, 2020)</p>
<hr>
<p>추가로 읽을 것: <a target="_blank" rel="noopener" href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">Docker와 VM</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">이전</a></div><div class="pagination-next"><a href="/page/5/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">48</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/NCloud/"><span class="level-start"><span class="level-item">NCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/RabbitMQ/"><span class="level-start"><span class="level-item">RabbitMQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-29T14:59:00.000Z">21-08-29</time></p><p class="title"><a href="/linux-uptime-top/">## uptime, top으로 CPU 부하 확인하기</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-22T09:20:00.000Z">21-08-22</time></p><p class="title"><a href="/linux-rmq-monitoring-easy/">리눅스에서 tmux와 rabbitmqctl을 이용한 Queue 잔여 메시지 모니터링하기</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/RabbitMQ/">RabbitMQ</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-15T10:10:00.000Z">21-08-15</time></p><p class="title"><a href="/linux-new-machine-settings/">리눅스 - 클라우드 머신 세팅하기 (Naver Cloud)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/NCloud/">NCloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-25T14:55:00.000Z">21-07-25</time></p><p class="title"><a href="/linux-file-descriptor/">리눅스에서의 파일 디스크립터와 리다이렉션</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-17T14:58:00.000Z">21-07-17</time></p><p class="title"><a href="/linux-env-security/">환경 변수와 보안</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NCloud/"><span class="tag">NCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RabbitMQ/"><span class="tag">RabbitMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-07T03:30:00.000Z" title="2021-01-07T03:30:00.000Z">21-01-07</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Docker/">Docker</a></span><span class="level-item">16분안에 읽기 (약 2338 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/docker-diamol-2-dockerfile-image/">[1 Month Docker] 2. Dockerfile, Docker Image</a></h1><div class="content"><p>Dockerfile과 Docker Image 개념을 소개하고, 핵심적인 내용을 설명한다. <a href="https://jsqna.com/docker-diamol-1-hello-world/">Docker에 대한 간단한 소개</a>의 내용을 기본으로 가정하고 시작한다.</p>
<hr>
<p>저번 글에선 Container와 Docker를 체험해보았다. Container는 어떠한 스택의 애플리케이션이든 배포 측면에서 일관된 경험을 제공하므로 사용하는 것이 좋지 않을까 생각한다.</p>
<p>Docker로 Container를 실행하려면 Docker Image가 필요한데, 이번 글에서는 최종적으로 Image를 직접 생성한다(공식적으로는 build 한다고 표현함.).</p>
<h3 id="1-기초-개념-설명"><a href="#1-기초-개념-설명" class="headerlink" title="1. 기초 개념 설명"></a><strong>1. 기초 개념 설명</strong></h3><p><strong>1. Dockerfile</strong>: 이미지 빌드 명령어의 입력으로 들어가는 스크립트이다. 아래와 같은 내용을 담는다.</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parent Image 지정</span></span><br><span class="line"><span class="comment"># Dockerfile은 이미지를 정의하는 파일이다.</span></span><br><span class="line"><span class="comment"># 새 이미지를 만들 때 다른 이미지의 내용에 기반해 덧씌우는 형태이다.</span></span><br><span class="line"><span class="keyword">FROM</span> diamol/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 환경 변수 3개 설정</span></span><br><span class="line"><span class="comment"># Docker와 같이 컨테이너 환경으로 앱이 배포되는 경우,</span></span><br><span class="line"><span class="comment"># 환경 변수를 arguments로 많이 활용한다.</span></span><br><span class="line"><span class="keyword">ENV</span> TARGET=<span class="string">&quot;blog.sixeyed.com&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> METHOD=<span class="string">&quot;HEAD&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> INTERVAL=<span class="string">&quot;3000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Working Directory를 /web-ping으로 지정 (폴더 생성 후 이동함. mkdir &amp;&amp; cd)</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /web-ping</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Host의 app.js 파일을, Working Directory(.)에 복사</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.js .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># node로 다음의 js를 실행</span></span><br><span class="line"><span class="comment"># CMD 명령어는 컨테이너 실행 시에 1회 수행되는</span></span><br><span class="line"><span class="comment"># container.once(&#x27;start&#x27;, callback)과 같다.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;/web-ping/app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>아마 셸 스크립트에 익숙한 사람은 셸 스크립트와 다름 없다고 생각할 것이다. 맞다. 똑같다. 아마 셸 스크립트가 익숙하지 않으면 Dockerfile에 쉽게 친해질 순 없을텐데, <a target="_blank" rel="noopener" href="https://tacademy.skplanet.com/live/player/onlineLectureDetail.action?seq=185">리눅스 환경 구성 기초 | T 아카데미</a>나 <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1zMf2HhVSR7MGJxafR8zRzqQEuRUBSDfG7yWx-GjBu6Q/edit#slide=id.p">리눅스 커맨드 라인 &amp; 쉘 스크립트 #1 | ABCD DevOps</a>라는 좋은 자료가 있으니 참고하자.</p>
</blockquote>
<p>Dockerfile 안에서만 쓸 수 있는, Dockerfile에서 쓰일 만한, 명령어가 10개 정의돼있다. 이 명령어들이 주축이 돼서 Dockerfile의 내용을 구성하게 된다.</p>
<ul>
<li><p>전체 기능에 대해서는 <a target="_blank" rel="noopener" href="https://medium.com/@iced_burn/dockerfile-cheat-sheet-9f52aa4a99b3">Dockerfile Cheat Sheet</a>를 참고하라.</p>
</li>
<li><p>걔 중 유사한 명령어인 <a target="_blank" rel="noopener" href="https://blog.leocat.kr/notes/2017/01/08/docker-run-vs-cmd-vs-entrypoint">CMD vs RUN vs ENTRYPOINT를 정리한 글</a>도 있으니 참고하기 바란다.</p>
</li>
<li><p>Dockerfile 명령어는 대소문자를 구분하지 않지만 대문자로 쓰는 게 컨벤션이다.</p>
</li>
</ul>
<p><strong>2. Image</strong>: 이미지는 Dockerfile에서 기술한 내용이 실행된 모습을 스냅샷 형태로 담은 파일이다.</p>
<ul>
<li>컨테이너 실행 시 이미지를 통해 Dockerfile에 정의된 내용이 그대로 재현된다.</li>
</ul>
<p><strong>3. Image 받아오기</strong>: 이미지를 직접 생성하지 않고, DockerHub 등의 Docker Registry (이미지 저장 서버)에서 받아올 수도 있다. 단순히 받아오기만 하는 명령어는 <code>docker image pull</code> 이다.</p>
<ul>
<li><code>docker image pull diamol/ch03-web-ping</code> 을 실행해 DockerHub에서 이미지를 받자.</li>
<li><img src="/images/image-1.png"></li>
<li>하나의 이미지를 받는데, 여러 <code>Pull Complete</code>가 표시돼있다. (나중에 설명한다.)</li>
</ul>
<p><strong>4. Image 빌드</strong>: <code>docker image build</code> 명령어를 실행하면, 이미지는 자동으로 빌드된다.</p>
<p>예: <code>docker image build --tag web-ping .</code> =&gt; <code>web-ping</code>이라는 이미지를 생성.</p>
<ul>
<li>(Mandatory) <code>.</code>은 Dockerfile 및 <code>COPY</code> 등에서 Host의 기준 디렉토리로 사용된다.</li>
<li>(Mandatory) <code>--tag</code>는 이미지의 이름을 지정한다.</li>
<li>주의: 파일을 Windows -&gt; Linux로 복사하는 경우, 권한이 <code>rwxrwx</code>로 지정되는데, 이는 서로 권한 정보가 호환되지 않기 때문이다.</li>
<li>로컬에서 직접 빌드된 이미지는 도커 엔진에 캐시돼 보관된다.</li>
<li>새로운 버전을 빌드하려는 경우, <code>--tag web-ping:v2</code>와 같이 <code>:</code>으로 버전을 구분하여 명시하면 된다.</li>
</ul>
<p><img src="/images/image-2.png" alt="Docker Image Build Process Example"></p>
<p><strong>5. Image 실행(컨테이너로)</strong>:</p>
<ul>
<li><code>docker container run &#123;image_name&#125;</code>으로 실행</li>
</ul>
<p><strong>6. Image Layer</strong>:</p>
<p>이미지에는 생성 과정에 대한 메타데이터도 포함된다. 이미지 생성 과정을 통해</p>
<ul>
<li><code>docker image history web-ping</code></li>
<li><img src="/images/image-3.png" alt="Image History Example"></li>
</ul>
<p>Docker Image는 Image Layer라는 더 작은 개념으로 구성되며, Dockerfile의 각 명령(<code>CREATED BY</code>) 마다 Layer가 생성된다.</p>
<ul>
<li>이미지는 각 Layer의 논리적인 집합이다.</li>
<li>Layer는 도커 엔진에 물리적인 파일의 형태로 캐시되는 단위이다.</li>
<li>이미지 간에 Layer가 공유되므로 전체 용량 부하를 낮출 수 있다.<ul>
<li><code>docker image ls</code>로 논리적인 용량을 확인할 수 있지만, <code>docker system df</code>로 이미지가 차지하는 물리적인 용량을 확인할 수 있다.</li>
<li><img src="/images/image-4.png" alt="docker system df"></li>
</ul>
</li>
</ul>
<p>이런 Image Layer 캐시를 활용하려면 조건이 필요한데: Layer 이전의 Layer 들의 내용과 순서가 바뀌지 않아야 한다.</p>
<ul>
<li>이전 내용이 바뀌었는데, 이 명령(Layer)을 실행한 결과가 같음을 보장할 수 없다.</li>
<li>만약 내용을 바꾸는 경우, 이 Layer에 의존하고 있던 모든 이미지에 영향을 끼친다.</li>
<li>그러므로, 이전 Layer가 변경되는 경우, 이후 Layer는 캐시로 사용될 수 없게 되고, 새로 Layer를 생성하게 된다.</li>
</ul>
<p><strong>7. Layer 캐시 최적화 전략</strong>: Layer 캐시 활용을 통해 전체 용량과 이미지 빌드 시간을 줄일 수 있다.</p>
<ul>
<li><p>이미지에서 변하지 않는 부분을 최대한 먼저 실행해 새로 빌드할 Layer 수를 줄인다.</p>
</li>
<li><p>캐시 사용 가능 여부는 Instruction의 내용과 Arguments(명령어 내용일 수도 있지만, <code>COPY</code>와 같은 경우 파일의 내용까지.)로 Hash 값을 만들고 비교하여 결정한다.</p>
</li>
<li><p>Hash가 일치하는 경우 빌드하지 않고 도커 엔진에 캐시된 Layer를 사용한다. 일치하지 않는 경우, 해당 Layer부터 최종 Layer까지 새로 빌드한다. (뒷 Layer의 해시가 같아도, 재사용할 수 없다.)</p>
</li>
<li><p><img src="/images/image-5.png" alt="docker build image cache"></p>
</li>
<li><p><code>app.js</code> 파일을 수정한 후 (<code>nano app.js</code>) 빌드한 모습이다. <code>COPY app.js</code>를 수행하는 <code>step 6</code>가 다시 Layer를 만듦을 확인할 수 있고, 이후 Layer인 <code>step 7</code>은 바뀐 내용이 없지만 앞 Layer가 바뀌어서 다시 만들어짐을 확인할 수 있다.</p>
</li>
</ul>
<p><strong>8. Layer 캐시 최적화 예시</strong>:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> diamol/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 시작 시 실행될 명령어를 지정하는 것이므로, 어디에 놓아도 상관 없다.</span></span><br><span class="line"><span class="comment"># 캐시를 위해 앞에 놓는다.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;/web-ping/app.js&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 환경 변수 3개를 한 번에 등록해 Layer 개수를 줄였다.</span></span><br><span class="line"><span class="comment"># 개수를 줄인 것과 캐시 최적화는 큰 연관은 없지만...</span></span><br><span class="line"><span class="keyword">ENV</span> TARGET=<span class="string">&quot;blog.sixeyed.com&quot;</span> \</span><br><span class="line">	METHOD=<span class="string">&quot;HEAD&quot;</span> \</span><br><span class="line">	INTERVAL=<span class="string">&quot;3000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /web-ping</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.js .</span></span><br></pre></td></tr></table></figure>
<p>이제 <code>docker image build -t web-ping:v3</code>를 실행해보자. 환경 변수 개수가 줄어들어 7단계에서 5단계로 줄었음을 확인할 수 있다.</p>
<p>이제부턴 <code>app.js</code>를 수정해도 마지막 Layer만 바뀐다.</p>
<hr>
<h3 id="2-실습"><a href="#2-실습" class="headerlink" title="2. 실습"></a><strong>2. 실습</strong></h3><p><strong>1. 목표</strong>:</p>
<p><code>diamol/ch03-lab</code> 폴더의 이미지에서 <code>/diamol/ch03.txt</code> 파일을 수정하고 새 Image를 생성하라. 이 때 Dockerfile을 수정해서는 안 된다.</p>
<p><strong>2. 힌트</strong>:</p>
<ul>
<li><code>-it</code>으로 컨테이너에 키보드 I/O 가능</li>
<li>컨테이너 파일 시스템이 Exit 상태에도 제거되지 않음을 활용</li>
<li><code>docker container --help</code>로 모르는 명령어에 대해 공부할 것</li>
</ul>
<p><strong>3. 처음 생각한 접근 방법</strong>:</p>
<ol>
<li>Container에서 일단 파일을 수정한다.</li>
<li>컨테이너로 이미지를 생성해낸다. 명령어를 찾아보자.</li>
</ol>
<p><strong>4. 실제 수행 과정</strong>:</p>
<hr>
<p><strong>1. 일단 이미지를 빌드함</strong></p>
<p><code>cd ../../lab</code> (빌드를 위해 lab 폴더로 이동)</p>
<p><code>docker build image -t ch03-lab .</code> (빌드 성공)</p>
<hr>
<p><strong>2. 이제 컨테이너를 실행해야 함</strong></p>
<p><code>docker container run ch03-lab</code> (실패)</p>
<p><code>docker container ls</code> (없었음)</p>
<p><code>cat Dockerfile</code> (<code>CMD</code> 등 명령어 실행이 없고, <code>COPY</code> 뿐이었음)</p>
<hr>
<p><strong>3. 컨테이너에서 수행할 명령어로 주어 실행해야 함</strong></p>
<p><code>docker container run ch03-lab /bin/bash</code> (실패)</p>
<p><code>docker container run ch03-lab /bin/sh</code> (이미지에 bash가 없었음..)</p>
<p><code>vi ch03.txt</code> (텍스트 파일 수정)</p>
<p><code>exit</code> (sh 나옴)</p>
<hr>
<p><strong>4. 정지된 컨테이너를 이미지로 빌드해야 함</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/commit/">Docker Commit Reference</a>를 참고해서 빌드 명령어 학습</p>
<p><code>docker container ls --all</code> 로 종료된 컨테이너 ID 확인 (<code>67a</code>)</p>
<p><code>docker image commit 67a ch03-lab:v2</code> (무슨 해시값이 출력됨..)</p>
<p><code>docker image ls</code> (v2로 생성됨을 확인)</p>
<p><code>docker container run ch03-lab:v2 cat ch03.txt</code> (파일 갱신됨을 확인)</p>
<p><strong>끝!</strong></p>
<hr>
<p><strong>Lab 하면서 배운 점:</strong></p>
<p><code>docker commit</code> 명령어로 컨테이너 내용으로 이미지를 빌드할 수 있다는 점.</p>
<ul>
<li>다만 이렇게 되면 Dockerfile은 없는게 아닌가?</li>
</ul>
<p><code>docker container run &#123;IMAGE&#125; &#123;COMMAND&#125;</code>로 명령어를 실행할 수 있음</p>
<ul>
<li>다만 이는 이미지에서 수행하는 명령어가 없는 경우에 한한 것 같고, <code>docker container exec</code>으로 셸을 띄우는 것이 일반적인 것 같다.</li>
</ul>
<p><strong>TO DO</strong>:</p>
<ul>
<li>컨테이너에서 Commit으로 생성한 이미지에서 Dockerfile을 추출할 수 있을지 확인해보기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-04T01:00:00.000Z" title="2021-01-04T01:00:00.000Z">21-01-04</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/CI-CD/">CI/CD</a></span><span class="level-item">14분안에 읽기 (약 2118 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ci-1-github-actions-nodejs/">10분 만에 기반 지식 없이 Node.js를 위한 Github Actions CI 구축하기</a></h1><div class="content"><h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a><strong>목표</strong></h3><ul>
<li>10분 만에 Github Actions를 통한 CI를 구축한다.</li>
<li>master에 Merge 시에 ESLint와 테스트를 자동으로 수행하고, 결과에 따라 Merge할 수 없게 한다.</li>
</ul>
<hr>
<h3 id="1-기본-개념-설명"><a href="#1-기본-개념-설명" class="headerlink" title="1. 기본 개념 설명"></a><strong>1. 기본 개념 설명</strong></h3><p>기본 개념 몇 가지를 소개하고 넘어간다.</p>
<h4 id="1-CI"><a href="#1-CI" class="headerlink" title="1. CI"></a><strong>1. CI</strong></h4><p>Continuous Integration. 각자의 코드를 병합하기 전에 검토하는 절차를 말한다.</p>
<p>보통 자동화된 상태를 지칭하며, <code>master(or main)</code> 등의 특정 브랜치에 <code>Push(or Merge) Request</code>가 올라오면 코드를 검토한다.</p>
<h4 id="2-GitHub-Actions"><a href="#2-GitHub-Actions" class="headerlink" title="2. GitHub Actions"></a><strong>2. GitHub Actions</strong></h4><p>GitHub에서 특정 작업을 할 때 마다, 이벤트를 발생시키는데, 이를 구독해 특정 작업을 실행하는 것을 Github Actions라고 한다. (<a target="_blank" rel="noopener" href="https://pjh3749.tistory.com/266">옵저버 패턴</a> 참고)</p>
<h4 id="3-Worflow-File"><a href="#3-Worflow-File" class="headerlink" title="3. Worflow File"></a><strong>3. Worflow File</strong></h4><p>GitHub Actions의 이벤트에 대해 무엇을 실행할 지에 대해 기록해 놓은 명령서를 <code>workflow</code> 파일이라고 한다.</p>
<h4 id="4-Github-Actions-사용-시의-CI-흐름"><a href="#4-Github-Actions-사용-시의-CI-흐름" class="headerlink" title="4. Github Actions 사용 시의 CI 흐름"></a><strong>4. Github Actions 사용 시의 CI 흐름</strong></h4><p><em>PR Created(EVENT!)</em> &gt; Build &gt; Test &gt; <em>PR Merged(EVENT!)</em> &gt; Deploy (배포 자동화는 다음에)</p>
<ul>
<li>PR을 생성할 때 CI 수행</li>
<li>Merge할 때 CD 수행</li>
</ul>
<p>CI 과정에서 빌드가 성공했을 때만 Merge가 가능하게 설정하자.</p>
<h3 id="2-Node-js-App-으로-CI-구축-시작"><a href="#2-Node-js-App-으로-CI-구축-시작" class="headerlink" title="2. Node.js App 으로 CI 구축 시작"></a><strong>2. Node.js App 으로 CI 구축 시작</strong></h3><p>이 챕터에서 구축을 완료하고, 결과를 확인한다.</p>
<p>아주 간단한 과정이어서 CI라고 하긴 부끄럽지만, 아래 과정을 수행한다.</p>
<ul>
<li>npm module 설치</li>
<li>ESLint를 통한 코드 스타일 체크</li>
<li>테스트 실행</li>
</ul>
<h4 id="1-필요한-자료"><a href="#1-필요한-자료" class="headerlink" title="1. 필요한 자료"></a><strong>1. 필요한 자료</strong></h4><ul>
<li><p>ESLint가 설치된, 스택에 상관 없는 Node.js 샘플 앱</p>
</li>
<li><p>샘플 앱을 올린 Public Repo가 필요하다.</p>
</li>
<li><p>(이 글에서 코드를 따로 제공하지는 않는다.)</p>
</li>
<li><p>글쓴이는 토이 작업 중인 <a target="_blank" rel="noopener" href="https://github.com/seongbin9786/study-nodejs-typescript">이 레포</a>를 활용하였다.</p>
</li>
</ul>
<p>글에서 Jest를 설치하고, ESLint와 연동할 것이다.</p>
<hr>
<h4 id="2-Node-js-템플릿-가져와서-사용하기"><a href="#2-Node-js-템플릿-가져와서-사용하기" class="headerlink" title="2. Node.js 템플릿 가져와서 사용하기"></a><strong>2. Node.js 템플릿 가져와서 사용하기</strong></h4><p>아래는 레포지토리에서 Actions 탭을 눌러, Get started with GitHub Actions 아래에 있는 Node.js 템플릿을 가져온 것이다.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Node.js</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 구독할 이벤트</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">master</span>]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">master</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># jobs 단위로 개별 서버(정확히는 Docker 컨테이너 단위라고 한다.)에서 작업이 수행된다.</span></span><br><span class="line"><span class="comment"># 각 작업은 병렬로 실행 된다고 하는데, needs: build와 같이 표시해서 기다릴 수도 있다.</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># Ubuntu, Windows, MacOS를 지원한다.</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 영상에서도 소개됐는데, 변수 개념으로 생각하면 된다.</span></span><br><span class="line">    <span class="comment"># node-version 과 같이 배열로 돼있으면, 해당 원소를 순회하면서 작업이 반복해서 실행된다.</span></span><br><span class="line">    <span class="comment"># matrix 때문인지 배열만 되는 것 같다. (TODO)</span></span><br><span class="line">    <span class="comment"># 응용해서 runs-on에 여러 OS에서 돌릴 수도 있다.</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">node-version:</span> [<span class="number">14.</span><span class="string">x</span>] <span class="comment"># 템플릿 기본값: [10.x, 12.x, 14.x]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># uses 개념은 다른 사람이 작성한 내용을 실행하는 개념이다.</span></span><br><span class="line">    <span class="comment"># actions/checkout: GitHub의 마지막 커밋으로 Checkout 한다.</span></span><br><span class="line">    <span class="comment"># actions/setup-node: Node.js를 설치한다.</span></span><br><span class="line">    <span class="comment"># run 개념은 명령어를 실행한다. 셸 스크립트와 동일하다.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="comment"># npm ci는 npm install과 같은 기능을 수행한다. 자세한 내용은 아래 링크 참조.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">      <span class="comment"># --if-present 옵션은 npm 스크립트가 존재할 때만 실행시키라는 의미이다.</span></span><br><span class="line">      <span class="comment"># 만약 build 스크립트가 없는 경우, 오류 없이 지나간다.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="string">--if-present</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci">npm ci에 대한 스택 오버 플로우 설명</a> (속도가 2배 가량 빠르다고 한다. 캐싱에 대한 내용도 있으면 좋겠다)</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50683885/how-to-check-if-npm-script-exists">–if-present 옵션에 대한 스택 오버 플로우 설명</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/actions/checkout">GitHub Actions Checkout ?</a></p>
<hr>
<p>프로젝트에 이 파일을 <code>.github/workflows/ci.yml</code>로 저장한다.</p>
<p>이후 Push 하면 Actions 탭을 눌렀을 때 해당 빌드 과정이 수행됨을 볼 수 있다.</p>
<p>단, 아직 설정이 다 끝나지 않았으므로, 이 파일의 구조만 확인하기 바란다.</p>
<h4 id="2-기본-제공-Workflow에-Lint-Test-추가"><a href="#2-기본-제공-Workflow에-Lint-Test-추가" class="headerlink" title="2. 기본 제공 Workflow에 Lint, Test 추가"></a><strong>2. 기본 제공 Workflow에 Lint, Test 추가</strong></h4><p>Lint와 Test 과정을 추가한다. 각 과정은 실패 없이 진행돼야 빌드가 성공한다.</p>
<p>Lint 과정에선 error로 설정된 Rule을 위반한 경우 빌드가 실패하게 된다.</p>
<hr>
<p><strong>1. Lint</strong>: <code>node_modules</code> 에 있는 ESLint를 수행하는 스크립트가 필요하다. 아래 내용을 추가하자.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &quot;lint&quot;: &quot;./node_modules/.bin/eslint .&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>ci.yaml 파일에 <code>npm run lint</code>를 추가하자.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="string">--if-present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">lint</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>2. Test</strong>: Jest를 설치하고, 아래 내용을 추가하자.</p>
<p>폴더를 <code>/tests</code>로 설정했는데, 굳이 그럴 필요가 없다면 생략해도 된다.</p>
<p>Test가 하나라도 실패하면 당연히 빌드는 실패하게 된다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &quot;test&quot;: &quot;./node_modules/.bin/jest --verbose ./tests&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52637116/specify-jest-test-files-directory">Jest 폴더 설정 스택 오버플로우 설명</a></p>
<hr>
<p>Jest는 글로벌로 API를 expose하기 때문에 ESLint error가 나지 않으려면 플러그인을 설치해줘야 한다.</p>
<p><code>npm i --save-dev eslint-plugin-jest</code> 로 ESLint-Plugin-Jest를 설치한다.</p>
<p><code>eslintrc.yml</code> 파일에 아래의 내용을 추가한다.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//...</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="string">//...</span></span><br><span class="line">  <span class="attr">jest:</span> <span class="literal">true</span> <span class="comment"># Jest 글로벌</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">jest</span> <span class="comment"># Jest 테스트를 위해 플러그인이 필요하다.</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="string">//...</span></span><br><span class="line">  <span class="comment"># Jest Eslint 옵션은 0,1,2 (off, warn, error) 만 옵션으로 사용 가능하다.</span></span><br><span class="line">  <span class="attr">jest/no-disabled-tests:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">jest/no-focused-tests:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">jest/no-identical-title:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">jest/prefer-to-have-length:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">warn</span></span><br><span class="line">  <span class="attr">jest/valid-expect:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">error</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31629389/how-to-use-eslint-with-jest">ESLint 설정 스택오버플로우 설명</a></p>
<h4 id="3-빌드-성공-전에-Merge-Button을-누를-수-없게-하기"><a href="#3-빌드-성공-전에-Merge-Button을-누를-수-없게-하기" class="headerlink" title="3. 빌드 성공 전에 Merge Button을 누를 수 없게 하기"></a><strong>3. 빌드 성공 전에 Merge Button을 누를 수 없게 하기</strong></h4><p>GitHub에서 Branch Protection Rule이라는 기능을 제공한다. 레포지토리 &gt; Settings 탭 &gt; Branches 탭 &gt; Branch protection rules 탭 &gt; Add Rule 버튼 클릭 후 아래와 같이 설정하였다.</p>
<p><img src="/images/github-branch-protection.png"></p>
<h4 id="4-끝"><a href="#4-끝" class="headerlink" title="4. 끝!"></a><strong>4. 끝!</strong></h4><ul>
<li>ci.yml 파일을 Push 하자.</li>
<li>Master에 Push하거나 Pull Request를 올리자</li>
<li>CI가 동작함을 확인하자.</li>
</ul>
<p>글쓴이는 아래처럼 잘 동작함을 확인했다.</p>
<p><img src="/images/github-actions-lint-and-test.png"></p>
<p><img src="/images/github-actions-merge-button.png"></p>
<p><img src="/images/github-actions-done.png"></p>
<p>코드 베이스가 작고, 테스트가 사실상 전무하지만, 그래도 Node 설치부터 실행까지 20초밖에 걸리지 않는다는 점은 신기하고 인상적이다. Public 레포로 작업하면 좋은 성능의 CI를 무료로 사용할 수 있어 좋은 것 같다.</p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><ol>
<li><p>CD 과정도 구축하기. Docker 레지스트리 배포가 일반적인 듯하다. (쿠버네티스가 사용되는듯)</p>
</li>
<li><p>Jobs에서 build 하나만으로 괜찮은 것 같긴 한데, 나누는 case는 뭐가 있을지 확인해보기</p>
</li>
<li><p><code>npm run build</code> 명령어로 무엇을 실행할지 고민해보기. Node.js로 프로덕션 배포를 해 본 적이 없어서 뭐가 필요한지 아직 파악하지 못 했다.</p>
</li>
<li><p>GitHub Actions에 대해 이론적으로 더 공부해보고, 할 수 있는 것들 더 많이 배우기</p>
</li>
<li><p>Git Hooks라는 개념도 있다고 한다. 로컬 수준에서도 프로세스를 자동화할 수 있는 것 같은데, 한 번 알아봐야겠다.</p>
</li>
</ol>
<hr>
<h3 id="기타-내용-정리"><a href="#기타-내용-정리" class="headerlink" title="기타 내용 정리"></a><strong>기타 내용 정리</strong></h3><h4 id="Why-is-it-free"><a href="#Why-is-it-free" class="headerlink" title="Why is it free?"></a><strong>Why is it free?</strong></h4><p>public은 무료, private은 사용량 만큼 낸다고 한다.</p>
<p>왜 무료일지 확인해봤는데, <a target="_blank" rel="noopener" href="https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/">출처</a>에 따르면 Open Source 프로젝트 지원이라는 명목이다.</p>
<blockquote>
<p>We want every open source project to be productive and use best practices, so Actions is free for the 40 million developers on GitHub to use with public repositories. For private repositories, Actions offers simple, pay-as-you-go pricing. (…)</p>
</blockquote>
<h4 id="Supported-OS"><a href="#Supported-OS" class="headerlink" title="Supported OS"></a><strong>Supported OS</strong></h4><p>위에서 언급했듯, Ubuntu, Windows, MacOS 이다. Docker 컨테이너로 작동한다고 하며, 매 번 Fresh한 Docker Container가 제공된다고 한다.</p>
<h4 id="계기가-된-Video"><a href="#계기가-된-Video" class="headerlink" title="계기가 된 Video"></a><strong>계기가 된 Video</strong></h4><p>참고한 유튜브 비디오. 간단하게 Github Actions이 뭔지 영상을 보기만 해도 파악이 가능하다.</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana">https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana</a></p>
<p>글쓴이는 도커 기본 개념과 컨테이너 개념에 조금 익숙한 상태로 봐서 쉽다고 느꼈지만, 정말 아무것도 모른다면 조금 어려울 수도 있다. 영상에서도 언급했듯 Github Actions의 설정 파일은 Docker와 비슷하다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-02T12:30:00.000Z" title="2021-01-02T12:30:00.000Z">21-01-02</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Docker/">Docker</a></span><span class="level-item">13분안에 읽기 (약 1933 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/docker-diamol-1-hello-world/">[1 Month Docker] 1. Docker의 기본 컨셉과 Hello World</a></h1><div class="content"><p>Docker의 기본 컨셉을 다루고, 간단한 Hello World를 실습한다.</p>
<hr>
<p><strong><em>build, share, run</em></strong>:</p>
<ul>
<li>build: (생략)</li>
<li>share: <em>DockerHub</em>에서 이미지를 공유할 수 있다.</li>
<li>run: 공유된 이미지를 통해 누구나 컨테이너를 실행할 수 있다.</li>
</ul>
<p><strong>이미지?</strong> 일단 Docker의 재사용 단위라고 생각하자.</p>
<p><strong>도커 컨테이너?</strong> 애플리케이션을 담은 박스.</p>
<ul>
<li><p>이 박스에는 기기명, IP 주소, 스토리지가 딸린, Docker에서 만들어낸 논리적인 가상 컴퓨터가 있다.</p>
</li>
<li><p>애플리케이션은 이 컴퓨터에서 실행된다.</p>
</li>
<li><p>박스 안의 애플리케이션은 박스 밖을 볼 수 없다.</p>
</li>
<li><p>이 박스는 여러 개가 동시에 실행될 수도 있다.</p>
</li>
<li><p>박스는 같은 실제 컴퓨터를 공유하면서 격리된 환경을 갖는다.</p>
</li>
</ul>
<p><strong>일관된 작업 방식</strong>: 아무리 애플리케이션이 복잡하더라도 Docker Image 단위로 Share, Run 만 하면 된다. 몇 개의, 어떤 컴포넌트, 설정 파일, 라이브러리를 사용하는지는 중요하지 않다.</p>
<p><strong>Portability</strong>: Docker가 있는 컴퓨터에선 명령어 하나로 곧바로 설치가 가능하다.</p>
<p><strong>효율적인 자원 활용</strong>: 도커는 VM이 그렇듯, 여러 애플리케이션을 동시에 실행하는 것으로 컴퓨터 자원을 최대한 활용할 수 있다. 다만 VM보다 나은 점을 아래 표로 정리했다.</p>
<table>
<thead>
<tr>
<th align="center">사용 자원</th>
<th align="center">Docker</th>
<th align="center">VM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Guest OS 사용 여부</td>
<td align="center">No (커널 공유)</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">가상화 리소스 비용</td>
<td align="center">매우 낮음 (커널 공유)</td>
<td align="center">독립적인 OS 수준</td>
</tr>
<tr>
<td align="center">Gust OS Update 다운로드</td>
<td align="center">Base Image 교체</td>
<td align="center">수동 설치</td>
</tr>
<tr>
<td align="center">아주 작은 앱 띄우기</td>
<td align="center">Yes</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">인수인계/배포 비용</td>
<td align="center">A Dockerfile</td>
<td align="center">hours of installation</td>
</tr>
</tbody></table>
<p>책에서는 Guest OS License 비용 문제에서도 차이가 난다고 언급했지만, Docker Image 형태로 쓴다고 해서 License 비용이 낮아지거나 사라지지는 않을 것 같다. 반대로 대수가 늘어나기 때문에 Open Source 기반으로 사용하지 않을까 생각이 든다.</p>
<p><a target="_blank" rel="noopener" href="https://indico.cern.ch/event/384358/contributions/909221/attachments/1170419/1689415/151014_hepix_wataru_takase.pdf">네이티브 vs Docker vs KVM(VM 계열) 벤치마크</a> p.19 참고</p>
<p><strong>주요 도커 명령어</strong>:</p>
<table>
<thead>
<tr>
<th align="left">명령어</th>
<th>기능</th>
</tr>
</thead>
<tbody><tr>
<td align="left">docker container ls</td>
<td>실행 중인 컨테이너의 목록 표시</td>
</tr>
<tr>
<td align="left">docker container ls –all</td>
<td>전체 컨테이너의 목록 표시 (종료된 것 포함)</td>
</tr>
<tr>
<td align="left">docker container run –detach {IMG}</td>
<td>컨테이너를 백그라운드로 실행</td>
</tr>
<tr>
<td align="left">docker container run –publish 8088:80 {IMG}</td>
<td>Host의 8088 포트로 Listen하여 컨테이너의 80포트로 전달</td>
</tr>
<tr>
<td align="left">docker container inspect {ID}</td>
<td>컨테이너의 상세 정보를 JSON으로 출력</td>
</tr>
<tr>
<td align="left">docker container stats {ID}</td>
<td>컨테이너가 사용하는 Host 자원 출력</td>
</tr>
<tr>
<td align="left">docker container rm (–force) {ID}</td>
<td>컨테이너를 완전히 제거 (실행 중인 경우 force)</td>
</tr>
<tr>
<td align="left">docker container rm –force $(docker container ls –all – quiet)</td>
<td>모든 컨테이너를 강제 제거</td>
</tr>
</tbody></table>
<p>종료된 컨테이너는 제거된 것이 아니어서 계속 용량을 차지하며, 아래 작업이 가능하다.</p>
<ul>
<li>그대로 다시 실행</li>
<li>컨테이너 내의 App이 생성한 로그를 확인</li>
<li>파일을 Host에서 or Host로 복사</li>
</ul>
<p><strong>컨테이너의 네트워크</strong>:</p>
<ul>
<li><p>기본적으로, 각 컨테이너는 Host 네트워크에 대해 격리된다. 컨테이너는 Host 내의 가상 사설망으로 구성된다.</p>
</li>
<li><p>Docker는 Host의 네트워크 트래픽을 가로채 컨테이너로 보낼 수 있다.</p>
</li>
</ul>
<p><strong>Docker가 컨테이너를 실행하는 방법</strong>:</p>
<p><strong>Docker Engine</strong>은 Docker Backend이다. Docker API(HTTP 기반의 REST API)를 제공한다. 이미지 재사용에 관한 기능은 직접 하고, 컨테이너는 <code>containerd</code>에 기반해 관리한다고 한다. containerd는 CNCF에 의해 관리되는 오픈소스 프로젝트이다.</p>
<p><strong>Docker CLI</strong>: Docker의 Frontend이다. Docker Engine과 소통하는 방법을 제공한다.</p>
<p><strong>기타 정보</strong>:</p>
<p>Docker는 가장 인기가 많은 컨테이너 플랫폼이지만, 다른 기술도 있으며 컨테이너 기술로 인해 플랫폼에 락인될 걱정은 하지 않아도 된다.</p>
<p>Docker는 이미지를 사용해 컨테이너를 실행한다. 이 때 이미지가 로컬에 있어야 한다. <code>docker container run</code>을 할 때에 없으면 <code>docker pull</code>을 받게 된다. 한 번 다운로드한 이미지는 재사용한다.</p>
<p>도커 컨테이너 Id는 컨테이너의 hostname이 된다.</p>
<p>컨테이너를 선택할 때, 이름 앞 몇글자만 입력해도 된다. 예: <code>f1695...</code>일 때, <code>docker container top f1</code>만 해도 된다.</p>
<hr>
<h3 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h3><p><a target="_blank" rel="noopener" href="https://github.com/sixeyed/diamol/tree/master/ch02/lab">솔루션</a></p>
<p><strong>목표</strong>: 실행 중인 Apache 컨테이너에서 index.html을 변경하라.</p>
<p><strong>힌트</strong>:</p>
<ul>
<li><p>컨테이너는 독립된 파일 시스템을 가지며, 컨테이너 내의 웹 서버 또한 컨테이너의 파일 시스템의 파일을 제공한다.</p>
</li>
<li><p><code>docker container</code> 명령어를 통해 컨테이너에서 수행할 수 있는 명령어 목록을 볼 수 있다.</p>
</li>
<li><p><code>docker &#123;command&#125; --help</code>를 통해 해당 명령어의 상세 설명을 확인할 수 있다.</p>
</li>
<li><p><code>diamol/ch02-hello-diamol-web</code> 이미지는 <code>/usr/local/apache2/htdocs</code> 폴더 내의 파일을 정적으로 제공한다. (윈도우의 경우, <code>C:\user\local\apache2\htdocs</code> 폴더.)</p>
</li>
</ul>
<hr>
<h3 id="내-풀이"><a href="#내-풀이" class="headerlink" title="내 풀이"></a>내 풀이</h3><p>풀이 과정을 서술함.</p>
<p><strong>1. 제공된 컨테이너 트러블 슈팅</strong>: 일단 <code>ch02-hello-diamol-web</code> 의 기본 포트인 8088은 접속할 수가 없었다. 그래서 DockerHub 가서 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/httpd">Apache 이미지</a>를 받아서 실행해봤다. 8080 포트로 잘 되더라. 이 때 명령어가 <code>$ docker run -dit --name my-apache-app -p 8080:80 -v &quot;$PWD&quot;:/usr/local/apache2/htdocs/ httpd:2.4</code> 였는데, 배운 점:</p>
<ul>
<li><code>-dit</code>: <code>--detach --interactive</code>의 약자인데, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41916435/practically-what-is-the-difference-between-docker-run-dit-itd-vs-docker-run">-dit가 필요한 이유</a>를 보면, bash 스크립트가 엔트리 포인트인 경우 <code>-d</code>만 하면 정지된 상태에서 아무것도 못한다고 한다. <code>-it</code>를 줘서 셸이 있어야 스크립트가 실행된다고 한다.</li>
<li><code>-p</code>: <code>--publish</code>의 약자이다.</li>
<li><code>-v</code>: 아직 안 배웠지만, 볼륨 개념일 것으로 추정된다.</li>
</ul>
<p>도커 자체의 네트워크 문제가 아님을 알고, 80으로 하니까 잘 됐는데, 이유는 모르겠다.</p>
<p><strong>2. 컨테이너 셸 접속</strong>: 일단 <code>docker container exec -it --tty &#123;id&#125; /bin/bash</code> 로 접속할 순 있었다. (나오는건 exit 치면 된다.)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22272401/what-does-it-mean-to-attach-a-tty-std-in-out-to-dockers-or-lxc"><code>--tty</code> 옵션에 대한 글</a> 참고</li>
</ul>
<p><strong>3. 직접 파일 수정</strong>: 무슨 망할 기반 이미지를 쓰는지 vi 밖에 지원을 하지 않아서 직접 수정은 포기했다. 파일을 복사해야 하는데, 어떻게 하는지 모르겠다.</p>
<p><strong>4. 파일 복사 방법</strong>: Dockerfile을 수정하는 게 가장 쉬울 것 같았지만, 제공되지 않아서 할 수 없었다. 복사를 해야 하는데, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22907231/how-to-copy-files-from-host-to-docker-container">호스트에서 컨테이너로 파일 복사하기</a>로 <code>docker cp</code> 명령어를 배워서 수행했고, 성공했다.</p>
<hr>
<p>매우 작은 작업이었지만 너무 오랜 기간이 걸렸다. 아무래도 기록하면서 하니까 오래 걸리고, 책의 내용을 요약했음에도 불구하고 며칠만에 다시 보는거여서 오래 걸렸다.</p>
<p>많이 헤맨 덕분에, <code>docker container ls</code>, <code>docker container rm</code>, <code>docker container exec</code>, <code>docker container run</code>은 정말 많이 사용해서 다행이다.</p>
<hr>
<p>참고 자료: Docker In A Month of Lunches (Manning, 2020)</p>
<hr>
<p>추가로 읽을 것: <a target="_blank" rel="noopener" href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">Docker와 VM</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-01T06:30:00.000Z" title="2021-01-01T06:30:00.000Z">21-01-01</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">10분안에 읽기 (약 1450 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-2-module/">2장 (2/3): Node.js의 모듈 시스템</a></h1><div class="content"><p>이 글은 Node.js의 모듈 시스템에 대해 소개한다.</p>
<hr>
<h3 id="1-모듈-시스템의-필요성과-Javascript의-방식"><a href="#1-모듈-시스템의-필요성과-Javascript의-방식" class="headerlink" title="1. 모듈 시스템의 필요성과 Javascript의 방식"></a>1. 모듈 시스템의 필요성과 Javascript의 방식</h3><p>모듈 시스템은 프로그램의 구성 요소들 간의 역할을 분리하고, 의존 관계와 구현 상세를 격리하는데 필수적이다. 모듈 시스템의 문법으로 보면, 소스 파일간의 import, export를 하는 것인데, 개념 상 Java의 접근 제한자 - <code>private, protected, public</code> - 도 모듈의 역할 중 일부를 수행 한다고 할 수 있다.</p>
<p>Javascript 모듈 시스템으로는 대표적으로 ESM, CommonJs 라는 두 개의 기술이 있는데, 현재의 Node.js는 ESM, CommonJs를 모두 지원한다.</p>
<table>
<thead>
<tr>
<th align="center">종류</th>
<th align="center">ESM</th>
<th align="center">CommonJS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">제정 시기</td>
<td align="center">ES6에 제정됨</td>
<td align="center">ESM 이전의 대표적인 비표준</td>
</tr>
<tr>
<td align="center">문법(Node 기준)</td>
<td align="center"><code>import / export</code></td>
<td align="center"><code>require / module.export</code></td>
</tr>
<tr>
<td align="center">Node.js 지원 여부</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">Browser 지원 여부</td>
<td align="center">최신 브라우저에서 지원</td>
<td align="center">CommonJs.js 로딩 필요</td>
</tr>
</tbody></table>
<p>자세한 역사와 기타 모듈 시스템의 종류는 <a target="_blank" rel="noopener" href="https://d2.naver.com/helloworld/12864">JavaScript 표준을 위한 움직임: CommonJS와 AMD | Naver D2</a>를 참고.</p>
<hr>
<h3 id="2-Revealing-Module-Pattern"><a href="#2-Revealing-Module-Pattern" class="headerlink" title="2. Revealing Module Pattern"></a>2. Revealing Module Pattern</h3><p>Javascript에는 접근 제한자가 없다. 접근을 원천적으로 제한하는 방법 중, 공개할 부분만 객체로 담아 내보내는 패턴이 있다. Private 변수는 클로저를 통해 접근할 수 있으므로, 꽤 괜찮은 방법이다.</p>
<p>Revealing Module 패턴을 구현하는 방법은 대표적으로 <code>IIFE</code>(즉시 실행 함수 표현식)가 있다. IIFE는 익명 함수를 ()로 감싼 후 즉시 실행하는 함수 호출 방식이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> privateFoo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* private functionality */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> privateCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increase = <span class="function">() =&gt;</span> ++privateCounter;</span><br><span class="line">  <span class="keyword">const</span> decrease = <span class="function">() =&gt;</span> --privateCounter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이 객체를 반환하므로, 외부에선 privateFoo, Bar에 접근할 수 없다.</span></span><br><span class="line">  <span class="keyword">return</span> &#123; increase, decrease &#125;;</span><br><span class="line">&#125;)(); <span class="comment">// 즉시 실행하여, &#123; increase, decrease &#125; 객체가 반환된다.</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-CommonJs의-require-방식에-대해"><a href="#3-CommonJs의-require-방식에-대해" class="headerlink" title="3. CommonJs의 require 방식에 대해"></a>3. CommonJs의 require 방식에 대해</h3><p>CommonJs는 <code>const moduleA = require(&#39;./moduleA&#39;);</code>와 같이 모듈을 로딩하는 문법을 제공한다. <code>require</code>는 <strong>동기로</strong> 작동하고, 한 번 로딩한 모듈은 캐시된다. 내보낼 때에는 각 모듈별로 제공되는 <code>exports</code> 객체에 필드를 할당하는 방식으로 진행한다.</p>
<p>모듈은 캐싱되므로 항상 동일한 객체를 반환한다.</p>
<p>아래는 <code>require</code>의 수도 코드이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="function">(<span class="params">modulePath</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// path를 가져오고, unique한 id로 활용한다.</span></span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">require</span>.resolveAbsolutePath(</span><br><span class="line">    modulePath,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 캐시된 모듈은 캐시를 반환한다.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">require</span>.cache[id])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>.cache[id].exports;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 처음 로딩하는 경우 새 exports 객체가 필요하다.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">    id,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 객체는 캐시한다.</span></span><br><span class="line">  <span class="built_in">require</span>.cache[id] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이 함수가 소스 코드를 읽어 exports 객체에 export 내용들을 할당한다.</span></span><br><span class="line">  readFileAndEvaluate(id, <span class="built_in">module</span>, <span class="built_in">require</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.cache = &#123;&#125;;</span><br><span class="line"><span class="built_in">require</span>.resolveAbsolutePath = <span class="function">(<span class="params">modulePath</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* implementation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>어느 범위까지 같은 인스턴스가 반환될까?</strong></p>
<ol>
<li><p>같은 패키지로 빌드된다면 하나의 인스턴스를 공유할 것이다.</p>
</li>
<li><p><code>package.json</code>별로 독립적으로 dependency를 관리하기 때문에, 각 패키지간에 제 3의 모듈의 객체를 주고 받는 경우, 해당 객체는 버전 불일치가 있을 수 있다.</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://medium.com/learnwithrahul/understanding-npm-dependency-resolution-84a24180901b">A Simple Explanation | Medium (EN)</a></p>
<hr>
<h3 id="4-비동기-모듈-초기화"><a href="#4-비동기-모듈-초기화" class="headerlink" title="4. 비동기 모듈 초기화"></a>4. 비동기 모듈 초기화</h3><p>비동기로 객체를 초기화할 순 없다. require 함수가 동기로 작동하기 때문인데, 아무래도 <code>initialize</code>와 같은 메소드를 호출하는 형태로 비동기 API를 만들어서 활용하는 수 밖에 없을 듯하다.</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/29490138/nodejs-async-module-initialization-code">관련 스택 오버 플로우</a> 참고.</p>
<hr>
<h3 id="5-순환-참조가-있는-경우"><a href="#5-순환-참조가-있는-경우" class="headerlink" title="5. 순환 참조가 있는 경우"></a>5. 순환 참조가 있는 경우</h3><p>Node.js 환경에서 순환 참조를 하는 경우 한 모듈이 먼저 로딩되기 때문에, 동기로 로딩하는 경우, 한 쪽에서는 null, 한 쪽에서는 정상 로딩이 될 수 밖에 없다. 아니면 명확한 순서를 지정해준다면 해결할 수도 있겠지만(A[A.B = null]-&gt;B[B.A = A]-&gt;[A.B = B]), 순서를 명시하는 API가 따로 있는지 잘 모르겠다.</p>
<ol>
<li><p>한 쪽에서 느린 초기화를 진행한다. (Lazy-Init) - 순서 정하기와 사실상 동일함.</p>
</li>
<li><p>순환 참조 관계에 있는 두 객체를 제 3의 객체에 의존하도록 한다. <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1450997/resolving-circular-dependencies-with-dependency-injection">관련 스택 오버 플로우</a> - 이 부분은 잘 이해하지 못 했다.</p>
</li>
</ol>
<hr>
<h3 id="어떻게-export-해야-좋은-모듈일까"><a href="#어떻게-export-해야-좋은-모듈일까" class="headerlink" title="어떻게 export 해야 좋은 모듈일까?"></a>어떻게 export 해야 좋은 모듈일까?</h3><h4 id="1-Substack-패턴"><a href="#1-Substack-패턴" class="headerlink" title="1. Substack 패턴"></a>1. Substack 패턴</h4><p>모듈의 기능을 객체가 아닌 함수 단위로 노출한다. 진입점이자 주가 되는 함수를 <code>module.exports</code>로 내보내는데, 따라서 <code>const logger = require(&#39;./logger&#39;)</code>와 같이 바로 사용할 수 있는 함수가 된다. 또한, <code>logger.verbose(msg);</code> 와 같이 서브 함수들도 내보내, 사용하는 입장에서 기능의 중요도를 쉽게 파악할 수 있게 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = mainFn;</span><br><span class="line"><span class="built_in">exports</span>.subFn1 = subFn1;</span><br><span class="line"><span class="comment">// 2...N-1</span></span><br><span class="line"><span class="built_in">exports</span>.subFnN = subFnN;</span><br></pre></td></tr></table></figure>
<p>(ex)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 메인 함수</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">msg</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 서브 함수 1</span></span><br><span class="line"><span class="built_in">exports</span>.verbose = <span class="function">(<span class="params">msg</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[verbose] <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-생성자-내보내기"><a href="#2-생성자-내보내기" class="headerlink" title="2. 생성자 내보내기"></a>2. 생성자 내보내기</h4><p>prototype 기반으로 생성자를 만들거나, ES6 Class를 활용하여 생성자를 만들어, 생성자를 내보낸다. 사용하는 입장에선 객체의 기능을 확장할 수도 있고, 쉽게 인스턴스를 생성할 수도 있고, 사용하기도 깔끔한 방법이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">log</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">verbose</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`[verbose] <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-인스턴스-내보내기"><a href="#3-인스턴스-내보내기" class="headerlink" title="3. 인스턴스 내보내기"></a>3. 인스턴스 내보내기</h4><p>생성자 내보내기와 거의 같지만, 싱글톤이 자동으로 구현되는 셈이므로 쉽게 활용하기 좋다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">log</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">verbose</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`[verbose] <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Logger(<span class="string">&#x27;App&#x27;</span>);</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-01T02:00:00.000Z" title="2021-01-01T02:00:00.000Z">21-01-01</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">5분안에 읽기 (약 776 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-2-cps/">2장 (1/3): CPS 패턴</a></h1><div class="content"><p>이 글은 CPS 패턴과 CPS가 Node.js에서 어떻게 사용되고, 어떤 점을 주의해야 하는지 다룬다.</p>
<hr>
<h3 id="1-CPS-패턴"><a href="#1-CPS-패턴" class="headerlink" title="1. CPS 패턴"></a>1. CPS 패턴</h3><p>Node.js는 1장에서 살펴봤듯 비동기 특성을 가지며, 따라서 Node.js 앱은 대부분의 일을 비동기로 처리할 수 밖에 없다. 비동기를 처리하는 방법 중 CPS, Continous Passing Style을 소개한다.</p>
<p>CPS: 비동기 API를 사용할 때, 콜백 함수를 인자로 넘기는 패턴이다.</p>
<ul>
<li><strong>왜 사용하는가</strong>: 비동기 API는 return을 할 수 없는데, 함수의 실행이 끝나기 전에 제어권이 넘어가기 때문이다. 이를 해결하기 위해선 결과를 다른 함수에 넘기면 된다.</li>
<li><strong>장점</strong>: 간단하고 효과적이다.</li>
<li><strong>단점</strong>: 호출 깊이가 깊어지면 가독성이 감소된다. Callback Hell이라고 불린다.</li>
</ul>
<hr>
<h3 id="2-Node-js에서의-CPS-패턴"><a href="#2-Node-js에서의-CPS-패턴" class="headerlink" title="2. Node.js에서의 CPS 패턴"></a>2. Node.js에서의 CPS 패턴</h3><p>Node.js는 CPS 패턴을 사용할 때 일관된 규칙을 따라야 한다.</p>
<ul>
<li>argument 순서에 관한 규칙: <code>(...params, callback)</code> 과 같이, callback 함수를 마지막 인자로 넘겨야 한다.</li>
<li>callback 함수의 argument에 관한 규칙: <code>(err, ...args)</code> 와 같이, err가 첫 인자여야 한다.</li>
<li><code>err</code> 인자의 경우, 항상 <code>Error()</code> 객체여야 한다. <strong>(이 부분은 잘 지켜지지 않는 듯 하다.)</strong></li>
</ul>
<hr>
<h3 id="3-CPS-패턴의-콜-스택"><a href="#3-CPS-패턴의-콜-스택" class="headerlink" title="3. CPS 패턴의 콜 스택"></a>3. CPS 패턴의 콜 스택</h3><p>Node.js에서 비동기 API를 호출하는 경우, callback 함수는 프로그래머가 예상한 호출 순서로 구성된 스택을 갖지 않는다. 비동기 API가 완료됐을 때, 이벤트 루프에 의해 단일 함수로 Queue에 쌓인 후 다른 타이밍에 실행되기 때문에 새로운 스택에서 실행된다. 비동기 함수에서 예외를 던지면, <code>Error</code>를 반환하며 프로세스가 종료된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readJsonThrows = <span class="function">(<span class="params">filename, cb</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);</span><br><span class="line">      cb(<span class="literal">null</span>, <span class="built_in">JSON</span>.parse(data));</span><br><span class="line">      <span class="comment">// cb이 없거나, data가 불량인 경우 exception 발생 가능.</span></span><br><span class="line">      <span class="comment">// 콜백 함수 내에서 try-catch하지 않는 경우 프로세스가 죽는다.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 여기서도 catch할 수 없음. 호출 스택은 fs.readFile에서 끝나고,</span></span><br><span class="line">    <span class="comment">// cb은 별개의 새 스택에서 실행되기 때문</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 JSON.parse에서 오류나는 경우, 프로세스가 종료된다.</span></span><br><span class="line">readJsonThrows(<span class="string">&#x27;C./test.json&#x27;</span>, <span class="function">(<span class="params">f</span>) =&gt;</span> f);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">SyntaxError: Unexcepted end of JSON input</span></span><br><span class="line"><span class="comment">    at JSON.parse</span></span><br><span class="line"><span class="comment">    at FSReqCallback.readFileAfterClose (internal/...)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-Node-js에서-비동기를-처리할-때-절대-하지-말아야-할-점들"><a href="#4-Node-js에서-비동기를-처리할-때-절대-하지-말아야-할-점들" class="headerlink" title="4. Node.js에서 비동기를 처리할 때 절대 하지 말아야 할 점들"></a>4. Node.js에서 비동기를 처리할 때 절대 하지 말아야 할 점들</h3><h4 id="1-결괏값을-동기-비동기-2가지-방식으로-전달하지-않는다"><a href="#1-결괏값을-동기-비동기-2가지-방식으로-전달하지-않는다" class="headerlink" title="1. 결괏값을 동기, 비동기 2가지 방식으로 전달하지 않는다."></a>1. 결괏값을 동기, 비동기 2가지 방식으로 전달하지 않는다.</h4><ul>
<li><p>결괏값이 비동기일것을 기대하고 이벤트 리스너를 등록할 때, 동기로 결괏값이 제공되는 경우 이벤트 리스너가 동작하지 않는다.</p>
</li>
<li><p>동기 반환값을 비동기화 한다. <code>setTimeout, setImmediate, nextTick, Promise</code> 등이 가능하다.</p>
</li>
</ul>
<h4 id="2-Callback-함수를-argument로-받는-동기-함수를-작성하지-않는다"><a href="#2-Callback-함수를-argument로-받는-동기-함수를-작성하지-않는다" class="headerlink" title="2. Callback 함수를 argument로 받는 동기 함수를 작성하지 않는다."></a>2. Callback 함수를 argument로 받는 동기 함수를 작성하지 않는다.</h4><ul>
<li>동기 API는 바로 결괏값을 받는 형태로 코드를 작성하면 된다.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-12-27T03:13:00.000Z" title="2020-12-27T03:13:00.000Z">20-12-27</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">9분안에 읽기 (약 1360 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-1-reactor-pattern/">1장: Reactor 패턴 (내용 검증 필요)</a></h1><div class="content"><p>1장은 Node.js에 대한 소개하는 챕터이다.</p>
<hr>
<p>주의!<br>해당 글의 내용은 부정확한 내용이 아주 많을 수 있습니다. 책의 설명이 추상적이고 OS 개념이 많이 필요하므로 추후 정리가 완료되는 경우 따로 표시하겠습니다.</p>
<hr>
<h3 id="Node-js-철학-Node-Way"><a href="#Node-js-철학-Node-Way" class="headerlink" title="Node.js 철학 (Node Way)"></a>Node.js 철학 (Node Way)</h3><p>최소 기능: 기능 개수를 최소한되므로, 개발자, 사용자 모두에게 간단함</p>
<ol>
<li> Node.js 자체 뿐만 아니라 node 기반 모듈을 설계할 때도 동일하게 적용</li>
<li> KISS 원칙: 부족하더라도 복잡함보다 단순함이 더 낫다</li>
</ol>
<hr>
<h3 id="Reactor-패턴과-Node-js-이벤트-루프"><a href="#Reactor-패턴과-Node-js-이벤트-루프" class="headerlink" title="Reactor 패턴과 Node.js 이벤트 루프"></a>Reactor 패턴과 Node.js 이벤트 루프</h3><p><strong>Reactor 패턴</strong>은 Node.js의 비동기 특성 - Node.js에서 여러 요청이 동시에 있는 경우는 항상 비동기 방식으로 작업을 처리한다 - 의 원인이자, 비동기 방식으로 작업을 처리하는 방법에 해당한다. Reactor 패턴을 배우기 전에, 동시성을 처리하는 2가지 방법에 대해서 알아보자.</p>
<p><strong>Blocking I/O</strong> : <u>느린 I/O</u>를 <u>기다리는</u> 방식</p>
<ol>
<li><p><strong>많은 스레드 개수</strong>: 소켓의 데이터를 매번 기다리게 되면 각 연결 별로 스레드가 적어도 하나씩 돌아야 한다. 기다리는 시간에 타 사용자가 기다리지 않게 하기 위해서이다.</p>
</li>
<li><p><strong>비효율적인 대기 시간</strong>: I/O가 CPU에 비해 매우 느리기 때문에 블로킹 API는 스레드의 유휴 시간이 처리 시간에 비해 압도적으로 길 수 밖에 없다. 스레드가 아무 일을 하지 않은 상태로 긴 시간 존재한다.</p>
</li>
<li><p><strong>스레드의 비용</strong>: 스레드는 그 비용이 싸지 않다. 아주 많은 스레드가 있는 경우, Context Switching만 해도 비용이 매우 클 것이고, 적은 스레드가 있는 경우 사용자를 처리하지 못하므로 비즈니스적으로 비용이 매우 클 것이다.</p>
</li>
</ol>
<p><strong>Non-blocking I/O</strong>: 비동기 API를 호출 시 바로 제어권을 반환(내부적으로 특정 상수를 반환)하여 CPU 유휴 시간을 최소화한다.</p>
<ol>
<li><p><strong>Polling</strong>: 비효율적으로 I/O를 처리하는 방식으로, 리소스는 데이터가 없을 때 읽기 조작을 요청 받는 경우 <code>EAGAIN</code>을 반환하는데, 이 때문에 값이 필요한 입장에선 리소스를 계속 확인해야 한다. 이걸 <code>BUSY_WAITING</code>이라고 하는데, CPU를 계속 활용하므로 효율적이지 못하다.</p>
</li>
<li><p><strong>동기 이벤트 디멀티플렉서</strong>: 논블로킹을 처리하는 효율적인 방법으로, 이벤트가 완료될 때마다 큐에 이벤트를 쌓아놓고 처리를 수행하는 객체. 이벤트가 없으면 Block 상태로 대기한다.</p>
<ol>
<li><p><strong>이벤트 통지자</strong>가 감시 대상 리소스의 자원이 읽기가 가능할 때(즉, 이벤트가 완료되었을 때) Demultiplexer에게 통지한다. (이벤트 통지자 역할로 IOCP, epoll/kqueue 등이 있는 것 같다.)</p>
</li>
<li><p>Event가 발생하면 <strong>Event Demultiplexer</strong>가 깨어나 Queue에서 이벤트를 읽어들여 처리하면 됨. 이 시점에서 리소스의 I/O 작업은 (1)에서 이미 완료되어있으므로 동기식으로 처리하면 됨. 또한 처리 방식이 싱글 스레드이므로 공유 자원 문제도 존재하지 않는다.</p>
</li>
</ol>
</li>
</ol>
<p><strong>리액터 패턴</strong>: 이벤트 디멀티플렉서 + 이벤트 루프 + 이벤트 큐 + 실행 환경(<code>V8, 싱글 스레드!</code>)</p>
<ol>
<li><p>이벤트 디멀티플렉서는 I/O 처리가 끝나면 (완료된) 이벤트를 이벤트 큐에 넣어줌</p>
</li>
<li><p>이벤트 루프는 실행 환경 상에서 스택이 비는 경우(즉 모든 동기 코드가 실행이 끝났을 때 - 노드 환경에서 동기 코드는 얼마 없어서 최초의 동기 코드는 금방 끝나기 마련.), 이벤트 큐에서 이벤트를 꺼내어 실행 환경에 이벤트 핸들러를 올리고, 인자로 이벤트를 넘겨 수행함.</p>
<ol>
<li>만약 async 내에 async가 있다면 해당 이벤트는 또 이 과정을 거침.</li>
</ol>
</li>
</ol>
<p><strong>이벤트 디멀티플렉서의 구현체</strong></p>
<p><strong>libuv</strong>: 크로스 플랫폼으로(가상머신 느낌으로 각 OS에 대응되는 이벤트 통지자를 활용) 비동기 작업을 처리함. 단, libuv는 이벤트 디멀티플렉서 역할만 하는 게 아니라 이벤트 루프도 구현함.</p>
<p>참고: libuv에 이벤트루프가 포함돼있음: <img src="/images/libuv_arch.png"></p>
<p><strong>더 정확한 이벤트 디멀티플렉서, 이벤트 루프 구현 상세에 관한 글, 영상</strong></p>
<p><a target="_blank" rel="noopener" href="https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/">로우 레벨로 살펴보는 Node.js 이벤트 루프 | Evans Library</a></p>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/">Node.js 이벤트 루프, 타이머, <code>process.nextTick()</code> | Node.js</a> (놀랍게도 이 문서가 더 어려운 것 같다…)</p>
<p>브라우저 환경에서의 이벤트 루프(자막 있음, 자세함!):<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=cCOL7MC4Pl0&ab_channel=JSConf">Jake Archibald: In The Loop | JSConf.Asia</a></p>
<p>아마도 이벤트 루프에 대한 가장 유명하고, 쉬운 설명:<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&ab_channel=JSConf">What the heck is the event loop anyway? | JSConf EU</a></p>
<hr>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-10T11:00:00.000Z" title="2019-09-10T11:00:00.000Z">19-09-10</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">함수형 자바스크립트</a></span><span class="level-item">8분안에 읽기 (약 1135 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/fjs-5-composition/">함수형 패러다임의 꽃: 함수 합성(composition)</a></h1><div class="content"><p>함수형 패러다임에서 최우선 설계 원칙으로 삼아진다고 하는 <strong>함수들의 합성</strong>에 대해서 설명한다.</p>
<h3 id="합성"><a href="#합성" class="headerlink" title="합성"></a>합성</h3><p>이전에 설명했던 <code>compose</code> 함수를 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span></span><br><span class="line">  fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    f(g(...args)),</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<h3 id="합성은-왜-하는걸까"><a href="#합성은-왜-하는걸까" class="headerlink" title="합성은 왜 하는걸까?"></a>합성은 왜 하는걸까?</h3><p>프로그램을 간결하고 실용적으로 작성할 수 있게 한다. 합성이 되므로 함수를 부담 없이 나눌 수 있게 되어 더 작고 의미있는 단위의 함수를 더 편하게 작성할 수 있다. 이렇게 합성된 함수는 가독성이 좋다. 아무래도 객체지향 패러다임을 강하게 지원하는 언어들에선 함수 합성이 쉽지 않다. 애초에 순수 함수를 작성하기도 쉽지 않다. <code>public static</code>으로 도배할 순 없기 때문이다.</p>
<h3 id="합성함수의-결합법칙"><a href="#합성함수의-결합법칙" class="headerlink" title="합성함수의 결합법칙"></a>합성함수의 결합법칙</h3><p>함수 합성은 <code>수학에서의 합성함수</code>와 같이 결합법칙이 성립한다. <code>compose(f, compose(g, h)) === compose(compose(f, g), h)</code>가 성립한다. Javascript 상에서 생성되는 함수가 동일하다는 것이 아니라, 그 실행 결과가 언제나 같다는 뜻이다.</p>
<h3 id="결합법칙이-무슨-소용일까"><a href="#결합법칙이-무슨-소용일까" class="headerlink" title="결합법칙이 무슨 소용일까"></a>결합법칙이 무슨 소용일까</h3><p>합성한 함수들을 재귀적으로 합성한 경우, <code>결합법칙</code>을 적용하면 결과 예측과 리팩토링 시에 유용하다.</p>
<p>그 예로, 아래 세가지 <code>loudLastUpper</code> 함수는 동일하다. 더 작고 더 의미있는 함수로 정의할수록 재사용성과 가독성은 높아진다.</p>
<p>버전 1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loudLastUpper = compose(</span><br><span class="line">  exclaim,</span><br><span class="line">  toUpperCase,</span><br><span class="line">  head,</span><br><span class="line">  reverse,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>버전 2 (리팩토링)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> last = compose(head, reverse);</span><br><span class="line"><span class="keyword">const</span> loudLastUpper = compose(</span><br><span class="line">  exclaim,</span><br><span class="line">  toUpperCase,</span><br><span class="line">  last,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>버전 3 (리팩토링)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> last = compose(head, reverse);</span><br><span class="line"><span class="keyword">const</span> angry = compose(exclaim, toUpperCase);</span><br><span class="line"><span class="keyword">const</span> loudLastUpper = compose(angry, last);</span><br></pre></td></tr></table></figure>
<h3 id="쓸모있고-재미있는-디버깅-방법"><a href="#쓸모있고-재미있는-디버깅-방법" class="headerlink" title="쓸모있고 재미있는 디버깅 방법"></a>쓸모있고 재미있는 디버깅 방법</h3><p>합성 함수를 디버깅하는 재밌는 방법이 있다. 흔히 <code>trace</code>라 부르는 유명한 함수인데, 항등함수(<code>const pass = x =&gt; x;</code>)에 <code>console.log</code>만 추가한 함수이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trace = <span class="function">(<span class="params">tag</span>) =&gt;</span> <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tag, x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 자동 커리</span></span><br><span class="line"><span class="keyword">const</span> trace = curry(<span class="function">(<span class="params">tag, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tag, x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용 예시</span></span><br><span class="line"><span class="keyword">const</span> toDebug = compose(</span><br><span class="line">  replace,</span><br><span class="line">  trace(<span class="string">&#x27;after A&#x27;</span>),</span><br><span class="line">  applyA,</span><br><span class="line">  trace(<span class="string">&#x27;after B&#x27;</span>),</span><br><span class="line">  applyB,</span><br><span class="line">  trace(<span class="string">&#x27;after last&#x27;</span>),</span><br><span class="line">  last,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>당연하게도 <code>trace</code> 함수는 순수하지 않다. <code>console</code>를 사용하기 때문이다.</p>
<h2 id="간단한-함수-합성-예제"><a href="#간단한-함수-합성-예제" class="headerlink" title="간단한 함수 합성 예제"></a>간단한 함수 합성 예제</h2><p>이하의 예제 코드는 아래의 <code>cars</code> 객체를 대상으로 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;Aston Martin One-77&#x27;</span>,</span><br><span class="line">    horsepower: <span class="number">750</span>,</span><br><span class="line">    dollar_value: <span class="number">1850000</span>,</span><br><span class="line">    in_stock: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="예제-1"><a href="#예제-1" class="headerlink" title="예제 1"></a>예제 1</h3><p>각 함수들의 정의는 <a target="_blank" rel="noopener" href="https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/appendix_c.md">이 문서</a>를 참고하라. 이 문서는 <a target="_blank" rel="noopener" href="https://ramdajs.com/docs/">ramdajs documentation</a>과도 호환된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isLastInStock = <span class="function">(<span class="params">cars</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> lastCar = last(cars);</span><br><span class="line">  <span class="keyword">return</span> prop(<span class="string">&#x27;in_stock&#x27;</span>, lastCar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after compose:</span></span><br><span class="line"><span class="keyword">const</span> isLastInStock = compose(</span><br><span class="line">  prop(<span class="string">&#x27;in_stock&#x27;</span>),</span><br><span class="line">  last,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="예제-2"><a href="#예제-2" class="headerlink" title="예제 2"></a>예제 2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> average = <span class="function">(<span class="params">xs</span>) =&gt;</span></span><br><span class="line">  reduce(add, <span class="number">0</span>, xs) / xs.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> averageDollarValue = <span class="function">(<span class="params">cars</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dollarValues = map(</span><br><span class="line">    (c) =&gt; c.dollar_value,</span><br><span class="line">    cars,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> average(dollarValues);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after compose:</span></span><br><span class="line"><span class="keyword">const</span> averageDollarValue = compose(</span><br><span class="line">  average,</span><br><span class="line">  map(prop(<span class="string">&#x27;dollar_value&#x27;</span>)),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="예제-3"><a href="#예제-3" class="headerlink" title="예제 3"></a>예제 3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fastestCar = <span class="function">(<span class="params">cars</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sorted = sortBy(<span class="function">(<span class="params">car</span>) =&gt;</span> car.horsepower);</span><br><span class="line">  <span class="keyword">const</span> fastest = last(sorted);</span><br><span class="line">  <span class="keyword">return</span> concat(fastest.name, <span class="string">&#x27; is the fastest&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after compose:</span></span><br><span class="line"><span class="keyword">const</span> fastestCar = compose(</span><br><span class="line">  append(<span class="string">&#x27; is the fastest&#x27;</span>),</span><br><span class="line">  prop(<span class="string">&#x27;name&#x27;</span>),</span><br><span class="line">  last,</span><br><span class="line">  sortBy(prop(<span class="string">&#x27;horsepower&#x27;</span>)),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="함수-합성-예제-프로그램"><a href="#함수-합성-예제-프로그램" class="headerlink" title="함수 합성 예제 프로그램"></a>함수 합성 예제 프로그램</h2><h3 id="스펙"><a href="#스펙" class="headerlink" title="스펙"></a>스펙</h3><ol>
<li><p>검색어에 대응하는 URL을 생성한다.</p>
</li>
<li><p>flicker API를 호출한다.</p>
</li>
<li><p>결과 JSON에서 이미지 링크를 추출한다.</p>
</li>
<li><p>이미지를 HTML에 표시한다.</p>
</li>
</ol>
<h3 id="구현-코드"><a href="#구현-코드" class="headerlink" title="구현 코드"></a>구현 코드</h3><p>예제의 스펙에서 보았듯, 2단계 API 호출과 4단계 이미지 표시는 순수하지 않다. 일단 순수하지 않은 함수를 같이 사용하면서 예제를 구현한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 유틸 함수 선언</span></span><br><span class="line"><span class="keyword">const</span> prop = curry(<span class="function">(<span class="params">p, obj</span>) =&gt;</span> obj[p]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 순수하지 않은 함수</span></span><br><span class="line"><span class="comment">// Impure 객체로 접근하도록 하여 사용자에게 주의를 준다.</span></span><br><span class="line"><span class="keyword">const</span> Impure = &#123;</span><br><span class="line">  getJSON: curry(<span class="function">(<span class="params">callback, url</span>) =&gt;</span></span><br><span class="line">    $.getJSON(url, callback),</span><br><span class="line">  ),</span><br><span class="line">  setHtml: curry(<span class="function">(<span class="params">sel, html</span>) =&gt;</span></span><br><span class="line">    $(sel).html(html),</span><br><span class="line">  ),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  참고: 서버의 응답이 아래와 같은 형태로 구성됨</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    items: [</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        media: &#123;</span></span><br><span class="line"><span class="comment">          m: &#x27;&lt;image-link&gt;&#x27;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      &#123; ... &#125;,</span></span><br><span class="line"><span class="comment">      &#123; ... &#125;,</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&#x27;api.flicker.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;/services/feeds/photos-public.gne&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> query = <span class="function">(<span class="params">t</span>) =&gt;</span></span><br><span class="line">  <span class="string">`?tags=<span class="subst">$&#123;t&#125;</span>&amp;format=json&amp;jsoncallback=?`</span>;</span><br><span class="line"><span class="keyword">const</span> url = <span class="function">(<span class="params">t</span>) =&gt;</span></span><br><span class="line">  <span class="string">`https://<span class="subst">$&#123;host&#125;</span><span class="subst">$&#123;path&#125;</span><span class="subst">$&#123;query(t)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mediaUrl = compose(</span><br><span class="line">  prop(<span class="string">&#x27;m&#x27;</span>),</span><br><span class="line">  prop(<span class="string">&#x27;media&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mediaUrls = compose(</span><br><span class="line">  map(mediaUrl),</span><br><span class="line">  prop(<span class="string">&#x27;items&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="function">(<span class="params">src</span>) =&gt;</span> <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;src&#125;</span>&quot; /&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = compose(</span><br><span class="line">  Impure.setHtml(<span class="string">&#x27;#root&#x27;</span>),</span><br><span class="line">  map(img),</span><br><span class="line">  mediaUrls,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = compose(Impure.getJSON(render), url);</span><br><span class="line"></span><br><span class="line">app(<span class="string">&#x27;cat&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="compose와-map-리팩토링"><a href="#compose와-map-리팩토링" class="headerlink" title="compose와 map 리팩토링"></a>compose와 map 리팩토링</h3><p>아주 간단한 리팩토링이다. 같은 배열에 대해 <code>map</code>을 여러 번 실행하기보다, 순서를 유지한 채로 매 원소에 대해 <code>map</code>할 함수를 합성해서 한 번에 실행하게 되면 반복 횟수를 줄일 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line">compose(map(img), map(mediaUrl));</span><br><span class="line"><span class="comment">// to</span></span><br><span class="line">compose(map(compose(img, mediaUrl)));</span><br></pre></td></tr></table></figure>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p><a target="_blank" rel="noopener" href="https://github.com/MostlyAdequate/mostly-adequate-guide">mostly-adequate-guide (EN)</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-06T14:00:00.000Z" title="2019-09-06T14:00:00.000Z">19-09-06</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">함수형 자바스크립트</a></span><span class="level-item">12분안에 읽기 (약 1871 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/fjs-4-pure-functions-and-curry/">순수함수와 curry 함수</a></h1><div class="content"><p>이번 글은 쉽다(?). 순수함수에 대해 이론적으로 다루고, curry 함수를 소개한다. 다만 객체지향과의 비교, 테스트와 설계에 대한 내 생각을 공유하므로 지식이 없으면 어렵게 보일 수도 있다.</p>
<h3 id="순수함수"><a href="#순수함수" class="headerlink" title="순수함수?"></a>순수함수?</h3><p>순수함수는 수학에서 정의하는 함수와 동일하다. 입력에 대한 출력이 항상 동일하고, 입력에 대한 출력이 항상 1가지이다. 이게 가능하기 위해선 <code>DB</code>, <code>HTTP</code>, <code>현재 시간</code> 등에 의존하면 안 된다! <strong>함수 외부의 것</strong>과 함수 내용이 전혀 연관이 없어야 한다.</p>
<h3 id="부원인과-부작용"><a href="#부원인과-부작용" class="headerlink" title="부원인과 부작용"></a>부원인과 부작용</h3><p>영어권에서 흔히 <code>side-effects</code>라고 얘기하는 <code>부수효과</code>나 <code>부작용</code>은 함수 밖의 코드의 상태에 영향을 주는 일을 말한다. 부수효과를 크게 <strong>부작용</strong>과 <strong>부원인</strong>으로 구분할 수 있다. 부작용은 <strong>숨겨진 출력</strong>이고, 부원인은 <strong>숨겨진 입력</strong>이라고 생각하면 된다. 왜 외부의 상태와 상호작용하면 안 될까? 궁금하면 계속 읽어야 된다.</p>
<h3 id="숨겨진-입력"><a href="#숨겨진-입력" class="headerlink" title="숨겨진 입력"></a>숨겨진 입력</h3><p>숨겨진 입력이라고 하면 뭐가 있을까? Javascript와 같이 객체지향 패러다임을 지원하는 언어의 경우는 <code>this</code>가 항상 함수에 전달된다. <code>this</code>도 숨겨진 입력이다. 또한 함수 내부에서 <code>new Date()</code> 등의 코드로 <code>현재 시간</code>에 의존하는 경우도 숨겨진 입력이라고 할 수 있다. 둘 모두 외부의 상태를 변경하기 때문이다.</p>
<h3 id="숨겨진-출력"><a href="#숨겨진-출력" class="headerlink" title="숨겨진 출력"></a>숨겨진 출력</h3><p>숨겨진 출력은 함수를 실행했을 때 바뀌는 모든 것이라고 할 수 있다. 순수함수 내에서는 어떤 외부의 상태도 변할 수 없으므로, 어떤 외부의 상태가 조금이라도 변경된다면 그 함수는 순수하다고 할 수 없다.</p>
<h3 id="부수효과는-복잡성-빙산"><a href="#부수효과는-복잡성-빙산" class="headerlink" title="부수효과는 복잡성 빙산"></a>부수효과는 복잡성 빙산</h3><p>왜 외부의 상태와 상호작용하면 <strong>안 될까</strong>?</p>
<p>순수함수가 아닌 함수의 <code>Signature</code>는 프로그래머가 읽더라도, 심지어 객체지향 언어의 설계 방식대로 설계했더라도 무슨 부수효과가 일어날지 알 수 없다.</p>
<p>캡슐화는 좋은 규칙이지만 그 구현 코드를 읽기 전까지 부수 효과를 <strong>정확히</strong> 알 순 없다.</p>
<p>부수효과가 왜 복잡성 빙산일까? 프로그래머가 예상한 <strong>그대로</strong> 동작하지 않는 경우 논리적 버그의 원인이 되기 때문이다. 부수 효과는 해당 코드 혹은 해당 코드와 간접적으로 연관이 있는 코드를 수정했을 때 바뀌기 또한 쉽고, 바뀌었을 때 작동하지 않게 될 확률도 높다. 그래서 객체지향 방식으로 설계를 하는 경우 회귀테스트를 그렇게 많이 작성해야 하나 보다. 응집성과 캡슐화를 생각해서 상태 의존적이고, 변경 시 서로의 영향을 받아서 깨지기 쉽기 때문이다.</p>
<p>그래서 함수형 패러다임에서는 공유 자체를 하지 않는 방향으로 설계하도록 지향한다. 그 결과가 <strong>순수함수</strong>이다.</p>
<h3 id="순수함수가-아니면-테스트하기-힘들다"><a href="#순수함수가-아니면-테스트하기-힘들다" class="headerlink" title="순수함수가 아니면 테스트하기 힘들다"></a>순수함수가 아니면 테스트하기 힘들다</h3><p>어떤 함수가 부수효과가 있는 경우 이미 그 함수는 다른 코드랑 최소한 1번은 엮여 있을 수 밖에 없다. 덕분에 그 함수를 테스트하기 위해서는 다른 코드까지 테스트할 수 밖에 없고, 이 과정에서 <code>Blackbox Testing</code>이 불가능해진다. 구현 상세에 외부 코드와의 연관이 존재하기 때문이다. 이 과정은 객체지향 언어로 작성한 경우 자주 발생하며 덕분에 <code>Mock</code>을 자주 사용하게 된다. 또한 테스트 자체도 구현 상세의 변경에 취약하게 된다.</p>
<h3 id="부수효과를-제거하기-제거했을-때의-장점"><a href="#부수효과를-제거하기-제거했을-때의-장점" class="headerlink" title="부수효과를 제거하기, 제거했을 때의 장점"></a>부수효과를 제거하기, 제거했을 때의 장점</h3><p>부수효과를 제거하려면 순수함수를 만들고 사용하면 된다.</p>
<p>모든 부작용, 부원인은 <strong>숨겨진</strong>것이기에 이를 <code>Signature</code>에 명시하면 된다. 이렇게 명시하는 것은 객체지향 언어에서는 응집성과 캡슐화를 위해 구현 상세로 분류하여 함수 안에 전부 집어넣는 등 지양하는 편이지만, 함수형 패러다임에서는 권장된다. 덕분에 덜 복잡해지고, 훨씬 테스트하기 쉬워지며, 추론이 훨씬 쉬워지기 때문이다.</p>
<h3 id="부수효과를-완전히-제거할-수는-없다"><a href="#부수효과를-완전히-제거할-수는-없다" class="headerlink" title="부수효과를 완전히 제거할 수는 없다."></a>부수효과를 완전히 제거할 수는 없다.</h3><p>아무래도 웹 등 실세계의 애플리케이션은 함수 내의 수식을 한 번 계산하고 종료하는 게 목적이 아니라, 부수효과로 불리는 것들 대부분을 사용하여 목적을 달성할 수 밖에 없다. 함수형 패러다임은 이런 한계를 인정하고, 가능한 모든 곳에서 부수효과를 제거하고, 제거할 수 없을 땐 강력히 통제한다.</p>
<h3 id="순수함수의-조합과-재사용성"><a href="#순수함수의-조합과-재사용성" class="headerlink" title="순수함수의 조합과 재사용성"></a>순수함수의 조합과 재사용성</h3><p>순수함수는 그 자체의 명료함 덕분에 재사용성과 조합이 굉장히 쉽고, 많이 조합하더라도 쉽게 그 결과가 예측 가능하다. 특히 한 번에 풀 수 없는 크고 복잡한 문제를 쪼개서 작은 함수의 조합으로 해결할 수 있다. 앞서 만들어 놓은 산출물을 쉽게 조합하여 새로운 문제를 해결할 수 있게 되고, 생산성도 비약적으로 늘어난다.</p>
<h3 id="순수함수에-대한-간단한-사실들"><a href="#순수함수에-대한-간단한-사실들" class="headerlink" title="순수함수에 대한 간단한 사실들"></a>순수함수에 대한 간단한 사실들</h3><ol>
<li><p>순수함수는 수학의 함수와 동일한 정의를 갖는다.</p>
</li>
<li><p>순수함수는 (input, output) 쌍이므로 객체로도 표현 가능하다. (<code>key,value 쌍</code>)</p>
</li>
<li><p>순수함수는 항상 캐시 가능하다.</p>
</li>
<li><p>순수함수는 필요한 건 다 전달받는다(<code>dependency injection</code>)</p>
</li>
<li><p>동시성 문제가 적거나 없다. 공유하는 메모리가 없기 때문이다.</p>
</li>
</ol>
<h3 id="curry-함수"><a href="#curry-함수" class="headerlink" title="curry 함수"></a>curry 함수</h3><p>2번째 글에서 currying을 이미 다루었다. 그 때의 currying은 프로그래머가 함수에 대해 직접 curry한 방식이고, 이번에는 어떤 함수에 대해 알아서 curry된 함수를 반환하는 함수를 소개한다.</p>
<p>curry 함수는 함수를 받아, 인자가 완전히 전달되지 않은 경우 남은 인자를 받을 함수를 반환한다. curry 함수의 구현은 <code>function.length</code>와 <code>bind</code>, <code>apply</code>를 사용하는 게 핵심이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = f.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">$curry</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; len) &#123;</span><br><span class="line">      <span class="comment">// 원래 함수의 매개변수의 갯수보다 $curry에 전달된 매개변수의 갯수가 작은 경우.</span></span><br><span class="line">      <span class="keyword">return</span> $curry.bind(<span class="literal">null</span>, ...arguments); <span class="comment">// $curry에 계속 전달받은 매개변수들이 bind 된다. (arguments가 계속 쌓인다.)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> f.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 실제 함수 호출.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예시</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c;</span><br><span class="line"><span class="keyword">const</span> addC = curry(add);</span><br><span class="line"><span class="keyword">const</span> add1 = addC(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> add1and2 = add1(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> add1and2and3 = add1and2(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(addC(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// function $curry</span></span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">2</span>)); <span class="comment">// function $curry</span></span><br><span class="line"><span class="built_in">console</span>.log(add1and2and3); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add1and2(<span class="number">3</span>) === add1and2and3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">ES6 bind 함수 (KO)</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-04T11:00:00.000Z" title="2019-09-04T11:00:00.000Z">19-09-04</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">함수형 자바스크립트</a></span><span class="level-item">6분안에 읽기 (약 847 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/fjs-3-functional-js-basics/">함수형 자바스크립트 기본</a></h1><div class="content"><p>함수형 패러다임을 자바스크립트에 적용할 때에 알면 좋은 Javascript의 기본 문법과 배경 지식을 설명한 글이다.</p>
<h3 id="자바스크립트와-타-언어들간의-함수형-프로그래밍-지원의-차이"><a href="#자바스크립트와-타-언어들간의-함수형-프로그래밍-지원의-차이" class="headerlink" title="자바스크립트와 타 언어들간의 함수형 프로그래밍 지원의 차이"></a>자바스크립트와 타 언어들간의 함수형 프로그래밍 지원의 차이</h3><p>Javascript에는 <strong>없는</strong> 함수형 언어의 특징</p>
<ol>
<li>순수 함수 강제 (side effect를 발생시키는 표현식을 허용하지 않음)</li>
<li>불변성 강제 (변수라고 부르지만, 상수. 객체까지도.)</li>
<li>재귀 강제 (반복문 미지원)</li>
</ol>
<p>아무래도 Javascript는 멀티 패러다임이라 함수형 패러다임만 지원하는 언어에 비해서는 제약이 덜할 수 밖에 없을 것이다.</p>
<p>Javascript에서 이를 극복하는 방법</p>
<ol>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/jfmengels/eslint-plugin-fp">eslint 규칙</a></strong> 사용으로 부분적으로 극복.</li>
<li><code>ImmerJS</code> 등의 라이브러리 도입</li>
<li>함수형 프로그래밍에 익숙해진다면, 괜찮을 것. (<code>1</code>과 마찬가지로 <code>eslint</code> 규칙 도입 등.)</li>
</ol>
<p>Javascript 런타임들이 대부분 꼬리 재귀 호출 최적화를 지원하지 않기 때문에, 재귀가 타 함수형 언어에 비해 성능이 낮을 수 밖에 없다.</p>
<p>꼬리 재귀 호출 최적화는 재귀 호출이 함수의 마지막에서 발생하는 경우에 적용된다. 컴파일러가 자동으로 재귀를 반복문으로 치환한다. 덕분에 스택 프레임을 1개만 사용한다.</p>
<p>Javascript의 장점</p>
<ol>
<li>다른 모든 함수형 언어는 학습 곡선이 높다. 누구나 이해하고 사용할 수 있다고 하기 힘들다.</li>
<li><code>ES6+</code>부터 함수형 지원이 좋은 편이다.</li>
<li>타 함수형 언어들에 비해 시장이 크고, Production-level Application 구축이 용이하다.</li>
</ol>
<h3 id="함수-실행-call-apply-과-인자-arguments-점-다시-보기"><a href="#함수-실행-call-apply-과-인자-arguments-점-다시-보기" class="headerlink" title="함수 실행(call, apply)과 인자(arguments), 점(.) 다시 보기"></a>함수 실행(call, apply)과 인자(arguments), 점(.) 다시 보기</h3><p>Javascript의 함수 안에서는 <code>arguments</code> 객체와 <code>this</code> 키워드를 사용할 수 있다.</p>
<p>※ 화살표 함수에서는 arguments를 사용할 수 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: arguments is not defined</span><br><span class="line">    at hi (&lt;anonymous&gt;:1:37)</span><br><span class="line">    at &lt;anonymous&gt;:1:1</span><br></pre></td></tr></table></figure>
<h3 id="arguments-객체"><a href="#arguments-객체" class="headerlink" title="arguments 객체"></a>arguments 객체</h3><p>배열과 유사한 Arguments 객체(Arguments(4) [ ‘a’, ‘b’, ‘c’, ‘d’, … ])로 매개변수들이 전달된다.</p>
<p><code>arguments</code>에 접근하는 시점에 따라 값이 변경될 수 있다. Javascript의 <code>parameter</code>는 변경할 수 있기 때문에, 이를 변경 후 <code>arguments</code>를 찍어보면 다르게 나온다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">hello(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// Arguments [1, &#x27;b&#x27;];</span></span><br></pre></td></tr></table></figure>
<h3 id="this-객체"><a href="#this-객체" class="headerlink" title="this 객체"></a>this 객체</h3><p><code>obj.prop()</code>으로 호출 시 <code>obj</code>가 <code>this</code>가 된다. <code>.</code> 좌측의 객체가 항상 <code>this</code>가 된다.</p>
<p>최상단 scope에서 호출하면 기본적으로 <code>window.</code>, <code>global.</code>이 생략된 것이기 때문에 <code>this</code>가 <code>window</code>, <code>global</code>이 된다. (global은 <code>Node.js</code> 환경에서.)</p>
<p><code>const &#123; prop &#125; = obj; prop();</code> 하면 <code>prop</code>이 <code>obj</code>에 속해있음에도 불구하고 <code>this</code>가 <code>window</code>, <code>global</code>이 된다.</p>
<h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call"></a>Function.prototype.call</h3><p><code>this</code> 객체를 지정해서 함수를 호출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  thisIs: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 매개변수는 가변 매개변수여서 개수 제한 없이 전달 가능하다.</span></span><br><span class="line">hello.call(obj, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// &#123; thisIs: &quot;obj&quot; &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply"></a>Function.prototype.apply</h3><p><code>call</code>과 다른 점은 매개변수를 배열과 유사한 객체로 넘겨야 한다는 점이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  thisIs: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 매개변수는 배열과 같은 객체로 전달하면 된다.</span></span><br><span class="line">hello.apply(obj, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]); <span class="comment">// &#123; thisIs: &quot;obj&quot; &#125;</span></span><br><span class="line">hello.apply(obj, &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">&#125;); <span class="comment">// &#123; thisIs: &quot;obj&quot; &#125;</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-03T11:00:00.000Z" title="2019-09-03T11:00:00.000Z">19-09-03</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">함수형 자바스크립트</a></span><span class="level-item">3분안에 읽기 (약 468 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/fjs-2-currying/">함수를 부분 실행하는 currying 개념</a></h1><div class="content"><h3 id="사용-예시-1"><a href="#사용-예시-1" class="headerlink" title="사용 예시 1"></a>사용 예시 1</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Field</span><br><span class="line">  name=<span class="string">&quot;username&quot;</span></span><br><span class="line">  onChange=&#123;handleChange(<span class="string">&#x27;username&#x27;</span>)&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;Field</span><br><span class="line">  name=<span class="string">&quot;password&quot;</span></span><br><span class="line">  onChange=&#123;handleChange(<span class="string">&#x27;password&#x27;</span>)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="함수-본문-1"><a href="#함수-본문-1" class="headerlink" title="함수 본문 1"></a>함수 본문 1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleChange = <span class="function">(<span class="params">fieldName</span>) =&gt;</span> <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  fields[fieldName].value = value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="함수-본문-1-해설"><a href="#함수-본문-1-해설" class="headerlink" title="함수 본문 1 해설"></a>함수 본문 1 해설</h3><p>함수 <code>handleChange</code>는 <code>fieldName</code>를 받아 새로운 함수를 반환한다. 반환한 함수에 <code>value</code>를 전달하는 경우, <code>fields</code> 객체에서 <code>fieldName</code>에 해당하는 프로퍼티에 <code>value</code>를 전달받은 <code>value</code>로 갱신한다.</p>
<h3 id="사용-예시-2"><a href="#사용-예시-2" class="headerlink" title="사용 예시 2"></a>사용 예시 2</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createForm = createElHtml(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> createInput = createElHtml(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> form = createForm();</span><br><span class="line"><span class="keyword">const</span> idInput = createInput(<span class="string">&#x27;name=&quot;username&quot;&#x27;</span>);</span><br><span class="line">form.innerHTML = idInput;</span><br></pre></td></tr></table></figure>
<h3 id="함수-본문-2"><a href="#함수-본문-2" class="headerlink" title="함수 본문 2"></a>함수 본문 2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createElHtml = <span class="function">(<span class="params">tag</span>) =&gt;</span> (</span><br><span class="line">  arrtibutes = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  children = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">) =&gt; <span class="string">`&lt;<span class="subst">$&#123;tag&#125;</span> <span class="subst">$&#123;arrtibutes&#125;</span>&gt;<span class="subst">$&#123;children&#125;</span>&lt;/<span class="subst">$&#123;tag&#125;</span>&gt;`</span>;</span><br></pre></td></tr></table></figure>
<h3 id="사용-예시-3"><a href="#사용-예시-3" class="headerlink" title="사용 예시 3"></a>사용 예시 3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toBoolean = <span class="function">(<span class="params">x</span>) =&gt;</span> !!x;</span><br><span class="line"><span class="keyword">const</span> double = <span class="function">(<span class="params">n</span>) =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> toNumber = <span class="function">(<span class="params">str</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Number</span>.parseInt(str, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> composedFunction = compose(</span><br><span class="line">  toBoolean,</span><br><span class="line">  double,</span><br><span class="line">  toNumber,</span><br><span class="line">); <span class="comment">// toNumber -&gt; double -&gt; toBoolean 순으로 실행된다.</span></span><br><span class="line"><span class="comment">// 매개변수는 composedFunction에 전달된 것부터</span></span><br><span class="line"><span class="comment">// 각 함수의 반환값이 다음 함수의 매개변수가 된다.</span></span><br><span class="line"></span><br><span class="line">composedFunction(<span class="string">&#x27;0&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">composedFunction(<span class="string">&#x27;&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">composedFunction(); <span class="comment">// false</span></span><br><span class="line">composedFunction(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">composedFunction(<span class="string">&#x27;2&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="함수-본문-3"><a href="#함수-본문-3" class="headerlink" title="함수 본문 3"></a>함수 본문 3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...functions</span>) =&gt;</span></span><br><span class="line">  [...functions].reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    f(g(...args)),</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<h3 id="함수-본문-3-해설"><a href="#함수-본문-3-해설" class="headerlink" title="함수 본문 3 해설"></a>함수 본문 3 해설</h3><ul>
<li><code>compose(f,g,h)(1)</code> =&gt; <code>f(g(h(1)))</code>의 형태로 실행한다.</li>
<li>compose 내부에선 <code>functions</code>를 배열에 넣어 <code>reduce</code>를 호출한다. <code>Array.reduce</code>는 <code>(result, currentvalue) =&gt; result;</code> 이다. reduce에게 <code>(f, g) =&gt; (...args) =&gt; f(g(...args))</code>를 인자로 넘겨준다.</li>
<li>단계별 흐름도<ul>
<li><code>(f, g) =&gt; (...args) =&gt; f(g(...args)) // f, g</code></li>
<li><code>((...args) =&gt; f(g(...args)), h) =&gt; ((...args) =&gt; f(g(h(...args)))) // f,g 합성함수, h 함수</code></li>
</ul>
</li>
</ul>
<h3 id="함수형-프로그래밍과의-연관성"><a href="#함수형-프로그래밍과의-연관성" class="headerlink" title="함수형 프로그래밍과의 연관성"></a>함수형 프로그래밍과의 연관성</h3><ol>
<li><code>currying</code>은 <code>함수</code>를 인자로 받게 만들 수도 있고, <code>함수가 아닌 값</code>을 받게 만들 수도 있다. 두 방법 모두 유용하다.</li>
<li>currying은 마지막으로 반환되는 경우를 제외하면 대부분 계속해서 함수를 반환한다. 이는 함수간의 조합이 쉽다.</li>
</ol>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://medium.com/front-end-weekly/javascript-es6-curry-functions-with-practical-examples-6ba2ced003b1">JavaScript ES6 curry functions with practical examples (EN)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/learn-javascript-courses/es6-curry">Learning Javascript Courses: ES6 Curry (EN)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/185585/what-is-the-advantage-of-currying">What is the advantage of currying? (EN)</a></p>
</li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">이전</a></div><div class="pagination-next"><a href="/page/5/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-20T14:00:00.000Z">21-06-20</time></p><p class="title"><a href="/linux-system-log-1/">리눅스 - 시스템 로그와 로그인 로그</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-13T14:55:00.000Z">21-06-13</time></p><p class="title"><a href="/linux-sshd-logs/">리눅스 - ssh/sshd의 보안에 대해 (1/2)</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-06T14:43:00.000Z">21-06-06</time></p><p class="title"><a href="/linux-ufw/">우분투의 SW 기반 방화벽 - UFW</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-30T14:35:00.000Z">21-05-30</time></p><p class="title"><a href="/linux-filesystem-ext/">리눅스 파일 시스템의 구조 - ext 계열</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-16T14:55:00.000Z">21-05-16</time></p><p class="title"><a href="/linux-namespaces-2/">Linux와 Docker의 기술적 관계 (2/3) - Network Namespace 기초</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
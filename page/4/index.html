<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-01T09:00:00.000Z" title="2021-02-01T09:00:00.000Z">21-02-01</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-03-03T11:53:48.260Z" title="2021-03-03T11:53:48.260Z">21-03-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">Node.js 디자인 패턴</a></span><span class="level-item">12분안에 읽기 (약 1828 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ndp-5-stream-1/">5장 Stream API (1/3) - 스트림 개요 및 Readable Stream</a></h1><div class="content"><p>이 글은 Node.js 디자인 패턴 CH 05 스트림 코딩의 일부를 참고해서 작성하였다. 이번 글은 Stream API에 대해 깊이 다루기보다 스트림 자체에 대해 다룬다.</p>
<hr>
<h3 id="스트림-개요"><a href="#스트림-개요" class="headerlink" title="스트림 개요"></a><strong>스트림 개요</strong></h3><p>스트림은 파일을 버퍼 단위로 옮겨서 전부 옮길 때까지 기다린 후 처리하기보다 매 버퍼 단위로 전송하는 방식이다.</p>
<p>스트림은 본질적으로 비동기 패러다임으로, <u>기다린 후</u> 처리하는 Sync 방식에 대비된다. 물론 <code>fs.readFile</code> 역시 Node.js 런타임에서 I/O를 처리해주니 스레드가 Block 되진 않겠지만, 애초에 <u>I/O 수준에서도 기다릴 일이 없게</u> 하는 것이 처리량에서 우위이지 않을까? </p>
<p>(처리량에서 정말 우위일지는 잘 모르겠다. 스트리밍 오버헤드에 대해 공부해본 적이 없기 때문.)</p>
<h3 id="스트림의-공간-효율성"><a href="#스트림의-공간-효율성" class="headerlink" title="스트림의 공간 효율성"></a><strong>스트림의 공간 효율성</strong></h3><p>스트림은 메모리에 파일의 전체 내용을 올리지 않고 버퍼의 크기만큼만 메모리를 할당하기 때문에 공간 효율적이다. 더 좋은 점은 <u>파일의 크기에 상관 없이</u> 일정한 양의 메모리를 점유한다는 점이다.</p>
<blockquote>
<p>이것과 별개로 V8 엔진은 32bit 기준 ~1GB, 64bit 기준 ~1.7GB 정도의 메모리만 사용하도록 설정돼있어(더 높이려면 빌드해야 함.) 파일이 큰 경우 전체 파일을 한 번에 메모리에 올릴 수 없음.</p>
</blockquote>
<hr>
<p>공간 비효율적인 파일 압축 코드 (ex: example.tar -&gt; example.tar.gz)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">fs.readFile(file, <span class="function">(<span class="params">err, buffer</span>) =&gt;</span> &#123;</span><br><span class="line">  zlib.gzip(buffer, <span class="function">(<span class="params">err, buffer</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.writeFile(file + <span class="string">&#x27;.gz&#x27;</span>, buffer, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;File successfully compressed&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>공간 효율적인 파일 압축 코드 (Stream API)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파일을 읽는데에 buffer 크기만큼만 메모리를 점유하기 때문에 공간 효율적</span></span><br><span class="line"><span class="comment">// pipe 체이닝으로 각 chunk에 대해 이런 저런 처리를 할 수 있음.</span></span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(fs.createWriteStream(file + <span class="string">&#x27;.gz&#x27;</span>))</span><br><span class="line">  .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;File successfully compressed&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>참고로 gzip이 어떻게 스트림에 대해 동작하는지 궁금하다면 아래 글들을 참고해보면 좋을 것 같다.</p>
<p><a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/393834/how-is-it-possible-to-gzip-a-stream-before-the-entire-contents-are-known">How is it possible to GZIP a stream before the entire contents are known? | StackOverFlow</a> </p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19700503/how-does-gzip-compression-rate-change-when-streaming-data">How does gzip compression rate change when streaming data? | StackOverFlow</a></p>
<hr>
<h3 id="스트림의-시간-효율성"><a href="#스트림의-시간-효율성" class="headerlink" title="스트림의 시간 효율성"></a><strong>스트림의 시간 효율성</strong></h3><p>Stream은 TTFB(Time to First Byte)에 강점이 있는데, TTFB는 파일의 크기에 비례하여 빠를 수 밖에 없다. 파일의 크기가 클 수록 읽는 데 대기시간이 필요하지만 Stream은 곧바로 응답을 보내기 시작하기 때문이다.</p>
<blockquote>
<p>웹에서 TTFB는 매우 중요하다.</p>
<p>자세한 건 <a target="_blank" rel="noopener" href="https://github.com/vercel/next.js/issues/1209">Next.js의 재밌는 이슈(Stream rendering to reduce TTFB and CPU load)</a> 참고.</p>
</blockquote>
<h4 id="파일을-단위로-전송하는-Server-Client-모델"><a href="#파일을-단위로-전송하는-Server-Client-모델" class="headerlink" title="파일을 단위로 전송하는 Server-Client 모델"></a><strong>파일을 단위로 전송하는 Server-Client 모델</strong></h4><p>다음의 사이클을 단 1회 거치게 된다: read &gt; compress &gt; send &gt; receive &gt; decompress &gt; write</p>
<hr>
<h4 id="chunk-단위로-전송하는-Server-Client-모델"><a href="#chunk-단위로-전송하는-Server-Client-모델" class="headerlink" title="chunk 단위로 전송하는 Server-Client 모델"></a><strong>chunk 단위로 전송하는 Server-Client 모델</strong></h4><p>위의 사이클을 매 chunk마다 거치게 되므로 파이프라이닝과 같은 형태로 병렬 처리가 가능하다. 물론 chunk의 크기마다 다르겠지만 각 단계를 거치는 만큼 오버헤드가 있을 것이다. (HTTP header 등. 이 부분에 대해선 잘 알지 못한다.)</p>
<blockquote>
<p> Node.js 동시성을 활용하는 것이므로 순서를 맞춰줘야 하는데 Stream API가 알아서 처리한다고 한다. </p>
</blockquote>
<hr>
<p>아래는 파일을 전송하는 스트림 예제 코드이다.</p>
<p><strong>client</strong>: 파일을 받아 디스크에 쓰는 역할</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = req.headers.filename;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;File request received: &#x27;</span> + filename);</span><br><span class="line">  req</span><br><span class="line">    .pipe(zlib.createGunzip())</span><br><span class="line">    .pipe(fs.createWriteStream(filename))</span><br><span class="line">    .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span> <span class="comment">/* CREATED */</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">      res.end(<span class="string">&#x27;That\&#x27;s it\n&#x27;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;filename&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Listening&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>server</strong>: 파일을 읽고 전송하는 역할</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> server = process.argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  hostname: server,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    filename: path.basename(file),</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/octet-stream&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Encoding&#x27;</span>: <span class="string">&#x27;gzip&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = http.request(options, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server response: &#x27;</span> + res.statusCode);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;File successfully sent&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="스트림의-문제-해결력"><a href="#스트림의-문제-해결력" class="headerlink" title="스트림의 문제 해결력"></a><strong>스트림의 문제 해결력</strong></h3><p>스트림은 Composition으로 문제 해결을 한다. Express Middleware와 같이 마음껏 파이프라인을 만들어낼 수 있다. </p>
<ul>
<li>파이프라인은 각 기능 간에 결합이 없기 때문에 항상 1차원으로 코드가 <u>표현</u>된다. (분기가 없다는 게 아니라 가독성이 좋다는 것.)</li>
<li>선언형으로 프로그래밍하기 수월하다. 선언형 패러다임은 코드를 요약해서 바라볼 수 있기 때문에 쉽게 이해하기 좋다.</li>
</ul>
<blockquote>
<p>스트림을 기반으로 비동기 이벤트를 처리하는 패러다임을 Reactive라고 하고 이를 위한 RxJS가 있다.</p>
</blockquote>
<p>(ex) 암호화 기능 추가</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 복호화</span></span><br><span class="line">.pipe(crypto.createDecipheriv(<span class="string">&quot;aes-192-gcm&quot;</span>, <span class="string">&quot;a_shared_secret&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 암호화</span></span><br><span class="line">.pipe(crypto.createCipheriv(<span class="string">&quot;aes-192-gcm&quot;</span>, <span class="string">&quot;a_shared_secret&quot;</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Node-js에서-지원하는-스트림"><a href="#Node-js에서-지원하는-스트림" class="headerlink" title="Node.js에서 지원하는 스트림"></a><strong>Node.js에서 지원하는 스트림</strong></h3><p>Node.js가 지원하는 스트림은 EventEmitter 객체를 상속하며 binary, 문자열 뿐만 아니라 거의 모든 Javascript의 값을 읽을 수 있다. 이러한 스트림에는 크게 네 종류가 있는데 이번 글에서는 (글이 길어지는 관계로) Readable만 다룬다.</p>
<ul>
<li>Readable, Writable, Duplex, Transform</li>
</ul>
<hr>
<h4 id="1-Readable"><a href="#1-Readable" class="headerlink" title="1. Readable"></a><strong>1. Readable</strong></h4><p>Readable 스트림은 외부에서 읽기 위한 스트림으로, 자신이 가진 값을 chunk로 써서 내보내는 역할이다. </p>
<blockquote>
<p>사용 예:</p>
<p><code>readable</code> 이벤트에 listener를 등록하고 이벤트 발생 시 버퍼에 있는 내용을 모두 읽기</p>
</blockquote>
<blockquote>
<p>API로는 아래의 함수가 있다.</p>
<p><code>readable.read([size]) // read는 동기 함수이다.</code></p>
</blockquote>
<p>(ex) 표준 입력(stdin) 받아서 표준 출력(<code>console.log</code>, <code>stdout.write</code>)하기</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">&#x27;readable&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;New data available&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Chunk read: (<span class="subst">$&#123;chunk.length&#125;</span>) &quot;<span class="subst">$&#123;chunk.toString()&#125;</span>&quot;`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> process.stdout.write(<span class="string">&#x27;End of stream&#x27;</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Stream v1, v2에 따라 non-flowing mode, flowing mode 로 나뉘는데 어차피 v1은 사용되지 않으므로 설명을 생략한다.</p>
</blockquote>
<hr>
<h4 id="ReadableStream을-하나-새로-만드는-예제"><a href="#ReadableStream을-하나-새로-만드는-예제" class="headerlink" title="ReadableStream을 하나 새로 만드는 예제"></a><strong>ReadableStream을 하나 새로 만드는 예제</strong></h4><p>지금까지는 <code>fs</code>, <code>http</code>의 스트림을 그대로 사용했지만 직접 ReadableStream을 만들어 활용할 수도 있다. </p>
<p><code>stream.Readable</code>을 상속해 abstract function인 <code>_read([size])</code>(public 인터페이스인 <code>read</code>와 헷갈리면 안 된다)를 구현하면 ReadableStream 객체를 하나 만들 수 있다.</p>
<p>구현을 위해 <code>push(data[, encoding])</code> 함수를 호출해 내부 버퍼에 값을 쓸 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Chance = <span class="built_in">require</span>(<span class="string">&#x27;chance&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1] 생성</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomStream</span> <span class="keyword">extends</span> <span class="title">stream</span>.<span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_read</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Pushing chunk of size: <span class="subst">$&#123;chunk.length&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">this</span>.push(chunk, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123; </span><br><span class="line">      <span class="built_in">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2] 사용</span></span><br><span class="line"><span class="keyword">const</span> RandomStream = <span class="built_in">require</span>(<span class="string">&#x27;./randomStream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> RandomStream();</span><br><span class="line"></span><br><span class="line">randomStream.on(<span class="string">&#x27;readable&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> chunk;</span><br><span class="line">  <span class="keyword">while</span>((chunk = randomStream.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received: <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>나머지 스트림 종류 다루기</p>
<p>백 프래셔</p>
<p>스트림 기반 비동기 제어</p>
<p>Pipe Composition</p>
<p>멀티 플렉싱, 디멀티 플렉싱</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-28T06:05:00.000Z" title="2021-01-28T06:05:00.000Z">21-01-28</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-28T06:06:43.740Z" title="2021-01-28T06:06:43.740Z">21-01-28</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a><span> / </span><a class="link-muted" href="/categories/Frontend/React-js/">React.js</a></span><span class="level-item">14분안에 읽기 (약 2159 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/atomic-design-1/">Atomic Design - 1 Intro</a></h1><div class="content"><p>이 글은 Atomic Design의 목적과 활용에 대해 간단하게 다룬다. 이후 시리즈에서는 실제 적용 예시를 다루고자 한다.</p>
<hr>
<h3 id="목적"><a href="#목적" class="headerlink" title="목적"></a><strong>목적</strong></h3><p>현대 프론트엔드는 두 가지 복잡성을 맞이했는데, Atomic Design은 이 문제를 해결하는데 효과적이다.</p>
<ul>
<li><p>이전에 비해 다양한 해상도를 지원해야 함.</p>
</li>
<li><p>UI 컴포넌트의 종류가 다양해지고 복잡해짐. 많은 상태를 갖게 됨.</p>
</li>
</ul>
<hr>
<p>즉 유지보수 비용이 크게 늘어난 상태이다. 소프트웨어 개발에서 복잡성을 낮추는 방식은 분할 정복과 의존성 격리를 통한 SRP 만족인데, Atomic Design은 프론트엔드의 구성 요소를 디자인 수준에서 분할하므로, 개발자는 이를 재사용하여 총 개발 비용을 낮출 수 있다.</p>
<p>기존에도 HTML, CSS 수준에서 컴포넌트 개발이 어느 정도 가능했으나 React.js의 등장 후 CSS-in-JS 라는 생태계가 조성된 덕분에 컴포넌트 개념의 완전한 구현이 가능해졌기 때문에 Atomic Design이 더 많이 언급되고 활용되는 듯하다.</p>
<hr>
<p>현대에는 <a target="_blank" rel="noopener" href="https://uxdesign.cc/everything-you-need-to-know-about-design-systems-54b109851969">디자인 시스템 (EN)</a>을 사용하는 것이 일반적인데, 디자인 시스템이란 브랜딩 디자인, 컴포넌트를 위한 스타일 가이드, 컴포넌트 등으로 구성된 디자인 &amp; 추상적인 개념의 집합이다. </p>
<p>이런 디자인 시스템의 Typo, Spacing 등을 포함해 컴포넌트를 라이브러리로 개발해놓으면, 전사적으로 디자인이 통일성을 갖게 되기도 하고 개발 측면에선 이미 개발된 디자인 요소를 빠르게 선언적으로 활용할 수 있기 때문에 생산성에 많이 유리하다. </p>
<ul>
<li>이미 널리 알려진 디자인 시스템의 라이브러리 또한 많다. 아무래도 Material Design의 구현체인 <a target="_blank" rel="noopener" href="https://material-ui.com/">Material-UI</a>가 가장 유명할 것이다.</li>
</ul>
<hr>
<p>Atomic Design의 접근 방식은 디자인 시스템을 구축하는 데 효과적이므로 많이 사용된다. 이후에 Atomic Design이 어떻게 개발 과정에서 유용하게 사용되는지 설명한다.</p>
<h3 id="이론"><a href="#이론" class="headerlink" title="이론"></a><strong>이론</strong></h3><p>가장 큰 개념으로 페이지, 컴포넌트가 있다. 컴포넌트가 조합돼 페이지를 구성하는 형태이다.</p>
<p>컴포넌트는 조합되므로 재사용된다. 즉 효율적이며 페이지 간 일관성 또한 보장된다.</p>
<p>컴포넌트는 아래의 4개의 하위 요소로 나뉜다. (작은 순으로 정렬)</p>
<ul>
<li>원자 (Atom)</li>
<li>분자 (Molecule)</li>
<li>유기체 (Organism)</li>
<li>템플릿 (Template)</li>
</ul>
<hr>
<h4 id="원자-Atom"><a href="#원자-Atom" class="headerlink" title="원자 (Atom)"></a><strong>원자 (Atom)</strong></h4><p>더 분해할 수 없는 가장 작은 요소이다. 아주 작은 기능도 Atom의 조합으로 만들어지는, 콘텐츠로서의 구체성은 없다.</p>
<p>(ex) 검색 폼: { <u>검색 Text, 검색 Input 바, 전송 버튼</u> } 이라는 Atom의 조합으로 생성 (여기서 어떻게 조합하는지는 또 별개의 정보.)</p>
<p>종류:</p>
<ul>
<li>버튼</li>
<li>텍스트 인풋, 색 팔레트, …</li>
<li>타이포그래피, 제목 (h1, h2, h3, …)</li>
<li>아이콘</li>
<li>체크박스, 라디오 버튼</li>
</ul>
<hr>
<h4 id="분자-Molecule"><a href="#분자-Molecule" class="headerlink" title="분자 (Molecule)"></a><strong>분자 (Molecule)</strong></h4><p>분자는 원자들의 조합을 그 단위로 한다. 분자부터 콘텐츠로서의 구체성이 있다.</p>
<p>(ex) <u>검색 폼</u>: { 검색 Text, 검색 Input 바, 전송 버튼 } 이라는 구체적인 목적이 있는 요소.</p>
<p>분자는 원자들의 조합이지만 계속해서 재사용성이 유지해야 한다.</p>
<p>(ex) 검색 폼은 여러 페이지에서 사용됨.</p>
<p>아무래도 재사용성 유지를 위해 적은 수의 Atom을 조합하여 그 범용성을 높인다.</p>
<hr>
<h4 id="유기체-Organism"><a href="#유기체-Organism" class="headerlink" title="유기체 (Organism)"></a><strong>유기체 (Organism)</strong></h4><p>유기체는 분자 뿐만 아니라 원자까지 조합해 만들어진다.</p>
<p>유기체부터는 재사용이 강제되지 않는다. 즉 분자와 유기체의 차이는 재사용성이라고 생각할 수 있다.</p>
<p>(ex) Header, Footer 컴포넌트</p>
<p>유기체는 Container의 형태를 띄기도 한다. (ex) ProductList (ProductListItem의 배치 역할)</p>
<p>아무래도 이런 List 컴포넌트는 재사용하기 어렵기 때문에 유기체로 분류되는 것이 일반적이다.</p>
<blockquote>
<p>몇 개의 Organism을 배치하면 하나의 페이지가 완성된다고 하는데 잘 모르겠다.</p>
</blockquote>
<hr>
<h4 id="템플릿-Template"><a href="#템플릿-Template" class="headerlink" title="템플릿 (Template)"></a><strong>템플릿 (Template)</strong></h4><p>하위 컴포넌트들의 배치가 목적인 컴포넌트로, 페이지 구조나 레이아웃 구성을 담당한다.</p>
<p>하위 컴포넌트는 자신의 형태만 다룰 뿐 자신이 어떻게 배치될 지에 대해 책임지지 않는데, 템플릿은 이러한 컴포넌트들을 어떻게 배치시키고 표현할 것인지 결정한다.</p>
<blockquote>
<p>약간 <code>UI = render(state)</code> 느낌이기도 하다.</p>
</blockquote>
<hr>
<h4 id="페이지-Page"><a href="#페이지-Page" class="headerlink" title="페이지 (Page)"></a><strong>페이지 (Page)</strong></h4><p>페이지는 템플릿에 예제/실제 데이터가 들어간 상태를 말한다. (ex) Mockup</p>
<p>템플릿에 데이터를 주고 초기화한 인스턴스라고 생각해도 좋다.</p>
<hr>
<h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a><strong>장점</strong></h3><p>Atomic Design은 디자이너도 함께 실행해야 하는 것이지만 개발자 측면에서의 장점만 나열하겠다.</p>
<h4 id="1-원활한-의사소통"><a href="#1-원활한-의사소통" class="headerlink" title="1. 원활한 의사소통"></a><strong>1. 원활한 의사소통</strong></h4><p>컴포넌트 단위로 나누는 것은 그 단위가 미리 정의가 돼야 하며 모두가 동의해야 한다. 그러한 단위를 굳이 Atomic Design이 주장하는 바대로 따를 필요는 없지만 의사 소통 이전에 미리 정의돼야함은 변함이 없다. 이 때 Atomic Design은 이런 단위를 미리 정의해서 제공한다.</p>
<p>충분히 납득할만한 수준으로 잘 정의됐으며 이미 널리 알려져 있기 때문에 사용할 가치가 높다고 생각한다.</p>
<h4 id="2-의존성-분리"><a href="#2-의존성-분리" class="headerlink" title="2. 의존성 분리"></a><strong>2. 의존성 분리</strong></h4><p>Atomic Design에 부합하도록 각 요소를 잘 분리한다면 아래와 같은 실익을 얻을 수 있다.</p>
<ul>
<li>개발 과정을 병렬로 진행할 수 있고</li>
<li>각 요소가 변경되더라도 변경되는 요소를 최소한으로 줄일 수 있음</li>
</ul>
<h4 id="3-작은-컴포넌트"><a href="#3-작은-컴포넌트" class="headerlink" title="3. 작은 컴포넌트"></a><strong>3. 작은 컴포넌트</strong></h4><p>Atomic Design의 각 단위에 맞게 하나의 역할을 하는 컴포넌트로 개발하면 각 컴포넌트를 작게 유지할 수 있다. 덕분에 그 개수가 늘어나도 변경에 의한 변경을 최소화할 수 있으며 따라서 복잡성이 지수적으로 올라가기보다 선형적으로 증가할 것이다. 뭐든 작게 유지하는 것은 key to computer science 이고 UNIX 철학에도 들어맞는다. </p>
<blockquote>
<p>Make each program do one thing well.</p>
</blockquote>
<hr>
<h3 id="주의점"><a href="#주의점" class="headerlink" title="주의점"></a><strong>주의점</strong></h3><h4 id="1-재사용을-위한-반응형-디자인"><a href="#1-재사용을-위한-반응형-디자인" class="headerlink" title="1. 재사용을 위한 반응형 디자인"></a><strong>1. 재사용을 위한 반응형 디자인</strong></h4><p>컴포넌트는 데이터에 따라 여러 상태를 가질 수 있고, 따라서 여러 해상도에서 표시될 수 있다. 컴포넌트가 여러 해상도를 지원하려면 가로 너비(width)가 변할 수 있게 개발해야 한다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* before */</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* after */</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-하위-컴포넌트에서-레이아웃-속성-최대한-피하기"><a href="#2-하위-컴포넌트에서-레이아웃-속성-최대한-피하기" class="headerlink" title="2. 하위 컴포넌트에서 레이아웃 속성 최대한 피하기"></a><strong>2. 하위 컴포넌트에서 레이아웃 속성 최대한 피하기</strong></h4><p>Atomic Design에서 컴포넌트를 배치하는 역할은 상위 컴포넌트의 역할이다. 배치란 위치를 결정하는 일이고 따라서 각 컴포넌트는 자신이 그려지는 바깥 범위의 레이아웃을 방해하면 안 된다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 여백은 배치(레이아웃) 속성이며 이렇게 스스로 값을 줘버리면 배치하는 입장에서 굳이 덮어써야 한다. */</span></span><br><span class="line"><span class="selector-class">.atom</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Atom을 조합하는 Molecule이 조합된 Atom을 알아서 배치하는 것이 적절하다. */</span></span><br><span class="line"><span class="selector-class">.molecule</span> <span class="selector-class">.atom</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-CSS3-Flexbox-GridBox-사용하기"><a href="#3-CSS3-Flexbox-GridBox-사용하기" class="headerlink" title="3. CSS3 Flexbox/GridBox 사용하기"></a><strong>3. CSS3 Flexbox/GridBox 사용하기</strong></h4><p>flex, grid 속성은 배치에 최적화된 속성이며 Organism의 경우 List 컴포넌트와 같이 Molecule을 배치하는 역할을 주로 하기 때문에 이 때 사용하는 것은 적절하다고 할 수 있다. </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.organism</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="실제-활용-예시"><a href="#실제-활용-예시" class="headerlink" title="실제 활용 예시"></a><strong>실제 활용 예시</strong></h3><p><a target="_blank" rel="noopener" href="https://velog.io/@thsoon/%EC%93%B8%EB%95%8C%EC%97%86%EC%9D%B4-%EA%B3%A0%ED%80%84%EC%9D%B8-%ED%88%AC%EB%91%90%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-FE-2.-%EB%B7%B0-%EC%84%A4%EA%B3%84">Atomic Design으로 Todo 만들기 (KR)</a></p>
<hr>
<p>출처: <a target="_blank" rel="noopener" href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=190038704">더 괜찮은 웹 개발자가 되기 위한 리액트 스타일 가이드 (Aladin)</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-25T11:00:00.000Z" title="2021-01-25T11:00:00.000Z">21-01-25</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-25T22:45:47.390Z" title="2021-01-25T22:45:47.390Z">21-01-26</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">11분안에 읽기 (약 1660 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-async-2/">JS Async Functionality 2 - Promise</a></h1><div class="content"><p>이 시리즈는 자바스크립트에서 비동기를 다룰 때 마주치는 개념들을 다룬다. 이번 글에서는 Promise를 다룬다. </p>
<p><a href="https://jsqna.com/js-async-1/">JS Async Functionality 1 - Intro</a></p>
<hr>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise:"></a><strong>Promise:</strong></h4><p><code>&#123; pending, fulfilled, rejected &#125;</code>상태를 가지는 객체로,  <code>executor</code> 함수를 인자로 받는다. </p>
<ul>
<li><p>executor 함수( <code>(resolve, reject ) =&gt; &#123;&#125;</code> )의 역할:</p>
<ol>
<li>비동기 함수를 호출하고 </li>
<li>그 비동기 함수의 콜백에서 resolve를 호출한다.</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">url</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 이 함수가 executor 함수이다. (주석 설명 참조)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. example Async API provided by Node.js</span></span><br><span class="line">    http.get(options, <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">let</span> data;</span><br><span class="line">        result.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> data += chunk);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. Calls either [ resolve, reject ] from async callback.</span></span><br><span class="line">        result.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> resolve(data));</span><br><span class="line">        result.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> reject(err));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>executor 함수는 기존의 비동기 처리 방식을 그대로 옮겨온 것으로 이해하기 어렵지 않다.</p>
</li>
<li><p>다만 Promise Chaining이라는 개념으로 Callback Hell을 1차원으로 들여쓰기 단계를 낮출 수 있다.</p>
</li>
<li><p>이렇게 들여쓰기 단계를 줄이는 것은 중요한데 가독성에 의한 논리 오류가 빈번하게 발생했기 때문이다.</p>
</li>
</ul>
<hr>
<p>또한 Javascript 특성상 CPS 패턴으로 작성된 비동기 처리 함수에서, 이후에 호출되는 함수는 이전 함수의 클로저 참조도 할 수 있다. </p>
<ul>
<li>부주의하게 클로저 영역의 변수들을 사용하는 경우 메모리 사용량 면에서 좋을 게 없었다. </li>
<li>(ex) 전체 비동기 절차가 끝날 때 까지 호출 함수의 지역 변수들이 해제되지 못하는 등.</li>
</ul>
<hr>
<h4 id="Promise-Chaining"><a href="#Promise-Chaining" class="headerlink" title="Promise Chaining:"></a><strong>Promise Chaining:</strong></h4><p>Promise는 타입이자 객체이다. Promise(<executor function>); 인스턴스는 자신의 실행 흐름에 관여하는 메소드를 세 개 갖는다: <strong><u>then</u></strong>, <strong><u>catch</u></strong>, <u><strong>finally</strong></u> (참고로 메소드는 총 5개이다. race, all이 그 나머지 둘이다.)</p>
<ul>
<li>Prototype에 등록된 함수로, then은 Promise를 반환하고(그래서 Chaining이 가능하고) catch는 reject된 Promise에 한 해 수행되는 조건문으로 <code>then(undefined, onRejected)</code>와 동등하다. finally는 JS의 try-catch-finally의 finally와 동등하다.</li>
</ul>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a><strong>then</strong></h4><p><code>then</code> = (onFulfilled, onRejected) =&gt; Promise</p>
<p>즉 then의 두 번째 인자는 catch 절인 셈이다. 웬만하면 가독성을 위해 따로 catch 절을 사용한다.</p>
<ul>
<li><p>onFulfilled = value =&gt; Promise (여기서 value는 Promise가 resolve한 값이다. 보통 비동기 함수의 결괏값.)</p>
</li>
<li><p>onRejected = value =&gt; {} (여기서 value는 Promise가 reject한 값이다. 보통 Error 객체.)</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.then(onFulfilled, onRejected);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 비동기가 별 탈 없이 진행된 경우.</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 비동기 함수 수행 중 오류가 난 경우.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>then에서는 값을 그냥 반환하는 경우 Promise.resolve로 감싼 것과 같다. 즉 Promise가 반환되는 것인데, 그렇기 때문에 Promise Chaining이 가능한 것이다.</p>
</li>
</ul>
<hr>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a><strong>catch</strong></h4><p><code>catch</code> = onRejected =&gt; Promise <strong>(!)</strong></p>
<ul>
<li><p>catch 메소드는 <code>try-catch</code>의 <code>catch</code>와 같은 역할이다. 즉, catch가 성공했느냐, 실패했느냐에 따라 다시 then이 실행될 수도 있고 다른 catch가 실행될 수도 있고 앱이 멈출 수도 있다.</p>
</li>
<li><p>Case 1: catch 절에서 resolved Promise를 반환하는 경우: 이후의 then 수행</p>
</li>
</ul>
<ul>
<li><p>catch 절에서 따로 throw를 하거나, <code>Promise.reject()</code>를 호출하지 않는 경우 Promise는 resolved 상태로 변하여 then을 수행한 것과 동등하게 된다.</p>
</li>
<li><p>Case 2: catch 절에서 rejected Promise를 반환하는 경우: 이후의 catch 수행</p>
</li>
</ul>
<ul>
<li><p>JS의 try-catch에서 catch는 여러 개가 존재할 수 없는 것에 비해 Promise가 rejected 상태이면 catch절은 계속해서 호출된다. 보통 여러 개의 catch 절은 특정 오류만 잡고 싶을 때 사용한다.</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래처럼 pin-point로 catch 절을 사용하는 것이 가능하다.</span></span><br><span class="line"><span class="comment">// 기존 JS에서 try-catch를 여러 번 순차적으로 사용한 것과 동등하다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.Promise를 생성</span></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">// 1. throw를 호출해 catch 절로 이동</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;oh, no!&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 2. reject 혹은 throw를 하지 않으므로 then 수행</span></span><br><span class="line">  <span class="built_in">console</span>.error(e.message); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 3. 이 then이 수행되게 됨.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;after a catch the chain is restored&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 4. 만약 [2], [3]에서 throw를 하는 경우 여기로 오게 됨.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Not fired due to the catch&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a><strong>finally</strong></h4><p>(설명 생략)</p>
<hr>
<h3 id="알기-어려운-Promise의-특징"><a href="#알기-어려운-Promise의-특징" class="headerlink" title="알기 어려운 Promise의 특징"></a><strong>알기 어려운 Promise의 특징</strong></h3><p><strong>1. <u>then, catch는 비동기로 실행</u>된다.</strong></p>
<ul>
<li><p>아무리 Promise.resolve(); 로 resolve가 동기로 수행되더라도 then, catch는 비동기로 queue 된다.</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="literal">null</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Async: &#x27;</span> + v));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Sync!&#x27;</span>);</span><br><span class="line"><span class="comment">// 결과:</span></span><br><span class="line"><span class="comment">// Sync!</span></span><br><span class="line"><span class="comment">// Async: null</span></span><br><span class="line"><span class="comment">// WHY? then이 async로 microtask queue에 들어갔기 때문.</span></span><br><span class="line"><span class="comment">// then이</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>2: then, catch는 <u>비동기이지만 한꺼번에 수행</u>된다.</strong></p>
<ul>
<li><p>만약 then, catch가 setTimeout과 같은 일반적인 비동기였다면 <u>Task Queue</u>에서 처리된다. Task Queue는 한 작업만 처리하고 나머지 작업은 다음 순서로 넘긴다.</p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(loop, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">loop();</span><br><span class="line"><span class="comment">// 무한 루프에 걸리지 않는다.</span></span><br><span class="line"><span class="comment">// Microtask가 아니므로 이벤트 루프에서 한 작업씩만(!!!) 처리한다.</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>그러나 Promise, then, catch는 <u>Microtask Queue</u>에서 수행되는데, 이는 Event Loop 내의 Event Loop으로 생각하면 된다.</p>
<ul>
<li><p>굳이 이렇게 하는 이유는 </p>
<ol>
<li>다른 Javascript 수행이 되지 않음을 보장 </li>
<li>화면이 변경되지 않음을 보장 하기 위해서이다.</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>Microtask가 호출한 microtask 역시 이어서 수행되며 microtask queue가 빌 때까지 이 단계는 끝나지 않는다. </p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// then은 microtask에 queue 된다.</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(loop);</span><br><span class="line">&#125;</span><br><span class="line">loop();</span><br><span class="line"><span class="comment">// microtask는 현재 cycle에서 microtask가 비워질 때까지 수행을 멈추지 않는다.</span></span><br><span class="line"><span class="comment">// 즉 무한 루프를 비동기 코드로 발생시킬 수 있는 셈이다.</span></span><br></pre></td></tr></table></figure></li>
<li><p>출처: <a target="_blank" rel="noopener" href="https://ko.javascript.info/event-loop#ref-834">이벤트 루프와 매크로, 마이크로 태스크</a>, <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">Jake Archibald: Inside Loop - JSConf.Asia | Youtube</a></p>
</li>
</ul>
</li>
<li><p>Promise가 연속적으로 수행되어 문제가 발생하는 예제를 생각하려고 했으나 대부분의 비동기는 microtask를 사용하지 않기에 큰 문제는 없을 것 같다. 따라서 이 본문의 내용을 몰라도 거의 문제는 없을 것 같다.</p>
</li>
</ul>
<hr>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a><strong>출처</strong></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">Promise then</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch">Promise catch</a> (재밌는 점은 catch 문서는 한국어 번역이 없다는 점이다.)</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Using_promises">Using Promises</a></p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>처음에 React를 통해 ES6를 배우면서 Promise를 접했을 때보다 문서 개수나 번역이 훨씬 좋아졌다는 걸 느꼈다. 앞으로의 JS 표준을 다루는 MDN Wiki 문서가 있으면 나도 기여해야겠다</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-22T10:40:00.000Z" title="2021-01-22T10:40:00.000Z">21-01-22</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-22T10:48:13.890Z" title="2021-01-22T10:48:13.890Z">21-01-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/NestJs/">NestJs</a></span><span class="level-item">10분안에 읽기 (약 1542 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/jsb-1-nestjs/">NestJS를 사용해야 할 이유</a></h1><div class="content"><p><a href="https://jsqna.com/ejs-1-why-express/">Express를 사용해야 할 이유 (1)</a>을 쓰면서 NestJS는 굉장히 매력적인 대상으로 다가왔다. 이번 글에서는 NestJS를 사용해야 할 이유를 조금 더 자세히 정리하고, NestJS를 간략히 알아본다.</p>
<hr>
<h3 id="NestJS를-사용해야-할-이유"><a href="#NestJS를-사용해야-할-이유" class="headerlink" title="NestJS를 사용해야 할 이유"></a><strong>NestJS를 사용해야 할 이유</strong></h3><p>NestJs만의 장점이 뭐가 있을까? 생각보다 좀 있었는데, 아무래도 Rich Framework의 특징을 많이 갖고 있다.</p>
<table>
<thead>
<tr>
<th>장점</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>CLI</td>
<td>생산성에 도움이 되는 유틸을 제공한다고 한다.</td>
</tr>
<tr>
<td>문서화</td>
<td>자세하고 유지보수가 잘 되는 문서를 갖고 있다고 한다. (타 프레임워크에 비해 기능이 훨씬 많은데도)</td>
</tr>
<tr>
<td>활성화된 개발 팀</td>
<td><a href="https://jsqna.com/ejs-1-why-express/">이전 글</a>에서 알아본 바로 이는 굉장히 특장점이다. (다른 언어에 비해 백엔드가 많이 약하다고 생각함)</td>
</tr>
<tr>
<td>Nest 전용 모듈</td>
<td>Spring처럼 타 라이브러리를 쉽게 사용할 수 있게 전용 모듈을 개발했다. TypeORM, Mongoose, GraphQL, Logging, Validation, Caching, WebSockets 등의 모듈이 있다고 한다.</td>
</tr>
<tr>
<td>MSA를 염두에 둔 설계</td>
<td>(이건 내가 MSA에 대한 이해가 적어서 얼마나 효과적일지 모르겠음.)</td>
</tr>
<tr>
<td>Typescript 채택</td>
<td>(Typescript 경험이 일천해 얼마나 효과적일지 모르겠음.)</td>
</tr>
<tr>
<td>테스트 용이성</td>
<td>프레임워크 핵심 가치에 테스트 용이성이 있고 프레임워크에서 설계를 <u>제공</u>하므로, 다른 프레임워크에 독자적인 설계를 했을 때보다 테스트가 용이할 것으로 <u>기대됨</u>.</td>
</tr>
</tbody></table>
<h4 id="NestJS를-사용하는-기업"><a href="#NestJS를-사용하는-기업" class="headerlink" title="NestJS를 사용하는 기업"></a><strong>NestJS를 사용하는 기업</strong></h4><p>사용하는 기업 목록 중 SW적으로 큰 기업이 없는데 무슨 이유일지 모르겠다. 분명 시장의 선택은 합리적일텐데 정말 선택받지 못한거라면 중요한 문제가 있을 거라는 합리적인 의심을 해볼 만하다.</p>
<hr>
<h3 id="NestJS의-핵심"><a href="#NestJS의-핵심" class="headerlink" title="NestJS의 핵심"></a><strong>NestJS의 핵심</strong></h3><hr>
<h4 id="패러다임"><a href="#패러다임" class="headerlink" title="패러다임"></a><strong>패러다임</strong></h4><p>Typescript를 <u>지원</u>하면서 OOP, FP, FRP(Functional Reactive) 요소를 조합한 백엔드 프레임워크이다.</p>
<blockquote>
<p>Typescript 사용은 강제가 아니다.</p>
</blockquote>
<p>Express, Fastify 를 기반해 개발됐고, NestJs가 윗단으로 추상화 계층을 제공하지만 바로 접근할 수도 있다.</p>
<p>NestJs는 Node.js HTTP 프레임워크 추상화 계층을 구현해놓았기 때문에, Express, Fastify 이외에도 Adapter 패턴을 통해 인터페이스 구현체만 제공한다면 어떤 기술 위에서도 작동할 수 있다고 한다. 아마 Fastify로 이주할 때 개발해 놓은듯하다.</p>
<blockquote>
<p><code>@nestjs/platform-expres</code>, <code>@nestjs/platform-fastify</code> 로 패키지가 분리돼있으니 참고해보면 재밌을 것 같다.</p>
</blockquote>
<p>다만 NestJs에서 Express 생태계가 필요할 것 같지도 않고 Fastify가 훨씬 빠른데 굳이 Express를 기본값으로 해놓은 이유는 모르겠다.</p>
<p>NestJs는 Typescript를 사용하지 않는다면 Babel이 필요하다고 하며 Node.js 10.13버전 미만으로는 지원하지 않는다.</p>
<blockquote>
<p>Typescript가 정확히 어떤 Javascript 버전까지 지원하는지 확인할 수 없었는데 조만간 Typescript를 학습하면서 정리해야겠다.</p>
</blockquote>
<hr>
<h4 id="목표"><a href="#목표" class="headerlink" title="목표"></a><strong>목표</strong></h4><p>프론트 3대 프레임워크 덕분에 개발자 생산성이 향상됐고 빠르고 테스트 가능하고 확장성있는 프론트엔드 개발이 가능해졌는데, 그 외 좋은 라이브러리들이 많지만 애플리케이션 구조, 설계 측면의 문제를 해결하는 프로젝트는 없었다. (이건 Javascript 계열의 특징이라고 생각한다. 아마도 대규모로 개발하는 제품에 Javascript를 쓰지 않기 때문인 것으로 보인다. 요즘은 언어가 많이 좋아졌는데도 말이다.)</p>
<p>NestJs는 애플리케이션 <u>아키텍처를 제공</u>한다(즉 개발자가 결정하는 게 아님). 테스트 가능하고, 확장성 있고, 느슨히 결합되고, 쉽게 유지보수 가능한 설계이다. Angular에서 영감을 받았다. (Angular는 강제성 있는 구조를 제공한다. React는 그 반대이고.)</p>
<hr>
<h3 id="NestJS-Docs-Intro-요약"><a href="#NestJS-Docs-Intro-요약" class="headerlink" title="NestJS Docs Intro 요약"></a><strong>NestJS Docs Intro 요약</strong></h3><p>문서의 내용을 요약했다.</p>
<h4 id="프로젝트-제너레이터"><a href="#프로젝트-제너레이터" class="headerlink" title="프로젝트 제너레이터"></a><strong>프로젝트 제너레이터</strong></h4><p><code>nest new &#123;project_name&#125;</code> 을 입력하면 프로젝트 폴더가 생성된다. (<code>npm i -g @nestjs/cli</code>로 설치되는 CLI 유틸인듯)</p>
<p>기본으로 생성되는 프로젝트 구조는 아래와 같다. 도메인이나 레이어 별로 폴더가 나뉘진 않는 듯하다.</p>
<blockquote>
<p>src</p>
<ul>
<li>app.controller.ts</li>
<li>app.controller.spec.ts</li>
<li>app.module.ts</li>
<li>app.service.ts</li>
<li>main.ts</li>
</ul>
</blockquote>
<p>아래는 Express에서의 파일 역할 비교이다.</p>
<table>
<thead>
<tr>
<th>file</th>
<th>NestJS</th>
<th>Express</th>
</tr>
</thead>
<tbody><tr>
<td>Controller</td>
<td>app.controller.ts</td>
<td>(사용자 나름)</td>
</tr>
<tr>
<td>Service</td>
<td>app.service.ts</td>
<td>(사용자 나름)</td>
</tr>
<tr>
<td>App</td>
<td>app.module.ts</td>
<td>App.js</td>
</tr>
<tr>
<td>Index (진입점)</td>
<td>main.ts</td>
<td>index.js</td>
</tr>
</tbody></table>
<hr>
<h4 id="재밌는-문서-구성"><a href="#재밌는-문서-구성" class="headerlink" title="재밌는 문서 구성"></a><strong>재밌는 문서 구성</strong></h4><p>아래는 몇 개의 하위 문서에 들어갔을 때 맨 위에 보이는 모식도 몇 개를 가져온 것이다.</p>
<p>Spring에서도 제공하지 않는 모식도를 Nest에서 제공하는 게 재밌었는데,</p>
<ol>
<li>개발진들이 정말 OOP를 좋아하는 것 같다고 느껴졌고</li>
<li>그래서 <u>오브젝트</u> 책을 보면서 같이 배우면 재밌을 것 같았고</li>
<li>Spring에 비해 Nest는 확실히 설계를 결정해주는 느낌이 들어서 자신감이 느껴졌고</li>
</ol>
<p>그동안 설계를 <u>정해준</u> 프레임워크는 사용해 본적이 없었는데 받아들이기만 한다면 생산성도 꽤 좋아질 것 같다. 설계 수준 또한 오픈 소스로 개발되니 어느 정도 검증됐을 거라고 생각한다. 따라서 꽤 좋은 학습 경험을 주지 않을까 생각이 든다.</p>
<p><img src="https://docs.nestjs.com/assets/Controllers_1.png" alt="Controller 문서의 모식도"></p>
<p><img src="https://docs.nestjs.com/assets/Components_1.png" alt="Provider 문서의 모식도"><img src="https://docs.nestjs.com/assets/Modules_1.png" alt="Module 문서의 모식도"></p>
<hr>
<p>출처:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.nestjs.com/">NestJS Docs</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://selleo.com/blog/why-choose-nest-js-as-your-backend-framework">Why choose Nest.js as your backend framework? | selleo</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-19T07:20:00.000Z" title="2021-01-19T07:20:00.000Z">21-01-19</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-02-02T12:01:32.770Z" title="2021-02-02T12:01:32.770Z">21-02-02</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/ExpressJs/">ExpressJs</a></span><span class="level-item">21분안에 읽기 (약 3193 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/ejs-1-why-express/">Express를 사용해야 할 이유 (1) - 생태계 조사</a></h1><div class="content"><p>잠시나마 사용해본 Express는 내게 React 같았다. 무엇이든 할 수 있어 보였으나 직접 하기에는 매우 불편하고, 그러다보니 REST API를 작성할 때 이런 것까지 해야 돼? 혹은 이런 기능이 없어서 불편하네 등이 많았는데 이번에 알아보려고 한다. 얼마나 많이 Express를 사용하며, 왜 Express를 사용하는지 팩트 위주로 체크해봤다.</p>
<hr>
<h3 id="1-Node와-Express의-장점을-헷갈리면-안-된다"><a href="#1-Node와-Express의-장점을-헷갈리면-안-된다" class="headerlink" title="1. Node와 Express의 장점을 헷갈리면 안 된다."></a><strong>1. Node와 Express의 장점을 헷갈리면 안 된다.</strong></h3><p>대부분의 웹사이트에서 소개하는 Express의 장점들은 <a target="_blank" rel="noopener" href="https://tsh.io/blog/why-use-nodejs/">Javascript, Node.js의 장점</a>들이었다. 많은 글을 읽어보아도 Express의 장점을 소개하는 글은 많이 없었고 대부분 Node.js의 장점을 소개하고 있었다. </p>
<p>Express가 Node 기반인 게 큰 장점이라는 걸까… 그래서 Node.js와 같은 목적으로 생성된 프레임워크/런타임을 조사해보았다.</p>
<hr>
<h3 id="2-Reactor-Pattern을-구현한-프레임워크-런타임"><a href="#2-Reactor-Pattern을-구현한-프레임워크-런타임" class="headerlink" title="2. Reactor Pattern을 구현한 프레임워크/런타임"></a><strong>2. Reactor Pattern을 구현한 프레임워크/런타임</strong></h3><p><strong>A. 역시 Node.js만 있는 것은 아니었다.</strong> Javascript를 깊게 배우고 생태계를 옮겨 탈 바에 기존에 사용하던 언어로 작업하는 게 현실적이긴하다.</p>
<table>
<thead>
<tr>
<th>Lang</th>
<th>Sync Framework</th>
<th>Async Framework</th>
</tr>
</thead>
<tbody><tr>
<td>Java</td>
<td>Spring Web MVC</td>
<td><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html">Spring WebFlux</a> (<a href="https://jsqna.com/ndp-1-reactor-pattern/">Reactor Pattern</a>), <a target="_blank" rel="noopener" href="https://vertx.io/">Vert.x (JVM 기반)</a></td>
</tr>
<tr>
<td>Python</td>
<td>Flask, Django</td>
<td><a target="_blank" rel="noopener" href="https://github.com/tiangolo/fastapi">FastAPI</a>, <a target="_blank" rel="noopener" href="https://github.com/tornadoweb/tornado">Tornado</a>, <a target="_blank" rel="noopener" href="https://github.com/channelcat/sanic/blob/master/docs/sanic/getting_started.rst">Sanic</a>, … (꽤 많다.)</td>
</tr>
<tr>
<td>Javascript</td>
<td>-</td>
<td>*</td>
</tr>
</tbody></table>
<p>다른 언어에 대해선 찾아보지 않았지만 Java, Python이 점유율이 큰 언어들이므로 충분하다고 생각한다. 벤치마크를 찾아보진 않았지만 같은 패턴을 기반으로 제작됐기 때문에 실제 서비스로 구현했을 땐 성능 면에서도 비슷할 것으로 예상된다.</p>
<p>다만 Node.js의 장점이라면, 선천적으로 비동기 API가 장려되어왔기 때문에 비동기 API로 작성된 라이브러리 활용 면에서 낫지 않을까 생각한다.</p>
<p><img src="https://blog.kakaocdn.net/dn/cvOos4/btqBAVbGq1W/SRBlIXlePKbV9U2k13Kcyk/img.png" alt="Spring Web Flux 구조 - Node.js EventLoop과 유사"></p>
<p>출처: </p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://happyer16.tistory.com/entry/%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EA%B0%90%EB%8B%B9%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-Spring-WebFlux-%EB%8F%84%EC%9E%85">대용량 트래픽을 감당하기 위한 Spring Webflux 도입</a>, </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://devahea.github.io/2019/04/21/Spring-WebFlux%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%81%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A1%9C-%EB%A7%8E%EC%9D%80-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EA%B0%90%EB%8B%B9%ED%95%A0%EA%B9%8C/">Spring Webflux는 어떻게 적은 리소스로 많은 트래픽을 감당할까</a></p>
</li>
</ul>
<hr>
<h3 id="3-Node-js-백엔드-프레임워크-간의-점유율-만족도-비교"><a href="#3-Node-js-백엔드-프레임워크-간의-점유율-만족도-비교" class="headerlink" title="3. Node.js 백엔드 프레임워크 간의 점유율/만족도 비교"></a><strong>3. Node.js 백엔드 프레임워크 간의 점유율/만족도 비교</strong></h3><p>제대로 비교하기 전에 통계 자료부터 확인하자.</p>
<ul>
<li>참고로 <a target="_blank" rel="noopener" href="https://medium.com/weekly-webtips/next-js-on-the-server-side-notes-to-self-e2170dc331ff">Next.js는 SSR 용 백엔드(SSR, Code Splitting 자동)</a>라고 생각하면 된다.</li>
</ul>
<hr>
<p><strong>점유율 요약 (아래 그림):</strong></p>
<ul>
<li>Express의 점유율이 압도적이다.</li>
<li>Koa, Hapi 라는 네임드의 점유율이 꽤 낮다.</li>
<li>서비스 개발에 가장 유리할 거라고 생각했던 Nest.js의 점유율이 13%밖에 안돼서 의문이다.</li>
</ul>
<p><img src="/images/ejs-1/express-1.png" alt="2020 점유율 순위"></p>
<table>
<thead>
<tr>
<th>Hapi</th>
<th>Koa</th>
<th>Nest</th>
<th>Express</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/images/ejs-1/hapi.png"></td>
<td><img src="/images/ejs-1/koa.png"></td>
<td><img src="/images/ejs-1/nest.png"></td>
<td><img src="/images/ejs-1/express.png"></td>
</tr>
</tbody></table>
<p>물론 Express를 기반으로 하는 다른 프레임워크 등이 어느 정도 반영됐을 것이긴 하다. Nest도 처음에는 Express 기반이었으니까. 그래도 다운로드 수의 큰 차이를 보면 나머지 프레임워크의 시장성이 의심되긴 한다.</p>
<hr>
<p><strong>만족도 비교 (아래 그림):</strong></p>
<ul>
<li>Express는 점유율에 이어 만족도도 최상위권이다.</li>
<li>Nest.js가 5% point 정도의 차이가 있지만 준수한 편이다. </li>
<li>Koa의 만족도가 76%인 점인 이유는 장점이었던 동기식 코딩 방식인 async-await이 표준화됐기 때문임으로 보인다.</li>
<li>Hapi는 만족도가 매우 낮은 것으로 보아 사용할 수 없겠다는 생각이 들었다. (추후 조사를 해봐야겠다.)</li>
</ul>
<p><img src="/images/ejs-1/express-2.png" alt="2020 만족도 순위"></p>
<p>출처: <a target="_blank" rel="noopener" href="https://2020.stateofjs.com/ko-KR/technologies/back-end-frameworks/">2020 State Of JS (한국어 번역)</a></p>
<hr>
<h3 id="4-왜-이렇게-Express를-많이-쓰는-걸까"><a href="#4-왜-이렇게-Express를-많이-쓰는-걸까" class="headerlink" title="4. 왜 이렇게 Express를 많이 쓰는 걸까?"></a><strong>4. 왜 이렇게 Express를 많이 쓰는 걸까?</strong></h3><blockquote>
<p>정말 Express가 좋은걸까? </p>
<p>다른 언어의 프레임워크를 비교해봤을 때 솔직히 좋다고 하진 못 할것 같다.</p>
</blockquote>
<hr>
<h4 id="1-단순함-0"><a href="#1-단순함-0" class="headerlink" title="1. 단순함 (+0)"></a><strong>1. 단순함 (+0)</strong></h4><p>정말 많은 블로그에서 Express의 최장점을 단순함으로 꼽고 있었는데 장점보다는 목적에 가까운 것이라 생각한다. 목표에 따라 단순함은 장점이 될 수도, 단점이 될 수도 있기 때문이다. 단순함을 장점으로 꼽는 경우 둘 중 하나이다. </p>
<ul>
<li>Rich Framework를 감당할 만큼 숙련된 개발자로 채우기 어려운 조직이거나</li>
<li>애초에 큰 규모의 서비스를 작성하기 위해 Express를 사용하지 않거나</li>
</ul>
<p>만약 서비스 개발을 위해 Express를 사용한다면 단순함은 직접적인 단점이 된다. </p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/danielfsousa/express-rest-boilerplate">기본적인 의존성만 담은 Boilerplate(1.4k stars)</a>만 보더라도 같이 깔아야 할 라이브러리들이 많아 학습 곡선이 가팔라진다.</p>
</li>
<li><p>처음 입문하는 경우 미들웨어들을 직접 찾는 추가적인 일을 하게 된다. (한 프레임워크 내에서 찾는 것과 대조적.)</p>
</li>
<li><p>Rich Framework 들에 비해 설계를 너무 근본적인 것들부터 해야 해 오히려 설계 측면에선 난도가 높다. (DI/IOC가 없고 여러 라이브러리를 비교 분석 후 사용해야 함.)</p>
</li>
</ul>
<p>다만 적절한 Boilerplate를 찾으면 이 문제가 어느 정도 해소된다는 점과 이후 단락에서 소개할 내용들을 통해 단순함의 단점을 상쇄할 수 있다.</p>
<p>Node.js는 출시 후 아직까지도 작은 서비스를 만드는 데 적합하다는, 프로토 타이핑 위주라는 인식이 남아 있는 것 같고, 그런 용도로 채택하여 단순함이 종종 장점이 되는 것 같기도 하다.</p>
<hr>
<h4 id="2-Express-Middleware-0"><a href="#2-Express-Middleware-0" class="headerlink" title="2. Express Middleware (+0)"></a><strong>2. Express Middleware (+0)</strong></h4><p>어떤 언어, 프레임워크로 웹 개발을 하더라도 Express에 미들웨어에 해당하는 계층에서 확장성을 가져가는 것은 기본이지 특별한 기능은 아니다. 또한 Express에서 제공하던 자체 Middleware들은 모두 <a target="_blank" rel="noopener" href="https://github.com/senchalabs/connect#middleware">Connect 미들웨어 라이브러리</a>로 <a target="_blank" rel="noopener" href="http://expressjs.com/en/guide/migrating-4.html#core-changes">옮겨갔다</a>. <a target="_blank" rel="noopener" href="https://nextjs.org/docs/api-routes/api-middlewares#connectexpress-middleware-support">Next.js에서는 이 미들웨어들을 지원하는데</a>, 그럼 다른 프레임워크에서도 의도하기만 하면 재사용 할 수 있는 셈이다. (의존성이 req, res, next 인자 밖에 없으니.)</p>
<hr>
<h4 id="3-Community-3"><a href="#3-Community-3" class="headerlink" title="3. Community (+3)"></a><strong>3. Community (+3)</strong></h4><p>Express는 꽤 많은 사용자 풀을 보유하고 있다. 이미 사용자가 많아 검색을 통한 문제 해결이 비교적 원활하다.</p>
<p>아래는 <a target="_blank" rel="noopener" href="https://insights.stackoverflow.com/trends?tags=express,nestjs,next.js">StackOverFlow 트렌드</a>인데 koa(js), hapi(js)는 태그로 잡히지도 않아서 비교가 불가능했다. 이는 생태계 조성이 거의 전무하다는 뜻인데 koa나 hapi는 출시된 지 시간이 지났음에도 이정도이며 특히 Hapi는 정말 작은 사용자 풀을 보여준다(사용하지 마세요).</p>
<p><img src="/images/ejs-1/trends-sto.png" alt="StackOverFlow Trends: Express vs Nest vs Next"></p>
<hr>
<h4 id="4-Async-await을-workaround로-쓸-수-있다-1"><a href="#4-Async-await을-workaround로-쓸-수-있다-1" class="headerlink" title="4. Async-await을 workaround로 쓸 수 있다. (+1)"></a><strong>4. Async-await을 workaround로 쓸 수 있다. (+1)</strong></h4><p>Express v5 부터는 Response Handler 및 Middleware에서 async/await을 사용할 수 있지만 아직 Release 되지 않은 관계로 사용할 수는 없다.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/expressjs/express/issues/4256#issuecomment-619616708">Express QnA 이슈의 답변</a>이다.</p>
<p>Q. How to use async/await in express 5?</p>
<p>A: There is one <u>main difference</u> between v4 and v5 when it comes to <u>async/await and promises in general</u>. In v5, if you return a promise from a response handler (or middleware), if that promise rejects and is not handled elsewhere, then Express will handle the error. It handles the rejection by passing the rejection reason to <code>next</code> for you.</p>
</blockquote>
<p>v4에서도 async-await을 쓸 수 있는데, 아주 간단한 미들웨어 <a target="_blank" rel="noopener" href="https://github.com/Abazhenov/express-async-handler">express-async-handler</a>로 한 번 감싸주면 된다. (원리는 <a target="_blank" rel="noopener" href="https://medium.com/@changjoopark/express-%EB%9D%BC%EC%9A%B0%ED%8A%B8%EC%97%90%EC%84%9C-async-await%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A0%A4%EB%A9%B4-7e8ffe0fcc84">이 설명</a> 참고) (같은 원리로 Promise도 처리 가능)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find a user by id</span></span><br><span class="line">router.get(</span><br><span class="line">  <span class="string">&#x27;/:id&#x27;</span>,</span><br><span class="line">  asyncHandler(<span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.user.id === req.params.id) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.status(<span class="number">403</span>).send(FORBIDDEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> UserRepository.findUserById(req.params.id);</span><br><span class="line">    <span class="keyword">if</span> (!user) <span class="keyword">return</span> res.status(<span class="number">404</span>).send(NOT_FOUND);</span><br><span class="line"></span><br><span class="line">    res.json(user);</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="5-Koa나-Express나-둘-다-개발은-하지-않는다-0"><a href="#5-Koa나-Express나-둘-다-개발은-하지-않는다-0" class="headerlink" title="5. Koa나 Express나 둘 다 개발은 하지 않는다. (+0)"></a><strong>5. Koa나 Express나 둘 다 개발은 하지 않는다. (+0)</strong></h4><p>Koa나 Express나 발전을 멈춘지 좀 됐다.</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/koajs/koa/issues/1114">Koa의 Roadmap 3.0</a>을 보면 현재 모습이 Koa의 완성형이라고 생각할 수 있다.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/koajs/koa/tree/7ae9c3e1099688ada21411a350d2b50dae629388">17년도 이후로 유지보수</a>가 대부분 Documentation에 치중되어 있다.</p>
</li>
</ul>
<p>KoaJS는 <a target="_blank" rel="noopener" href="https://github.com/koajs/koa/tree/8ee8abcc3268189c3f44abfb64d42903a87c4d5e">2013년에 시작</a>해 제너레이터 기반으로 미들웨어를 쉽게 작성하기 위해 나온 프레임워크인데, async-await 표준이 2017년 초부터 Node.js에서 공식적으로 지원되면서 그 의미가 퇴색되지 않았나 생각이 든다.</p>
<p>Express 역시 Documentation 위주의 유지보수, v5를 6-7년 째 안 내고 있긴 하다. (14, 15년도 쯤까지만 일한듯)</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/expressjs/express/issues/2844">Is express dying?</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/expressjs/express/pull/2237">Release v5</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/pillarjs/router">Router 모듈</a> (Express가 라우팅 관련 책임을 이 모듈로 넘긴 듯하다.) (얘도 유지보수가 죽었고.)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://nodejs.org/en/blog/announcements/foundation-express-news/">Node.js Foundation to Add Express to its Incubator Program</a> 16년 초에 Express 소유권이 넘어갔다고 한다.(인과관계는 잘x)</p>
</li>
</ul>
<hr>
<h3 id="5-서비스-개발-측면에선-NestJs가-더-낫지-않을까-추후-보강-예정"><a href="#5-서비스-개발-측면에선-NestJs가-더-낫지-않을까-추후-보강-예정" class="headerlink" title="5. 서비스 개발 측면에선 NestJs가 더 낫지 않을까? (추후 보강 예정)"></a><strong>5. 서비스 개발 측면에선 NestJs가 더 낫지 않을까? (추후 보강 예정)</strong></h3><p>Express, Koa는 현재 사실상 유지보수가 되고 있지 않다. 프로젝트에서 돈을 벌지 못하기 때문인 것으로 보이는데, 기업 스폰서가 없으며 프레임워크도 간단해 기술 지원이 불가능해 수익 모델이 없다. (Hapi는 Walmart에서 사용 중이긴 하지만 너무 마이너하다. 왜 인기가 없을까?)</p>
<p>NestJS는 구조가 Angular의 영향을 받았다고 돼있지만 Spring과 유사한 구조와 개발자 경험을 제공한다고 생각하며, Spring은 그 기능과 복잡성을 통해 기술 지원으로 돈을 벌고 있기 때문에 NestJS가 이 모델을 구현한다면 긴 시간 유지보수를 해나갈 수 있을 것 같다.</p>
<hr>
<p>정확히 무슨 벤치마크를 했는진 모르겠지만 성능 측면에서 NestJs-Fasitfy[현재 버전]가 Express보다 낫다고 한다. (<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/47733390/nestjs-vs-plain-express-performance">출처</a>)</p>
<table>
<thead>
<tr>
<th>Framework</th>
<th>Req/sec</th>
<th>Trans/sec</th>
<th>Req/sec DIFF</th>
<th>Trans/sec DIFF</th>
</tr>
</thead>
<tbody><tr>
<td>Nest-Express</td>
<td>15370</td>
<td>3.17MB</td>
<td>+4.38%</td>
<td>+4.23%</td>
</tr>
<tr>
<td>Nest-Fastify</td>
<td>30001</td>
<td>4.38MB</td>
<td>+2.20%</td>
<td>+2.23%</td>
</tr>
<tr>
<td>Express</td>
<td>17208</td>
<td>3.53MB</td>
<td>+8.38%</td>
<td>+8.31%</td>
</tr>
<tr>
<td>Fastify</td>
<td>33578</td>
<td>4.87MB</td>
<td>+6.55%</td>
<td>+6.53%</td>
</tr>
</tbody></table>
<p>NestJS에 대해선 추후 더 조사하려고 한다.</p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><h4 id="1-NestJS"><a href="#1-NestJS" class="headerlink" title="1. NestJS"></a><strong>1. NestJS</strong></h4><p>NestJS는 다루는 양이 방대하기도 하고 앞의 리서치에서 시간을 너무 많이 사용해서 따로 시간을 내서 리서치하진 못 해서 다음 기회에 꼭 하도록 한다.</p>
<h4 id="2-Fasify"><a href="#2-Fasify" class="headerlink" title="2. Fasify"></a><strong>2. Fasify</strong></h4><p>한 번 조사해봐야 할 것 같다. async-await도 지원하며 제대로 관리되고 있는 것 같다.</p>
<p>아래는 <a target="_blank" rel="noopener" href="https://github.com/fastify/fastify">README에 게시된 벤치마크</a>인데 성능도 역시 좋고.</p>
<table>
<thead>
<tr>
<th>Framework</th>
<th>Version</th>
<th>Router?</th>
<th>Requests/sec</th>
</tr>
</thead>
<tbody><tr>
<td>Express</td>
<td>4.17.1</td>
<td>✓</td>
<td>15,978</td>
</tr>
<tr>
<td>hapi</td>
<td>19.1.0</td>
<td>✓</td>
<td>45,815</td>
</tr>
<tr>
<td>Restify</td>
<td>8.5.1</td>
<td>✓</td>
<td>49,279</td>
</tr>
<tr>
<td>Koa</td>
<td>2.13.0</td>
<td>✗</td>
<td>54,848</td>
</tr>
<tr>
<td><strong>Fastify</strong></td>
<td><strong>3.0.0</strong></td>
<td><strong>✓</strong></td>
<td><strong>78,956</strong></td>
</tr>
<tr>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>http.Server</code></td>
<td>12.18.2</td>
<td>✗</td>
<td>70,380</td>
</tr>
</tbody></table>
<h4 id="3-HapiJS"><a href="#3-HapiJS" class="headerlink" title="3. HapiJS"></a><strong>3. HapiJS</strong></h4><p>Hapi도 개발이 계속 진행 중이고 Nest처럼 Rich한 Framework를 목표로 하는 것 같고, Walmart에서 실제로 사용하면서 주도적으로 개발하다가 작년 중순부터 <a target="_blank" rel="noopener" href="https://github.com/hapijs/hapi/issues/4113">Community-driven으로 간다고 한다</a>. 성장 가능성이 꽤 있는 것 같아서 시간이 나면 조사하면 좋을 것 같다. Facebook이 React를 만들어 프론트엔드 생태계를 많이 바꿔낸 것처럼.</p>
<h4 id="4-Express-In-Action-2016"><a href="#4-Express-In-Action-2016" class="headerlink" title="4. Express In Action (2016)"></a><strong>4. Express In Action (2016)</strong></h4><p>이 책을 좀 더 읽어보고 Express의 가치를 발견하다면 정말 좋을 것 같다.</p>
<h4 id="5-기타"><a href="#5-기타" class="headerlink" title="5. 기타"></a><strong>5. 기타</strong></h4><p>Promise, Async-await이 성능이 CPS 패턴에 비해 느리다는 의견이 종종 나왔는데 왜 그런지 확인해보기</p>
<p>D2에서 Node.js는 Socket.IO 때문에 떴다고 하던데 정말인지 확인해보기</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T10:55:00.000Z" title="2021-01-15T10:55:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">7분안에 읽기 (약 1070 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-generator/">Javascript의 Generator</a></h1><div class="content"><p>이 글은 자바스크립트의 제너레이터 문법에 대해 간략히 소개한다.</p>
<hr>
<h3 id="정의"><a href="#정의" class="headerlink" title="정의"></a><strong>정의</strong></h3><p>JavaScript의 제너레이터는 <code>function*</code> 으로 정의된 제너레이터 함수가 반환한 객체이다. 이 객체는 이터레이터(iterator)이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo()로 생성된 제너레이터를 순회하며 값을 읽어간다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-객체와-함수-팩토리"><a href="#Generator-객체와-함수-팩토리" class="headerlink" title="Generator 객체와 함수(팩토리)"></a><strong>Generator 객체와 함수(팩토리)</strong></h3><p><u>제너레이터 함수</u>를 호출하면 <u>제너레이터 객체</u>를 반환하고 끝난다.</p>
<p>제너레이터 객체의 <code>next(...args)</code>를 통해 제너레이터의 본문을 일정 부분 실행할 수 있다.</p>
<ul>
<li>이터레이터는 <code>next()</code> 함수로 파라미터를 전달할 수 없다.</li>
<li>제너레이터가 값을 읽을 수 있기 때문에 <u><strong>협력적 멀티 태스킹</strong></u>이 가능하다.</li>
</ul>
<h3 id="Generator-기반-협력적-멀티-태스킹"><a href="#Generator-기반-협력적-멀티-태스킹" class="headerlink" title="Generator 기반 협력적 멀티 태스킹"></a><strong>Generator 기반 협력적 멀티 태스킹</strong></h3><p>협력적 멀티 태스킹은 코루틴에 나오는 개념이다. (추후 정리할 예정이다.)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">go(<span class="function"><span class="keyword">function</span>* <span class="title">producer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> write(i);</span><br><span class="line">    <span class="keyword">yield</span> sleep(<span class="number">100</span>); <span class="comment">// -- sleep이 가능해진다!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">go(<span class="function"><span class="keyword">function</span>* <span class="title">consumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> v;</span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    <span class="keyword">typeof</span> (v = <span class="keyword">yield</span> read()) !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;read:&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>이 코드의 <code>go</code>와 같은 함수를 <strong>제너레이터 실행기</strong>라고 한다. <code>co</code> 라이브러리가 훌륭한 제너레이터 실행기를 제공한다.</p>
<p>제너레이터 실행기는 원래 동기적으로 수행되는 제너레이터를 비동기 호출을 수행하게 만든 다음 callback을 통해 다시 제너레이터를 호출하게끔 하여 비동기 코드를 동기 코드처럼 작성할 수 있게 하는 목적의 함수이다.</p>
<h3 id="제너레이터-실행기"><a href="#제너레이터-실행기" class="headerlink" title="제너레이터 실행기"></a><strong>제너레이터 실행기</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 제너레이터 실행기</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grun</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> it = g();</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x = it.next(val);</span><br><span class="line">    <span class="keyword">if</span> (!x.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        x.value</span><br><span class="line">          .then(iterate)</span><br><span class="line">          .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> it.throw(err));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(iterate, <span class="number">0</span>, x.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 실행기를 사용한 모습.</span></span><br><span class="line"><span class="comment">// 꽤 async-await과 같이 가독성이 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">theFutureIsNow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    data = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;a.txt&#x27;</span>),</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;b.txt&#x27;</span>),</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;c.txt&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;Unable to read one or more input files: &#x27;</span> +</span><br><span class="line">        err.message,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> ptimeout(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> nfcall(</span><br><span class="line">      fs.writeFile,</span><br><span class="line">      <span class="string">&#x27;d.txt&#x27;</span>,</span><br><span class="line">      data[<span class="number">0</span>] + data[<span class="number">1</span>] + data[<span class="number">2</span>],</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;Unable to write output file: &#x27;</span> +</span><br><span class="line">        err.message,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-직접-만들어보기"><a href="#Generator-직접-만들어보기" class="headerlink" title="Generator 직접 만들어보기"></a><strong>Generator 직접 만들어보기</strong></h3><p>자료 중 재밌는 것이 있었다: <a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/babel%EC%9D%80-generator%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%82%98-c78523645cd7">Babel은 Generator를 어떻게 바꾸나</a>. 지금 나한테는 바로 이해하긴 어렵다. 직접 만들어보면 이해에 큰 도움이 될 듯 하다.</p>
<h3 id="Generator의-단점-Iterable은-가변-인자가-아니다"><a href="#Generator의-단점-Iterable은-가변-인자가-아니다" class="headerlink" title="Generator의 단점: Iterable은 가변 인자가 아니다"></a><strong>Generator의 단점: Iterable은 가변 인자가 아니다</strong></h3><p>제너레이터 객체는 위에서 말했듯 Iterable이지만, 이는 <u><strong>가변 인자와는 달라</strong></u>서, Math.min같은 함수를 이용할 때 spead 연산자로 배열로 만들어 넘겨야 하므로, 인자 전달 부분에서 아쉽다고 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 객체만 넘길 순 없음.</span></span><br><span class="line"><span class="comment">// 굳이 제너레이터 객체를 넘길거면, 받는 함수 입장에서 이터레이터를 써야 할 듯?</span></span><br><span class="line"><span class="comment">// for-of 문으로.</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// spread 연산자로 넘겨줘야 함.</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...foo());</span><br></pre></td></tr></table></figure>
<h3 id="Generator의-콜-스택"><a href="#Generator의-콜-스택" class="headerlink" title="Generator의 콜 스택?"></a><strong>Generator의 콜 스택?</strong></h3><blockquote>
<p>Calling <code>.next()</code> method just pushes that call on the top of the stack. It will then run the code inside the generator function.</p>
<p><strong><u>difference</u></strong>: it has to remember the state of all local variables, but engines already know how to do that from the implementation of closures. A generator call will restore the state so that it can continue where it left off.</p>
</blockquote>
<p>일반적인 콜 스택과 동일하다고 한다. 다만 제너레이터 내에서 제너레이터를 호출하는 경우 복잡하다고 하는데, 거기까지 알 필요는 없을 듯 하다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48873128/javascript-stack-model-for-generators">Javascript stack model for generators | StackOverFlow</a></p>
<p>출처: <a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%9E%AC%EB%AF%B8-246553cadfbd">Javascript Generator의 재미 (2016.12)</a></p>
<p>출처: Learning Javascript, O Reilly</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><strong>TODO</strong>:</h3><p>부족한 내용 보충하기. 제너레이터가 개념 뿐 아니라 사용이 중요한 개념이어서 정리가 난잡한데 다음주 중으로 정리하려고 한다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T10:54:00.000Z" title="2021-01-15T10:54:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">3분안에 읽기 (약 426 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-promise-all/">Promise.all은 Parallel로 실행되는가?</a></h1><div class="content"><p>Javascript의 모든 코드는 이벤트 루프에서 처리된다. 그리고 Node.js의 이벤트 루프 구현체로 libuv가 사용 된다는 사실은 널리 알려져 있다. 그런데 이상하지 않은가?</p>
<h3 id="Promise-all은-Parallel로-실행되는가"><a href="#Promise-all은-Parallel로-실행되는가" class="headerlink" title="Promise.all은 Parallel로 실행되는가?"></a><strong>Promise.all은 Parallel로 실행되는가?</strong></h3><p>이벤트 루프 모델을 이해했다면 자바스크립트에 병렬 실행은 없다는 것을 이해했을 것이다. 파일, 네트워크 I/O는 자바스크립트 코드가 직접 처리하는 것이 아니고, 콜백은 이벤트 루프에 의해 호출되어 순차적으로 실행된다.</p>
<blockquote>
<p>그럼, Promise.all은 어떤가?</p>
</blockquote>
<p>음… 애초에 자바스크립트 코드가 병렬적으로 실행될 수 있는가?</p>
<h4 id="Promise-all을-잘-몰라서-생긴-일"><a href="#Promise-all을-잘-몰라서-생긴-일" class="headerlink" title="Promise.all을 잘 몰라서 생긴 일"></a><strong>Promise.all을 잘 몰라서 생긴 일</strong></h4><p><code>Promise.all</code>은 Promise의 호출 순서와는 전혀 관계가 없다. Promise의 기본 동작을 하나도 건드리지 않는다.</p>
<p>Promise.all이 제공하는 기능이란, 트랜잭션과 같이 하나라도 실패하면 catch 훅으로 넘어가게 하는 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3, p4, p5])</span><br><span class="line">  .then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="오히려-순차적으로-Promise를-실행하는-것이-더-특별하다"><a href="#오히려-순차적으로-Promise를-실행하는-것이-더-특별하다" class="headerlink" title="오히려 순차적으로 Promise를 실행하는 것이 더 특별하다."></a><strong>오히려 순차적으로 Promise를 실행하는 것이 더 특별하다.</strong></h4><p><code>reduce</code>를 사용해 <code>iterable.reduce((p, fn) =&gt; p.then(fn), Promise.resolve())</code>로 순차적으로 실행시킬 수 있다. (웬만하면 <code>then</code>으로 직접 잇겠지만.)</p>
<p><a href="https://jsqna.com/js-async-1">Async Functions in Javascript 1</a>를 참고해도 좋을 것 같다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://medium.com/@sandeepv68/how-does-promise-all-works-internally-978ee82f3348">How does Promise.all all works interanlly</a></p>
<p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30823653/is-node-js-native-promise-all-processing-in-parallel-or-sequentially">Is Node.js native Promise.all processing in parallel or sequentially? | StackOverFlow</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T09:05:00.000Z" title="2021-01-15T09:05:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">3분안에 읽기 (약 385 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-event-loop-browser-vs-node/">이벤트 루프는 환경마다 다를까?</a></h1><div class="content"><p>Javascript의 모든 코드는 이벤트 루프에서 처리된다. 그리고 Node.js의 이벤트 루프 구현체로 libuv가 사용 된다는 사실은 널리 알려져 있다. 그런데 이상하지 않은가?</p>
<blockquote>
<p>왜 Node.js를 설명할 때 이벤트 루프의 <u>구현체</u>라며 따로 소개하는 걸까?</p>
</blockquote>
<p>과연 브라우저 상의 이벤트 루프와 Node.js의 이벤트 루프는 동일하다고 생각해도 될까?</p>
<p>이벤트 루프 <u>구현체가 다르다</u>는 것을 어떻게 생각하면 좋을까?</p>
<hr>
<h3 id="원인은-환경-차이"><a href="#원인은-환경-차이" class="headerlink" title="원인은 환경 차이"></a><strong>원인은 환경 차이</strong></h3><p>이벤트 루프의 처리 방식은 스펙으로 결정돼있지만 벤더마다 약간씩 다르게 구현하는 부분이 있다고 한다. Node.js 또한 예외는 아니다.</p>
<table>
<thead>
<tr>
<th>기능</th>
<th>브라우저</th>
<th>NodeJs</th>
</tr>
</thead>
<tbody><tr>
<td>File, Network I/O</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Event의 종류</td>
<td>Mouse, Keyboard Events</td>
<td>File, Network I/O</td>
</tr>
<tr>
<td>이벤트 루프 구현체</td>
<td><a target="_blank" rel="noopener" href="https://libevent.org/">libevent</a> (크롬 기준)</td>
<td><a target="_blank" rel="noopener" href="https://libuv.org/">libuv</a></td>
</tr>
<tr>
<td>자바스크립트 엔진</td>
<td>V8 (크롬 기준)</td>
<td>V8</td>
</tr>
<tr>
<td>process.nextTick (process 모듈 자체 API)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>setImmediate (<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate">ECMA 표준 아님</a>)</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>위 표 이외에 처리 순서의 차이가 약간 있긴 하지만 Node v11부터는 그 차이마저 적은 편이다.</p>
<blockquote>
<p><em>결론: 환경의 차이 때문에 약간의 구현 상의 차이가 있다 정도로 받아들이자.</em></p>
</blockquote>
<p>출처: <a target="_blank" rel="noopener" href="https://blog.insiderattack.net/javascript-event-loop-vs-node-js-event-loop-aea2b1b85f5c">JavaScript Event Loop vs Node JS Event Loop</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T06:45:00.000Z" title="2021-01-15T06:45:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">9분안에 읽기 (약 1381 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-license/">Javascript의 라이센스</a></h1><div class="content"><p>이 글은 자바스크립트의 라이센스 - 소유권과 결정권에 대한 내용과 근거를 찾아 정리한 글이다.</p>
<hr>
<h3 id="1-Javascript의-라이센스"><a href="#1-Javascript의-라이센스" class="headerlink" title="1. Javascript의 라이센스"></a><strong>1. Javascript의 라이센스</strong></h3><p>Javascript 이해관계자는 크게 언어 명세을 결정하는 쪽과 언어를 개발하는 쪽으로 나뉜다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>소유자</th>
<th>라이센스</th>
<th>생명 주기</th>
</tr>
</thead>
<tbody><tr>
<td>언어 명세(ECMA 262)</td>
<td>TC39</td>
<td>수정 하지 않는 선에서 사용 가능</td>
<td>매년</td>
</tr>
<tr>
<td>런타임(SW)</td>
<td>각 벤더</td>
<td>개별적으로 다름</td>
<td>상시 업데이트</td>
</tr>
</tbody></table>
<p>재밌는 점은 TC39에 벤더들이 참여한다는 점이다.</p>
<p>Trademark(유사 상표권)는 Oracle에 있는데, <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/135905/legal-ramifications-of-use-of-the-javascript-trademark">명칭하는 데 사용하는 것은 문제가 되지 않는다</a>고 한다.</p>
<p>언어 명세(구현 코드가 아님)은 ECMA International(TC39의 상위 개념)에서 제정한다. 언어 표준의 라이센스는 <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/238724/what-license-is-html-released-under">이 글 | StackExchange</a>을 참고</p>
<p>언어 - 인터프리터, 컴파일러, 런타임 - 구현의 몫은 각 벤더사에 있으며 벤더사가 적용하는 라이센스에 따라 각자 라이센스를 가질 수 있다.</p>
<p>아래는 역사를 요약 설명한 내용이다.</p>
<blockquote>
<p>in 1995, Netscape decided to add a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scripting_language">scripting language</a> to Navigator. They pursued two routes to achieve this: collaborating with <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems</a> to embed the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Programming_language">programming language</a>, while also hiring <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Brendan_Eich">Brendan Eich</a> to embed the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> language.</p>
<p>Netscape management soon decided that the best option was for Eich to devise a new language, with syntax similar to Java and less like Scheme or other extant scripting languages. Although the new language and its <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a> implementation were officially called LiveScript when first shipped as part of a Navigator release in September 1995, the name was changed to JavaScript three months later.</p>
</blockquote>
<p>1995: Netscape Navigator라는 브라우저의 기능으로 스크립트 언어를 내장하기로 개발</p>
<blockquote>
<p>In November 1996, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netscape">Netscape</a> submitted JavaScript to <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ecma_International">ECMA International</a>, as the starting point for a standard specification that all browser vendors could conform to. This led to the official release of the first <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a> language specification in June 1997.</p>
</blockquote>
<p>1996: Netscape -&gt; ECMA International로 소유권 이양 (이후 특정 기업의 소유는 아니게 됨)</p>
<p>출처: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JavaScript">Javascript | Wikipedia</a></p>
<h3 id="2-TC39-소개"><a href="#2-TC39-소개" class="headerlink" title="2. TC39 소개"></a><strong>2. TC39 소개</strong></h3><blockquote>
<p>Ecma International’s TC39 is a group of JavaScript developers, implementers, academics, and more, collaborating with the community to maintain and evolve the definition of JavaScript.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://tc39.es/">TC39</a>에서는 미팅 회의록을 공개하는데, <a target="_blank" rel="noopener" href="https://github.com/tc39/notes/blob/master/meetings/2020-11/nov-16.md">최근 미팅</a>을 보니 주요 브라우저 벤더사만 참여하는 것은 아니고 회의마다 여러 주체나 외부 인사도 참여하는 듯 하다. TC39에서 Javascript의 스펙을 결정한다고 한다.</p>
<blockquote>
<p>This Standard defines the ECMAScript 2021 general-purpose programming language.</p>
</blockquote>
<p>TC39는 <a target="_blank" rel="noopener" href="https://tc39.es/ecma262/">가장 최신의 Javascript 스펙 문서</a>를 온라인으로 유지한다. 현재는 ECMAScript 2021이며 이 문서는 Living Standard로 주기적으로 갱신되는 듯하다.</p>
<p>TC39이 표준을 제정하는 방식에 대해선 <a target="_blank" rel="noopener" href="https://ahnheejong.name/articles/ecmascript-tc39/">ECMAScript와 TC39 | ahn.heejong</a>을 참고하라.</p>
<h3 id="3-WHATWG-소개"><a href="#3-WHATWG-소개" class="headerlink" title="3. WHATWG 소개"></a><strong>3. WHATWG 소개</strong></h3><blockquote>
<p>The WHATWG was formed in response to the slow development of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium">World Wide Web Consortium</a> (W3C) <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Web_standards">Web standards</a> (…) On 28 May 2019, the W3C announced that WHATWG would be the sole publisher of the HTML and DOM standards.</p>
</blockquote>
<p>WHATWG는 W3C이 제정하는 표준 중 HTML, DOM 표준을 독자적으로 제정하는 그룹이다. WHATWG는 주요 브라우저 벤더로 구성된다. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HTML5#W3C_and_WHATWG_conflict">자세한 내용</a></p>
<p>WHATWG에서 제정한 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/introduction.html">HTML 5 스펙</a>은 HTML 뿐만 아니라 - HTML5라고 해서 HTML만을 다루지는 않는다 - (현대) 웹 기술의 전반에 대해 표준화된 문서이다.</p>
<h3 id="4-번외-구글은-왜-Chrome-V8을-오픈소스화했을까"><a href="#4-번외-구글은-왜-Chrome-V8을-오픈소스화했을까" class="headerlink" title="4. 번외: 구글은 왜 Chrome, V8을 오픈소스화했을까?"></a><strong>4. 번외: 구글은 왜 Chrome, V8을 오픈소스화했을까?</strong></h3><blockquote>
<p>[Chromium Release Announcement 발췌]</p>
<p>With a richer set of APIs we can build more interesting apps allowing people to do more online. The more people do online, the more they can use our services. […]</p>
<p>We believe that open source works not only because it allows people to join us and improve our products, but also (and more importantly) because it means other projects are able to use the code we’ve developed.</p>
</blockquote>
<blockquote>
<p>[StackExchange 답변 중]</p>
<p>they just needed the web as a whole to become more attractive. Their decision to open-source V8 led to one such effect: the NodeJS system was built on V8 … The web has become so attractive as a development environment that it is even displacing native apps, e.g. Electron is based on Chromium.</p>
</blockquote>
<p>공유되는 일부 내용을 정리해보자면, 크롬을 통해 구글은 웹 시장을 키우고 싶었고, 오픈소스화(2008)로 웹의 기능을 늘리고 늘어난 기능이 널리 퍼지는 것을 유도했다(다른 크로미움 기반 브라우저를 통해). 오픈소스를 활용해 크롬을 개발했으며, V8기반의 NodeJS(2011)를 통해 Javascript 생태계가 커졌다. (숙련된 개발자가 많아질 수 있는 환경 조성)</p>
<p>출처: <a target="_blank" rel="noopener" href="https://opensource.stackexchange.com/questions/10644/why-did-google-make-chromium-open-source">Why did Google make Chromium Open Source? | StackExchange</a></p>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><strong>TODO</strong>:</h4><p><em>Q. Netscape은 왜 넘겼을까? 돈이 안 돼서 그런걸까? 독자적인 기능으로 탑재했다면 더 성공할 수 있지 않았을까?</em></p>
<p><em>Q. 굳이 <u>오픈소스화</u> 하지 않아도 경쟁을 통해 기능은 늘어났을 것이고 크롬 출시연도인 2009년에 이미 2위 브라우저로 시작해 2012년엔 1위 브라우저가 됐는데 오픈 소스화가 여기서 얼마나 큰 역할을 했는지는 잘 모르겠다. 좀 더 찾아봐야 할 듯.</em></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-11T11:00:00.000Z" title="2021-01-11T11:00:00.000Z">21-01-11</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-25T11:21:13.860Z" title="2021-01-25T11:21:13.860Z">21-01-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">13분안에 읽기 (약 1935 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-async-1/">JS Async Functionality 1 - Intro</a></h1><div class="content"><p>이 글은 자바스크립트에서 비동기를 다룰 때 마주치는 개념들인 Promise, Generator, Async-Await을 큰 범위에서 다룬다. 중간 중간에 재밌는 패턴들도 수록했다.</p>
<hr>
<h3 id="Why-Promise"><a href="#Why-Promise" class="headerlink" title="Why Promise?"></a><strong>Why Promise?</strong></h3><blockquote>
<p><strong><u>What’s Promise?</u></strong><br>Promise는 순차적인 비동기 코드를 깔끔하게 짤 수 있게 하는 문법이다. 문법에 포함된 <code>Promise 객체</code>로 처리한다. Promise로 거의 모든 비동기를 처리한다고 해도 과언이 아니다.</p>
<p>Promise가 익숙하지 않다면 MDN을 참고:<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a> &gt; <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises</a></p>
</blockquote>
<p>비동기 작업 시 순차적인 흐름을 많이 구현해야 하는데, <u>CPS 방식으론 간결하게 짤 수 없다</u>. <a href="https://jsqna.com/ndp-3-cps-tips/">CPS 패턴 사용 시의 Tip | JSQnA</a> 참고.</p>
<p><strong>Promise의 장점</strong>: (콜백과 관련한 비교에 대한 내용은 <a href="https://jsqna.com/ndp-2-cps/">CPS 패턴</a> 참고.)</p>
<ul>
<li>프로미스 체인을 사용하면 작업들을 순차 실행시키는 일은 그리 어렵지 않다.</li>
<li><code>throw</code>를 프로미스 체인에서 사용할 수 있다.</li>
<li>catch 될 때까지 전체 체인에 오류를 자동으로 전파할 수 있다. 비동기 오류가 누락될 확률이 줄어든다.</li>
<li>동기적으로 값을 반환해도 비동기적인 호출을 보장한다. 함수가 동기, 비동기 반환을 섞어서 하는 것은 나쁘다.</li>
<li><code>Promise.all</code> 함수를 통해 비동기 작업을 병렬로 실행할 수 있다. (이건 CPS도 가능)</li>
<li><code>Promise.race</code> 함수를 통해 비동기 작업 중 가장 먼저 수행이 끝난 결과만 사용할 수 있다. (CPS에선 직접 구현해야 함.)</li>
</ul>
<p><strong>Promise로 함수 배열을 순차적으로 실행하는 패턴</strong> (현재 이해 부족으로 인해 수정 필요함.):</p>
<p>책에 재밌는 코드가 있어 가져왔다. Promise로 함수의 배열을 순차적으로 실행하는 방법이 있을까?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sequential :: Array(() =&gt; Promise) =&gt; Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequential</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 빈 값을 반환하는 Promise를 생성한다.</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  tasks.forEach(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// promise에 then으로 체인을 걸고,</span></span><br><span class="line">    <span class="comment">// 다음 순번의 &#x27;이전 작업&#x27;이 되기 위해 promise 변수로 할당한다.</span></span><br><span class="line">    <span class="comment">// UPDATE: task는 Promise를 반환하는 함수여야 한다.</span></span><br><span class="line">    promise = promise.then(task);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 최종 Promise를 반환한다.</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reduce로도 가능하다:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> promise = tasks.reduce(</span><br><span class="line">  (prev, task) =&gt; prev.then(task),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> retreive result</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>제한된 개수로 병렬 실행하기</strong>: (현재 이해 부족으로 인해, 추후 삽입 예정)</p>
<hr>
<h3 id="ES8-비동기-함수"><a href="#ES8-비동기-함수" class="headerlink" title="ES8 비동기 함수"></a><strong>ES8 비동기 함수</strong></h3><p>정의에 대한 자세한 내용은 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN async function</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">MDN AsyncFunction 생성자</a>를 참고하라.</p>
<p>ES7 비동기 함수는 비동기적으로 동작하는, <code>async</code>, <code>await</code> 문법이 활용된 함수이다.</p>
<p>(설명 보충 예정.)</p>
<hr>
<h3 id="Why-Generator"><a href="#Why-Generator" class="headerlink" title="Why Generator?"></a><strong>Why Generator?</strong></h3><blockquote>
<p><u><strong>What’s Generator?</strong></u></p>
<p>Generator는 시작 지점이 여러 개이며 중간에 실행을 정지/재개할 수 있는 함수이다.</p>
<ul>
<li><u>시작 지점이 여러 개</u>: 다른 시작 지점에 대해 매번 새로운 arguments로 호출할 수 있다.</li>
<li><u>정지/재개할 수 있다</u>: 제너레이터 함수는 실행 후 값을 반환할 때 정지한다. 이후 호출하면 다시 재개된다.</li>
</ul>
<p>Generator가 익숙하지 않다면 MDN을 참고:</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function</a>*</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator</a></p>
<p>시작하기 전에 아래 두 코드의 결과를 모르겠다면 이후 내용을 이해하기 어려우므로, Generator에 대해 추가적으로 공부를 하기 바란다.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator Example 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fruitGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;watermelon&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFruitGenerator = fruitGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator Example 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iteratorGenerator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = iteratorGenerator([</span><br><span class="line">  <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;orange&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;watermelon&#x27;</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">let</span> currentItem = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!currentItem.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(currentItem.value);</span><br><span class="line">  currentItem = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Generator-with-CPS-into-Async-Await"><a href="#Generator-with-CPS-into-Async-Await" class="headerlink" title="Generator with CPS into Async-Await:"></a><strong>Generator with CPS into Async-Await:</strong></h4><p>놀랍게도 Generator에 약간의 양념을 치면 ES7 비동기 함수를 만들어낼 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터로 비동기 흐름을 구현하는 방법이다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFlow</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// callback 함수는 비동기 함수에 CPS 패턴으로 넘겨져서, 결괏값으로 다시 제너레이터를 호출하는 데 사용된다.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> generator.throw(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> results = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    generator.next(</span><br><span class="line">      results.length &gt; <span class="number">1</span> ? results : results[<span class="number">0</span>],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> generator = generatorFunction(callback);</span><br><span class="line">  generator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncFlow, callback을 감추고, yield를 await으로 바꾼다면 async-await과 같은 문법을 지닌다.</span></span><br><span class="line">asyncFlow(<span class="function"><span class="keyword">function</span>* (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fileName = path.basename(__filename);</span><br><span class="line">  <span class="keyword">const</span> myself = <span class="keyword">yield</span> fs.readFile(</span><br><span class="line">    fileName,</span><br><span class="line">    <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">yield</span> fs.writeFile(</span><br><span class="line">    <span class="string">`clone_of_<span class="subst">$&#123;fileName&#125;</span>`</span>,</span><br><span class="line">    myself,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Clone created&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a><strong>try-catch</strong></h4><p>Async-Await과 유사하게, 제너레이터에는 <code>throw</code> API가 있는데, 제너레이터 함수 내에서 <code>try-catch</code>로 이를 처리할 수 있다:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> twoWay = twoWayGenerator();</span><br><span class="line">twoWay.next(args); <span class="comment">// args를 전달</span></span><br><span class="line">twoWay.throw(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">// throw로 Error 객체 전달. 제너레이터 함수 내의 catch 절로 이동하게 된다.</span></span><br></pre></td></tr></table></figure>
<p>참고자료 전문: <a target="_blank" rel="noopener" href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2">Async-Await ≈ Generators + Promises</a></p>
<p>참고 2: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36196608/difference-between-async-await-and-es6-yield-with-generators">Difference between async/await and ES6 yield with generators | StackOverFlow</a></p>
<p>참고 3: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31483342/es2017-async-vs-yield">ES2017 - Async vs. Yield | StackOverFlow</a></p>
<hr>
<h4 id="하나의-API로-CPS와-Promise-모두-지원하는-방법"><a href="#하나의-API로-CPS와-Promise-모두-지원하는-방법" class="headerlink" title="하나의 API로 CPS와 Promise 모두 지원하는 방법"></a><strong>하나의 API로 CPS와 Promise 모두 지원하는 방법</strong></h4><p><u>mongoose</u>와 같은 많은 라이브러리는 CPS와 Promise 방식을 모두 지원한다. 어떻게 한 함수로 동시에 지원할 수 있을까? 아래 코드와 같이 구현한다면 가능하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 마지막 인자로 callback 함수를 받는다.</span></span><br><span class="line"><span class="comment">// Promise로 사용하는 경우 callback 함수를 넘기지 않으니, 상관 없다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncDivision</span>(<span class="params">dividend, divisor, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 항상 Promise를 반환한다.</span></span><br><span class="line">  <span class="comment">// 어차피 CPS 패턴을 사용하는 코드라면 Promise로 결과를 받아서 처리하지 않는다.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 비동기로 반환</span></span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = dividend / divisor;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="built_in">isNaN</span>(result) ||</span><br><span class="line">        !<span class="built_in">Number</span>.isFinite(result)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">&#x27;Invalid operands&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">          cb(error);</span><br><span class="line">        &#125; <span class="comment">// 콜백이 있으면, 콜백을 호출한다.</span></span><br><span class="line">        <span class="keyword">return</span> reject(error); <span class="comment">// 콜백이 있든 없든, Promise reject로 catch 체인을 실행한다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, result);</span><br><span class="line">      &#125; <span class="comment">// 콜백이 있으면, 콜백을 결과로 호출한다.</span></span><br><span class="line">      resolve(result); <span class="comment">// Promise resolve로 then 체인을 실행한다.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>장점:</p>
<ul>
<li>Promise, CPS 패턴 사용자 모두에게 기능을 제공할 수 있다.</li>
</ul>
<hr>
<h3 id="비동기와-함수형-자바스크립트"><a href="#비동기와-함수형-자바스크립트" class="headerlink" title="비동기와 함수형 자바스크립트"></a><strong>비동기와 함수형 자바스크립트</strong></h3><p>Javascript는 순수한 함수형 언어가 아니므로, 모든 코드를 함수형 패러다임을 적용해서 작성할 수 없다고 한다. 비동기를 다루는 코드에 있어서는, 특히 async-await 키워드를 사용하여 작성할 때는 명령형 코드가 되므로, 더 함수형과 멀어지게 되는데, 결론적으론 Javascript에서 함수형 패러다임을 실천할 때에는 함수형인 코드 베이스와 그렇지 않은 부분으로 나누는 게 좋다고 한다. 또한 Promise든 Async-Await이든 하나를 택해서 통일하는 게 좋다고 하니 참고 바란다.</p>
<p>전문: <a target="_blank" rel="noopener" href="https://medium.com/@aidobreen/js-promises-async-await-and-functional-programming-f2e5fa66b4ef">JS: Promises, async/await, and functional programming.</a></p>
<hr>
<p><strong>TODO:</strong></p>
<ul>
<li>Generator는 아직도 공부 중이다. Iterable 프로토콜에 대한 얘기도 있고, 비동기 처리 외에 Generator의 쓰임새나 Generator 자체 개념에 대해 더 공부해야 한다.</li>
<li>코루틴에 대해서도 공부해봐야 할 것 같다. 공부 중 접하게 된 키워드이다.</li>
<li>제너레이터에 대한 설명을 보강해야겠다.</li>
<li>이해가 완료되면 자체 제작한 예제 코드로 교체한다.</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">이전</a></div><div class="pagination-next"><a href="/page/5/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/NCloud/"><span class="level-start"><span class="level-item">NCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/RabbitMQ/"><span class="level-start"><span class="level-item">RabbitMQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T14:43:00.000Z">21-10-10</time></p><p class="title"><a href="/linux-ipc-unix-domain-socket/">리눅스에서의 IPC Socket vs Network Socket</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-03T14:50:00.000Z">21-10-03</time></p><p class="title"><a href="/linux-install-zsh/">ZSH를 WSL2에 설치하는 방법</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-26T14:50:00.000Z">21-09-26</time></p><p class="title"><a href="/linux-shell-2-screen/">screen: 리눅스에서 셸을 유지하면서 나갔다 들어오는 방법</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-19T14:30:00.000Z">21-09-19</time></p><p class="title"><a href="/linux-profile-not-loaded/">왜 .profile 파일이 적용되지 않을까</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-12T13:33:00.000Z">21-09-12</time></p><p class="title"><a href="/linux-debian-dpkg-apt/">데비안 리눅스 패키지 매니저 dpkg와 apt</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">10월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">9월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NCloud/"><span class="tag">NCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RabbitMQ/"><span class="tag">RabbitMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>태그: Javascript - JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">태그</a></li><li class="is-active"><a href="#" aria-current="page">Javascript</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-25T11:00:00.000Z" title="2021-01-25T11:00:00.000Z">21-01-25</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-25T22:45:47.390Z" title="2021-01-25T22:45:47.390Z">21-01-26</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">11분안에 읽기 (약 1660 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-async-2/">JS Async Functionality 2 - Promise</a></h1><div class="content"><p>이 시리즈는 자바스크립트에서 비동기를 다룰 때 마주치는 개념들을 다룬다. 이번 글에서는 Promise를 다룬다. </p>
<p><a href="https://jsqna.com/js-async-1/">JS Async Functionality 1 - Intro</a></p>
<hr>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise:"></a><strong>Promise:</strong></h4><p><code>&#123; pending, fulfilled, rejected &#125;</code>상태를 가지는 객체로,  <code>executor</code> 함수를 인자로 받는다. </p>
<ul>
<li><p>executor 함수( <code>(resolve, reject ) =&gt; &#123;&#125;</code> )의 역할:</p>
<ol>
<li>비동기 함수를 호출하고 </li>
<li>그 비동기 함수의 콜백에서 resolve를 호출한다.</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">url</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 이 함수가 executor 함수이다. (주석 설명 참조)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. example Async API provided by Node.js</span></span><br><span class="line">    http.get(options, <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">let</span> data;</span><br><span class="line">        result.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> data += chunk);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. Calls either [ resolve, reject ] from async callback.</span></span><br><span class="line">        result.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> resolve(data));</span><br><span class="line">        result.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> reject(err));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>executor 함수는 기존의 비동기 처리 방식을 그대로 옮겨온 것으로 이해하기 어렵지 않다.</p>
</li>
<li><p>다만 Promise Chaining이라는 개념으로 Callback Hell을 1차원으로 들여쓰기 단계를 낮출 수 있다.</p>
</li>
<li><p>이렇게 들여쓰기 단계를 줄이는 것은 중요한데 가독성에 의한 논리 오류가 빈번하게 발생했기 때문이다.</p>
</li>
</ul>
<hr>
<p>또한 Javascript 특성상 CPS 패턴으로 작성된 비동기 처리 함수에서, 이후에 호출되는 함수는 이전 함수의 클로저 참조도 할 수 있다. </p>
<ul>
<li>부주의하게 클로저 영역의 변수들을 사용하는 경우 메모리 사용량 면에서 좋을 게 없었다. </li>
<li>(ex) 전체 비동기 절차가 끝날 때 까지 호출 함수의 지역 변수들이 해제되지 못하는 등.</li>
</ul>
<hr>
<h4 id="Promise-Chaining"><a href="#Promise-Chaining" class="headerlink" title="Promise Chaining:"></a><strong>Promise Chaining:</strong></h4><p>Promise는 타입이자 객체이다. Promise(<executor function>); 인스턴스는 자신의 실행 흐름에 관여하는 메소드를 세 개 갖는다: <strong><u>then</u></strong>, <strong><u>catch</u></strong>, <u><strong>finally</strong></u> (참고로 메소드는 총 5개이다. race, all이 그 나머지 둘이다.)</p>
<ul>
<li>Prototype에 등록된 함수로, then은 Promise를 반환하고(그래서 Chaining이 가능하고) catch는 reject된 Promise에 한 해 수행되는 조건문으로 <code>then(undefined, onRejected)</code>와 동등하다. finally는 JS의 try-catch-finally의 finally와 동등하다.</li>
</ul>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a><strong>then</strong></h4><p><code>then</code> = (onFulfilled, onRejected) =&gt; Promise</p>
<p>즉 then의 두 번째 인자는 catch 절인 셈이다. 웬만하면 가독성을 위해 따로 catch 절을 사용한다.</p>
<ul>
<li><p>onFulfilled = value =&gt; Promise (여기서 value는 Promise가 resolve한 값이다. 보통 비동기 함수의 결괏값.)</p>
</li>
<li><p>onRejected = value =&gt; {} (여기서 value는 Promise가 reject한 값이다. 보통 Error 객체.)</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.then(onFulfilled, onRejected);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 비동기가 별 탈 없이 진행된 경우.</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 비동기 함수 수행 중 오류가 난 경우.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>then에서는 값을 그냥 반환하는 경우 Promise.resolve로 감싼 것과 같다. 즉 Promise가 반환되는 것인데, 그렇기 때문에 Promise Chaining이 가능한 것이다.</p>
</li>
</ul>
<hr>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a><strong>catch</strong></h4><p><code>catch</code> = onRejected =&gt; Promise <strong>(!)</strong></p>
<ul>
<li><p>catch 메소드는 <code>try-catch</code>의 <code>catch</code>와 같은 역할이다. 즉, catch가 성공했느냐, 실패했느냐에 따라 다시 then이 실행될 수도 있고 다른 catch가 실행될 수도 있고 앱이 멈출 수도 있다.</p>
</li>
<li><p>Case 1: catch 절에서 resolved Promise를 반환하는 경우: 이후의 then 수행</p>
</li>
</ul>
<ul>
<li><p>catch 절에서 따로 throw를 하거나, <code>Promise.reject()</code>를 호출하지 않는 경우 Promise는 resolved 상태로 변하여 then을 수행한 것과 동등하게 된다.</p>
</li>
<li><p>Case 2: catch 절에서 rejected Promise를 반환하는 경우: 이후의 catch 수행</p>
</li>
</ul>
<ul>
<li><p>JS의 try-catch에서 catch는 여러 개가 존재할 수 없는 것에 비해 Promise가 rejected 상태이면 catch절은 계속해서 호출된다. 보통 여러 개의 catch 절은 특정 오류만 잡고 싶을 때 사용한다.</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래처럼 pin-point로 catch 절을 사용하는 것이 가능하다.</span></span><br><span class="line"><span class="comment">// 기존 JS에서 try-catch를 여러 번 순차적으로 사용한 것과 동등하다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.Promise를 생성</span></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">// 1. throw를 호출해 catch 절로 이동</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;oh, no!&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 2. reject 혹은 throw를 하지 않으므로 then 수행</span></span><br><span class="line">  <span class="built_in">console</span>.error(e.message); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 3. 이 then이 수행되게 됨.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;after a catch the chain is restored&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 4. 만약 [2], [3]에서 throw를 하는 경우 여기로 오게 됨.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Not fired due to the catch&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a><strong>finally</strong></h4><p>(설명 생략)</p>
<hr>
<h3 id="알기-어려운-Promise의-특징"><a href="#알기-어려운-Promise의-특징" class="headerlink" title="알기 어려운 Promise의 특징"></a><strong>알기 어려운 Promise의 특징</strong></h3><p><strong>1. <u>then, catch는 비동기로 실행</u>된다.</strong></p>
<ul>
<li><p>아무리 Promise.resolve(); 로 resolve가 동기로 수행되더라도 then, catch는 비동기로 queue 된다.</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="literal">null</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Async: &#x27;</span> + v));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Sync!&#x27;</span>);</span><br><span class="line"><span class="comment">// 결과:</span></span><br><span class="line"><span class="comment">// Sync!</span></span><br><span class="line"><span class="comment">// Async: null</span></span><br><span class="line"><span class="comment">// WHY? then이 async로 microtask queue에 들어갔기 때문.</span></span><br><span class="line"><span class="comment">// then이</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>2: then, catch는 <u>비동기이지만 한꺼번에 수행</u>된다.</strong></p>
<ul>
<li><p>만약 then, catch가 setTimeout과 같은 일반적인 비동기였다면 <u>Task Queue</u>에서 처리된다. Task Queue는 한 작업만 처리하고 나머지 작업은 다음 순서로 넘긴다.</p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(loop, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">loop();</span><br><span class="line"><span class="comment">// 무한 루프에 걸리지 않는다.</span></span><br><span class="line"><span class="comment">// Microtask가 아니므로 이벤트 루프에서 한 작업씩만(!!!) 처리한다.</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>그러나 Promise, then, catch는 <u>Microtask Queue</u>에서 수행되는데, 이는 Event Loop 내의 Event Loop으로 생각하면 된다.</p>
<ul>
<li><p>굳이 이렇게 하는 이유는 </p>
<ol>
<li>다른 Javascript 수행이 되지 않음을 보장 </li>
<li>화면이 변경되지 않음을 보장 하기 위해서이다.</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>Microtask가 호출한 microtask 역시 이어서 수행되며 microtask queue가 빌 때까지 이 단계는 끝나지 않는다. </p>
<ul>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// then은 microtask에 queue 된다.</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(loop);</span><br><span class="line">&#125;</span><br><span class="line">loop();</span><br><span class="line"><span class="comment">// microtask는 현재 cycle에서 microtask가 비워질 때까지 수행을 멈추지 않는다.</span></span><br><span class="line"><span class="comment">// 즉 무한 루프를 비동기 코드로 발생시킬 수 있는 셈이다.</span></span><br></pre></td></tr></table></figure></li>
<li><p>출처: <a target="_blank" rel="noopener" href="https://ko.javascript.info/event-loop#ref-834">이벤트 루프와 매크로, 마이크로 태스크</a>, <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">Jake Archibald: Inside Loop - JSConf.Asia | Youtube</a></p>
</li>
</ul>
</li>
<li><p>Promise가 연속적으로 수행되어 문제가 발생하는 예제를 생각하려고 했으나 대부분의 비동기는 microtask를 사용하지 않기에 큰 문제는 없을 것 같다. 따라서 이 본문의 내용을 몰라도 거의 문제는 없을 것 같다.</p>
</li>
</ul>
<hr>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a><strong>출처</strong></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">Promise then</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch">Promise catch</a> (재밌는 점은 catch 문서는 한국어 번역이 없다는 점이다.)</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Using_promises">Using Promises</a></p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>처음에 React를 통해 ES6를 배우면서 Promise를 접했을 때보다 문서 개수나 번역이 훨씬 좋아졌다는 걸 느꼈다. 앞으로의 JS 표준을 다루는 MDN Wiki 문서가 있으면 나도 기여해야겠다</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T10:55:00.000Z" title="2021-01-15T10:55:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">7분안에 읽기 (약 1070 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-generator/">Javascript의 Generator</a></h1><div class="content"><p>이 글은 자바스크립트의 제너레이터 문법에 대해 간략히 소개한다.</p>
<hr>
<h3 id="정의"><a href="#정의" class="headerlink" title="정의"></a><strong>정의</strong></h3><p>JavaScript의 제너레이터는 <code>function*</code> 으로 정의된 제너레이터 함수가 반환한 객체이다. 이 객체는 이터레이터(iterator)이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo()로 생성된 제너레이터를 순회하며 값을 읽어간다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-객체와-함수-팩토리"><a href="#Generator-객체와-함수-팩토리" class="headerlink" title="Generator 객체와 함수(팩토리)"></a><strong>Generator 객체와 함수(팩토리)</strong></h3><p><u>제너레이터 함수</u>를 호출하면 <u>제너레이터 객체</u>를 반환하고 끝난다.</p>
<p>제너레이터 객체의 <code>next(...args)</code>를 통해 제너레이터의 본문을 일정 부분 실행할 수 있다.</p>
<ul>
<li>이터레이터는 <code>next()</code> 함수로 파라미터를 전달할 수 없다.</li>
<li>제너레이터가 값을 읽을 수 있기 때문에 <u><strong>협력적 멀티 태스킹</strong></u>이 가능하다.</li>
</ul>
<h3 id="Generator-기반-협력적-멀티-태스킹"><a href="#Generator-기반-협력적-멀티-태스킹" class="headerlink" title="Generator 기반 협력적 멀티 태스킹"></a><strong>Generator 기반 협력적 멀티 태스킹</strong></h3><p>협력적 멀티 태스킹은 코루틴에 나오는 개념이다. (추후 정리할 예정이다.)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">go(<span class="function"><span class="keyword">function</span>* <span class="title">producer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> write(i);</span><br><span class="line">    <span class="keyword">yield</span> sleep(<span class="number">100</span>); <span class="comment">// -- sleep이 가능해진다!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">go(<span class="function"><span class="keyword">function</span>* <span class="title">consumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> v;</span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    <span class="keyword">typeof</span> (v = <span class="keyword">yield</span> read()) !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;read:&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>이 코드의 <code>go</code>와 같은 함수를 <strong>제너레이터 실행기</strong>라고 한다. <code>co</code> 라이브러리가 훌륭한 제너레이터 실행기를 제공한다.</p>
<p>제너레이터 실행기는 원래 동기적으로 수행되는 제너레이터를 비동기 호출을 수행하게 만든 다음 callback을 통해 다시 제너레이터를 호출하게끔 하여 비동기 코드를 동기 코드처럼 작성할 수 있게 하는 목적의 함수이다.</p>
<h3 id="제너레이터-실행기"><a href="#제너레이터-실행기" class="headerlink" title="제너레이터 실행기"></a><strong>제너레이터 실행기</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 제너레이터 실행기</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grun</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> it = g();</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x = it.next(val);</span><br><span class="line">    <span class="keyword">if</span> (!x.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        x.value</span><br><span class="line">          .then(iterate)</span><br><span class="line">          .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> it.throw(err));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(iterate, <span class="number">0</span>, x.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 실행기를 사용한 모습.</span></span><br><span class="line"><span class="comment">// 꽤 async-await과 같이 가독성이 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">theFutureIsNow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    data = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;a.txt&#x27;</span>),</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;b.txt&#x27;</span>),</span><br><span class="line">      nfcall(fs.readFile, <span class="string">&#x27;c.txt&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;Unable to read one or more input files: &#x27;</span> +</span><br><span class="line">        err.message,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> ptimeout(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> nfcall(</span><br><span class="line">      fs.writeFile,</span><br><span class="line">      <span class="string">&#x27;d.txt&#x27;</span>,</span><br><span class="line">      data[<span class="number">0</span>] + data[<span class="number">1</span>] + data[<span class="number">2</span>],</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;Unable to write output file: &#x27;</span> +</span><br><span class="line">        err.message,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generator-직접-만들어보기"><a href="#Generator-직접-만들어보기" class="headerlink" title="Generator 직접 만들어보기"></a><strong>Generator 직접 만들어보기</strong></h3><p>자료 중 재밌는 것이 있었다: <a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/babel%EC%9D%80-generator%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%82%98-c78523645cd7">Babel은 Generator를 어떻게 바꾸나</a>. 지금 나한테는 바로 이해하긴 어렵다. 직접 만들어보면 이해에 큰 도움이 될 듯 하다.</p>
<h3 id="Generator의-단점-Iterable은-가변-인자가-아니다"><a href="#Generator의-단점-Iterable은-가변-인자가-아니다" class="headerlink" title="Generator의 단점: Iterable은 가변 인자가 아니다"></a><strong>Generator의 단점: Iterable은 가변 인자가 아니다</strong></h3><p>제너레이터 객체는 위에서 말했듯 Iterable이지만, 이는 <u><strong>가변 인자와는 달라</strong></u>서, Math.min같은 함수를 이용할 때 spead 연산자로 배열로 만들어 넘겨야 하므로, 인자 전달 부분에서 아쉽다고 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 객체만 넘길 순 없음.</span></span><br><span class="line"><span class="comment">// 굳이 제너레이터 객체를 넘길거면, 받는 함수 입장에서 이터레이터를 써야 할 듯?</span></span><br><span class="line"><span class="comment">// for-of 문으로.</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// spread 연산자로 넘겨줘야 함.</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...foo());</span><br></pre></td></tr></table></figure>
<h3 id="Generator의-콜-스택"><a href="#Generator의-콜-스택" class="headerlink" title="Generator의 콜 스택?"></a><strong>Generator의 콜 스택?</strong></h3><blockquote>
<p>Calling <code>.next()</code> method just pushes that call on the top of the stack. It will then run the code inside the generator function.</p>
<p><strong><u>difference</u></strong>: it has to remember the state of all local variables, but engines already know how to do that from the implementation of closures. A generator call will restore the state so that it can continue where it left off.</p>
</blockquote>
<p>일반적인 콜 스택과 동일하다고 한다. 다만 제너레이터 내에서 제너레이터를 호출하는 경우 복잡하다고 하는데, 거기까지 알 필요는 없을 듯 하다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48873128/javascript-stack-model-for-generators">Javascript stack model for generators | StackOverFlow</a></p>
<p>출처: <a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%9E%AC%EB%AF%B8-246553cadfbd">Javascript Generator의 재미 (2016.12)</a></p>
<p>출처: Learning Javascript, O Reilly</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><strong>TODO</strong>:</h3><p>부족한 내용 보충하기. 제너레이터가 개념 뿐 아니라 사용이 중요한 개념이어서 정리가 난잡한데 다음주 중으로 정리하려고 한다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T10:54:00.000Z" title="2021-01-15T10:54:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">3분안에 읽기 (약 426 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-promise-all/">Promise.all은 Parallel로 실행되는가?</a></h1><div class="content"><p>Javascript의 모든 코드는 이벤트 루프에서 처리된다. 그리고 Node.js의 이벤트 루프 구현체로 libuv가 사용 된다는 사실은 널리 알려져 있다. 그런데 이상하지 않은가?</p>
<h3 id="Promise-all은-Parallel로-실행되는가"><a href="#Promise-all은-Parallel로-실행되는가" class="headerlink" title="Promise.all은 Parallel로 실행되는가?"></a><strong>Promise.all은 Parallel로 실행되는가?</strong></h3><p>이벤트 루프 모델을 이해했다면 자바스크립트에 병렬 실행은 없다는 것을 이해했을 것이다. 파일, 네트워크 I/O는 자바스크립트 코드가 직접 처리하는 것이 아니고, 콜백은 이벤트 루프에 의해 호출되어 순차적으로 실행된다.</p>
<blockquote>
<p>그럼, Promise.all은 어떤가?</p>
</blockquote>
<p>음… 애초에 자바스크립트 코드가 병렬적으로 실행될 수 있는가?</p>
<h4 id="Promise-all을-잘-몰라서-생긴-일"><a href="#Promise-all을-잘-몰라서-생긴-일" class="headerlink" title="Promise.all을 잘 몰라서 생긴 일"></a><strong>Promise.all을 잘 몰라서 생긴 일</strong></h4><p><code>Promise.all</code>은 Promise의 호출 순서와는 전혀 관계가 없다. Promise의 기본 동작을 하나도 건드리지 않는다.</p>
<p>Promise.all이 제공하는 기능이란, 트랜잭션과 같이 하나라도 실패하면 catch 훅으로 넘어가게 하는 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3, p4, p5])</span><br><span class="line">  .then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="오히려-순차적으로-Promise를-실행하는-것이-더-특별하다"><a href="#오히려-순차적으로-Promise를-실행하는-것이-더-특별하다" class="headerlink" title="오히려 순차적으로 Promise를 실행하는 것이 더 특별하다."></a><strong>오히려 순차적으로 Promise를 실행하는 것이 더 특별하다.</strong></h4><p><code>reduce</code>를 사용해 <code>iterable.reduce((p, fn) =&gt; p.then(fn), Promise.resolve())</code>로 순차적으로 실행시킬 수 있다. (웬만하면 <code>then</code>으로 직접 잇겠지만.)</p>
<p><a href="https://jsqna.com/js-async-1">Async Functions in Javascript 1</a>를 참고해도 좋을 것 같다.</p>
<p>출처: <a target="_blank" rel="noopener" href="https://medium.com/@sandeepv68/how-does-promise-all-works-internally-978ee82f3348">How does Promise.all all works interanlly</a></p>
<p>출처: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30823653/is-node-js-native-promise-all-processing-in-parallel-or-sequentially">Is Node.js native Promise.all processing in parallel or sequentially? | StackOverFlow</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T09:05:00.000Z" title="2021-01-15T09:05:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">3분안에 읽기 (약 385 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-event-loop-browser-vs-node/">이벤트 루프는 환경마다 다를까?</a></h1><div class="content"><p>Javascript의 모든 코드는 이벤트 루프에서 처리된다. 그리고 Node.js의 이벤트 루프 구현체로 libuv가 사용 된다는 사실은 널리 알려져 있다. 그런데 이상하지 않은가?</p>
<blockquote>
<p>왜 Node.js를 설명할 때 이벤트 루프의 <u>구현체</u>라며 따로 소개하는 걸까?</p>
</blockquote>
<p>과연 브라우저 상의 이벤트 루프와 Node.js의 이벤트 루프는 동일하다고 생각해도 될까?</p>
<p>이벤트 루프 <u>구현체가 다르다</u>는 것을 어떻게 생각하면 좋을까?</p>
<hr>
<h3 id="원인은-환경-차이"><a href="#원인은-환경-차이" class="headerlink" title="원인은 환경 차이"></a><strong>원인은 환경 차이</strong></h3><p>이벤트 루프의 처리 방식은 스펙으로 결정돼있지만 벤더마다 약간씩 다르게 구현하는 부분이 있다고 한다. Node.js 또한 예외는 아니다.</p>
<table>
<thead>
<tr>
<th>기능</th>
<th>브라우저</th>
<th>NodeJs</th>
</tr>
</thead>
<tbody><tr>
<td>File, Network I/O</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Event의 종류</td>
<td>Mouse, Keyboard Events</td>
<td>File, Network I/O</td>
</tr>
<tr>
<td>이벤트 루프 구현체</td>
<td><a target="_blank" rel="noopener" href="https://libevent.org/">libevent</a> (크롬 기준)</td>
<td><a target="_blank" rel="noopener" href="https://libuv.org/">libuv</a></td>
</tr>
<tr>
<td>자바스크립트 엔진</td>
<td>V8 (크롬 기준)</td>
<td>V8</td>
</tr>
<tr>
<td>process.nextTick (process 모듈 자체 API)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>setImmediate (<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate">ECMA 표준 아님</a>)</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>위 표 이외에 처리 순서의 차이가 약간 있긴 하지만 Node v11부터는 그 차이마저 적은 편이다.</p>
<blockquote>
<p><em>결론: 환경의 차이 때문에 약간의 구현 상의 차이가 있다 정도로 받아들이자.</em></p>
</blockquote>
<p>출처: <a target="_blank" rel="noopener" href="https://blog.insiderattack.net/javascript-event-loop-vs-node-js-event-loop-aea2b1b85f5c">JavaScript Event Loop vs Node JS Event Loop</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T06:45:00.000Z" title="2021-01-15T06:45:00.000Z">21-01-15</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-19T07:03:05.410Z" title="2021-01-19T07:03:05.410Z">21-01-19</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">9분안에 읽기 (약 1381 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-license/">Javascript의 라이센스</a></h1><div class="content"><p>이 글은 자바스크립트의 라이센스 - 소유권과 결정권에 대한 내용과 근거를 찾아 정리한 글이다.</p>
<hr>
<h3 id="1-Javascript의-라이센스"><a href="#1-Javascript의-라이센스" class="headerlink" title="1. Javascript의 라이센스"></a><strong>1. Javascript의 라이센스</strong></h3><p>Javascript 이해관계자는 크게 언어 명세을 결정하는 쪽과 언어를 개발하는 쪽으로 나뉜다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>소유자</th>
<th>라이센스</th>
<th>생명 주기</th>
</tr>
</thead>
<tbody><tr>
<td>언어 명세(ECMA 262)</td>
<td>TC39</td>
<td>수정 하지 않는 선에서 사용 가능</td>
<td>매년</td>
</tr>
<tr>
<td>런타임(SW)</td>
<td>각 벤더</td>
<td>개별적으로 다름</td>
<td>상시 업데이트</td>
</tr>
</tbody></table>
<p>재밌는 점은 TC39에 벤더들이 참여한다는 점이다.</p>
<p>Trademark(유사 상표권)는 Oracle에 있는데, <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/135905/legal-ramifications-of-use-of-the-javascript-trademark">명칭하는 데 사용하는 것은 문제가 되지 않는다</a>고 한다.</p>
<p>언어 명세(구현 코드가 아님)은 ECMA International(TC39의 상위 개념)에서 제정한다. 언어 표준의 라이센스는 <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/238724/what-license-is-html-released-under">이 글 | StackExchange</a>을 참고</p>
<p>언어 - 인터프리터, 컴파일러, 런타임 - 구현의 몫은 각 벤더사에 있으며 벤더사가 적용하는 라이센스에 따라 각자 라이센스를 가질 수 있다.</p>
<p>아래는 역사를 요약 설명한 내용이다.</p>
<blockquote>
<p>in 1995, Netscape decided to add a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scripting_language">scripting language</a> to Navigator. They pursued two routes to achieve this: collaborating with <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems</a> to embed the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Programming_language">programming language</a>, while also hiring <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Brendan_Eich">Brendan Eich</a> to embed the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> language.</p>
<p>Netscape management soon decided that the best option was for Eich to devise a new language, with syntax similar to Java and less like Scheme or other extant scripting languages. Although the new language and its <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a> implementation were officially called LiveScript when first shipped as part of a Navigator release in September 1995, the name was changed to JavaScript three months later.</p>
</blockquote>
<p>1995: Netscape Navigator라는 브라우저의 기능으로 스크립트 언어를 내장하기로 개발</p>
<blockquote>
<p>In November 1996, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netscape">Netscape</a> submitted JavaScript to <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ecma_International">ECMA International</a>, as the starting point for a standard specification that all browser vendors could conform to. This led to the official release of the first <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a> language specification in June 1997.</p>
</blockquote>
<p>1996: Netscape -&gt; ECMA International로 소유권 이양 (이후 특정 기업의 소유는 아니게 됨)</p>
<p>출처: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JavaScript">Javascript | Wikipedia</a></p>
<h3 id="2-TC39-소개"><a href="#2-TC39-소개" class="headerlink" title="2. TC39 소개"></a><strong>2. TC39 소개</strong></h3><blockquote>
<p>Ecma International’s TC39 is a group of JavaScript developers, implementers, academics, and more, collaborating with the community to maintain and evolve the definition of JavaScript.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://tc39.es/">TC39</a>에서는 미팅 회의록을 공개하는데, <a target="_blank" rel="noopener" href="https://github.com/tc39/notes/blob/master/meetings/2020-11/nov-16.md">최근 미팅</a>을 보니 주요 브라우저 벤더사만 참여하는 것은 아니고 회의마다 여러 주체나 외부 인사도 참여하는 듯 하다. TC39에서 Javascript의 스펙을 결정한다고 한다.</p>
<blockquote>
<p>This Standard defines the ECMAScript 2021 general-purpose programming language.</p>
</blockquote>
<p>TC39는 <a target="_blank" rel="noopener" href="https://tc39.es/ecma262/">가장 최신의 Javascript 스펙 문서</a>를 온라인으로 유지한다. 현재는 ECMAScript 2021이며 이 문서는 Living Standard로 주기적으로 갱신되는 듯하다.</p>
<p>TC39이 표준을 제정하는 방식에 대해선 <a target="_blank" rel="noopener" href="https://ahnheejong.name/articles/ecmascript-tc39/">ECMAScript와 TC39 | ahn.heejong</a>을 참고하라.</p>
<h3 id="3-WHATWG-소개"><a href="#3-WHATWG-소개" class="headerlink" title="3. WHATWG 소개"></a><strong>3. WHATWG 소개</strong></h3><blockquote>
<p>The WHATWG was formed in response to the slow development of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium">World Wide Web Consortium</a> (W3C) <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Web_standards">Web standards</a> (…) On 28 May 2019, the W3C announced that WHATWG would be the sole publisher of the HTML and DOM standards.</p>
</blockquote>
<p>WHATWG는 W3C이 제정하는 표준 중 HTML, DOM 표준을 독자적으로 제정하는 그룹이다. WHATWG는 주요 브라우저 벤더로 구성된다. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HTML5#W3C_and_WHATWG_conflict">자세한 내용</a></p>
<p>WHATWG에서 제정한 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/introduction.html">HTML 5 스펙</a>은 HTML 뿐만 아니라 - HTML5라고 해서 HTML만을 다루지는 않는다 - (현대) 웹 기술의 전반에 대해 표준화된 문서이다.</p>
<h3 id="4-번외-구글은-왜-Chrome-V8을-오픈소스화했을까"><a href="#4-번외-구글은-왜-Chrome-V8을-오픈소스화했을까" class="headerlink" title="4. 번외: 구글은 왜 Chrome, V8을 오픈소스화했을까?"></a><strong>4. 번외: 구글은 왜 Chrome, V8을 오픈소스화했을까?</strong></h3><blockquote>
<p>[Chromium Release Announcement 발췌]</p>
<p>With a richer set of APIs we can build more interesting apps allowing people to do more online. The more people do online, the more they can use our services. […]</p>
<p>We believe that open source works not only because it allows people to join us and improve our products, but also (and more importantly) because it means other projects are able to use the code we’ve developed.</p>
</blockquote>
<blockquote>
<p>[StackExchange 답변 중]</p>
<p>they just needed the web as a whole to become more attractive. Their decision to open-source V8 led to one such effect: the NodeJS system was built on V8 … The web has become so attractive as a development environment that it is even displacing native apps, e.g. Electron is based on Chromium.</p>
</blockquote>
<p>공유되는 일부 내용을 정리해보자면, 크롬을 통해 구글은 웹 시장을 키우고 싶었고, 오픈소스화(2008)로 웹의 기능을 늘리고 늘어난 기능이 널리 퍼지는 것을 유도했다(다른 크로미움 기반 브라우저를 통해). 오픈소스를 활용해 크롬을 개발했으며, V8기반의 NodeJS(2011)를 통해 Javascript 생태계가 커졌다. (숙련된 개발자가 많아질 수 있는 환경 조성)</p>
<p>출처: <a target="_blank" rel="noopener" href="https://opensource.stackexchange.com/questions/10644/why-did-google-make-chromium-open-source">Why did Google make Chromium Open Source? | StackExchange</a></p>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a><strong>TODO</strong>:</h4><p><em>Q. Netscape은 왜 넘겼을까? 돈이 안 돼서 그런걸까? 독자적인 기능으로 탑재했다면 더 성공할 수 있지 않았을까?</em></p>
<p><em>Q. 굳이 <u>오픈소스화</u> 하지 않아도 경쟁을 통해 기능은 늘어났을 것이고 크롬 출시연도인 2009년에 이미 2위 브라우저로 시작해 2012년엔 1위 브라우저가 됐는데 오픈 소스화가 여기서 얼마나 큰 역할을 했는지는 잘 모르겠다. 좀 더 찾아봐야 할 듯.</em></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-11T11:00:00.000Z" title="2021-01-11T11:00:00.000Z">21-01-11</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-01-25T11:21:13.860Z" title="2021-01-25T11:21:13.860Z">21-01-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Javascript/">Javascript</a></span><span class="level-item">13분안에 읽기 (약 1935 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/js-async-1/">JS Async Functionality 1 - Intro</a></h1><div class="content"><p>이 글은 자바스크립트에서 비동기를 다룰 때 마주치는 개념들인 Promise, Generator, Async-Await을 큰 범위에서 다룬다. 중간 중간에 재밌는 패턴들도 수록했다.</p>
<hr>
<h3 id="Why-Promise"><a href="#Why-Promise" class="headerlink" title="Why Promise?"></a><strong>Why Promise?</strong></h3><blockquote>
<p><strong><u>What’s Promise?</u></strong><br>Promise는 순차적인 비동기 코드를 깔끔하게 짤 수 있게 하는 문법이다. 문법에 포함된 <code>Promise 객체</code>로 처리한다. Promise로 거의 모든 비동기를 처리한다고 해도 과언이 아니다.</p>
<p>Promise가 익숙하지 않다면 MDN을 참고:<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a> &gt; <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises</a></p>
</blockquote>
<p>비동기 작업 시 순차적인 흐름을 많이 구현해야 하는데, <u>CPS 방식으론 간결하게 짤 수 없다</u>. <a href="https://jsqna.com/ndp-3-cps-tips/">CPS 패턴 사용 시의 Tip | JSQnA</a> 참고.</p>
<p><strong>Promise의 장점</strong>: (콜백과 관련한 비교에 대한 내용은 <a href="https://jsqna.com/ndp-2-cps/">CPS 패턴</a> 참고.)</p>
<ul>
<li>프로미스 체인을 사용하면 작업들을 순차 실행시키는 일은 그리 어렵지 않다.</li>
<li><code>throw</code>를 프로미스 체인에서 사용할 수 있다.</li>
<li>catch 될 때까지 전체 체인에 오류를 자동으로 전파할 수 있다. 비동기 오류가 누락될 확률이 줄어든다.</li>
<li>동기적으로 값을 반환해도 비동기적인 호출을 보장한다. 함수가 동기, 비동기 반환을 섞어서 하는 것은 나쁘다.</li>
<li><code>Promise.all</code> 함수를 통해 비동기 작업을 병렬로 실행할 수 있다. (이건 CPS도 가능)</li>
<li><code>Promise.race</code> 함수를 통해 비동기 작업 중 가장 먼저 수행이 끝난 결과만 사용할 수 있다. (CPS에선 직접 구현해야 함.)</li>
</ul>
<p><strong>Promise로 함수 배열을 순차적으로 실행하는 패턴</strong> (현재 이해 부족으로 인해 수정 필요함.):</p>
<p>책에 재밌는 코드가 있어 가져왔다. Promise로 함수의 배열을 순차적으로 실행하는 방법이 있을까?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sequential :: Array(() =&gt; Promise) =&gt; Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequential</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 빈 값을 반환하는 Promise를 생성한다.</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  tasks.forEach(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// promise에 then으로 체인을 걸고,</span></span><br><span class="line">    <span class="comment">// 다음 순번의 &#x27;이전 작업&#x27;이 되기 위해 promise 변수로 할당한다.</span></span><br><span class="line">    <span class="comment">// UPDATE: task는 Promise를 반환하는 함수여야 한다.</span></span><br><span class="line">    promise = promise.then(task);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 최종 Promise를 반환한다.</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reduce로도 가능하다:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> promise = tasks.reduce(</span><br><span class="line">  (prev, task) =&gt; prev.then(task),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> retreive result</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>제한된 개수로 병렬 실행하기</strong>: (현재 이해 부족으로 인해, 추후 삽입 예정)</p>
<hr>
<h3 id="ES8-비동기-함수"><a href="#ES8-비동기-함수" class="headerlink" title="ES8 비동기 함수"></a><strong>ES8 비동기 함수</strong></h3><p>정의에 대한 자세한 내용은 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN async function</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">MDN AsyncFunction 생성자</a>를 참고하라.</p>
<p>ES7 비동기 함수는 비동기적으로 동작하는, <code>async</code>, <code>await</code> 문법이 활용된 함수이다.</p>
<p>(설명 보충 예정.)</p>
<hr>
<h3 id="Why-Generator"><a href="#Why-Generator" class="headerlink" title="Why Generator?"></a><strong>Why Generator?</strong></h3><blockquote>
<p><u><strong>What’s Generator?</strong></u></p>
<p>Generator는 시작 지점이 여러 개이며 중간에 실행을 정지/재개할 수 있는 함수이다.</p>
<ul>
<li><u>시작 지점이 여러 개</u>: 다른 시작 지점에 대해 매번 새로운 arguments로 호출할 수 있다.</li>
<li><u>정지/재개할 수 있다</u>: 제너레이터 함수는 실행 후 값을 반환할 때 정지한다. 이후 호출하면 다시 재개된다.</li>
</ul>
<p>Generator가 익숙하지 않다면 MDN을 참고:</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function</a>*</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator</a></p>
<p>시작하기 전에 아래 두 코드의 결과를 모르겠다면 이후 내용을 이해하기 어려우므로, Generator에 대해 추가적으로 공부를 하기 바란다.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator Example 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fruitGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;watermelon&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFruitGenerator = fruitGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"><span class="built_in">console</span>.log(newFruitGenerator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator Example 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iteratorGenerator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = iteratorGenerator([</span><br><span class="line">  <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;orange&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;watermelon&#x27;</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">let</span> currentItem = iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!currentItem.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(currentItem.value);</span><br><span class="line">  currentItem = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Generator-with-CPS-into-Async-Await"><a href="#Generator-with-CPS-into-Async-Await" class="headerlink" title="Generator with CPS into Async-Await:"></a><strong>Generator with CPS into Async-Await:</strong></h4><p>놀랍게도 Generator에 약간의 양념을 치면 ES7 비동기 함수를 만들어낼 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터로 비동기 흐름을 구현하는 방법이다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFlow</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// callback 함수는 비동기 함수에 CPS 패턴으로 넘겨져서, 결괏값으로 다시 제너레이터를 호출하는 데 사용된다.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> generator.throw(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> results = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    generator.next(</span><br><span class="line">      results.length &gt; <span class="number">1</span> ? results : results[<span class="number">0</span>],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> generator = generatorFunction(callback);</span><br><span class="line">  generator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncFlow, callback을 감추고, yield를 await으로 바꾼다면 async-await과 같은 문법을 지닌다.</span></span><br><span class="line">asyncFlow(<span class="function"><span class="keyword">function</span>* (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fileName = path.basename(__filename);</span><br><span class="line">  <span class="keyword">const</span> myself = <span class="keyword">yield</span> fs.readFile(</span><br><span class="line">    fileName,</span><br><span class="line">    <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">yield</span> fs.writeFile(</span><br><span class="line">    <span class="string">`clone_of_<span class="subst">$&#123;fileName&#125;</span>`</span>,</span><br><span class="line">    myself,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Clone created&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a><strong>try-catch</strong></h4><p>Async-Await과 유사하게, 제너레이터에는 <code>throw</code> API가 있는데, 제너레이터 함수 내에서 <code>try-catch</code>로 이를 처리할 수 있다:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> twoWay = twoWayGenerator();</span><br><span class="line">twoWay.next(args); <span class="comment">// args를 전달</span></span><br><span class="line">twoWay.throw(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">// throw로 Error 객체 전달. 제너레이터 함수 내의 catch 절로 이동하게 된다.</span></span><br></pre></td></tr></table></figure>
<p>참고자료 전문: <a target="_blank" rel="noopener" href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2">Async-Await ≈ Generators + Promises</a></p>
<p>참고 2: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36196608/difference-between-async-await-and-es6-yield-with-generators">Difference between async/await and ES6 yield with generators | StackOverFlow</a></p>
<p>참고 3: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31483342/es2017-async-vs-yield">ES2017 - Async vs. Yield | StackOverFlow</a></p>
<hr>
<h4 id="하나의-API로-CPS와-Promise-모두-지원하는-방법"><a href="#하나의-API로-CPS와-Promise-모두-지원하는-방법" class="headerlink" title="하나의 API로 CPS와 Promise 모두 지원하는 방법"></a><strong>하나의 API로 CPS와 Promise 모두 지원하는 방법</strong></h4><p><u>mongoose</u>와 같은 많은 라이브러리는 CPS와 Promise 방식을 모두 지원한다. 어떻게 한 함수로 동시에 지원할 수 있을까? 아래 코드와 같이 구현한다면 가능하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 마지막 인자로 callback 함수를 받는다.</span></span><br><span class="line"><span class="comment">// Promise로 사용하는 경우 callback 함수를 넘기지 않으니, 상관 없다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncDivision</span>(<span class="params">dividend, divisor, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 항상 Promise를 반환한다.</span></span><br><span class="line">  <span class="comment">// 어차피 CPS 패턴을 사용하는 코드라면 Promise로 결과를 받아서 처리하지 않는다.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 비동기로 반환</span></span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = dividend / divisor;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="built_in">isNaN</span>(result) ||</span><br><span class="line">        !<span class="built_in">Number</span>.isFinite(result)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">&#x27;Invalid operands&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">          cb(error);</span><br><span class="line">        &#125; <span class="comment">// 콜백이 있으면, 콜백을 호출한다.</span></span><br><span class="line">        <span class="keyword">return</span> reject(error); <span class="comment">// 콜백이 있든 없든, Promise reject로 catch 체인을 실행한다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, result);</span><br><span class="line">      &#125; <span class="comment">// 콜백이 있으면, 콜백을 결과로 호출한다.</span></span><br><span class="line">      resolve(result); <span class="comment">// Promise resolve로 then 체인을 실행한다.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>장점:</p>
<ul>
<li>Promise, CPS 패턴 사용자 모두에게 기능을 제공할 수 있다.</li>
</ul>
<hr>
<h3 id="비동기와-함수형-자바스크립트"><a href="#비동기와-함수형-자바스크립트" class="headerlink" title="비동기와 함수형 자바스크립트"></a><strong>비동기와 함수형 자바스크립트</strong></h3><p>Javascript는 순수한 함수형 언어가 아니므로, 모든 코드를 함수형 패러다임을 적용해서 작성할 수 없다고 한다. 비동기를 다루는 코드에 있어서는, 특히 async-await 키워드를 사용하여 작성할 때는 명령형 코드가 되므로, 더 함수형과 멀어지게 되는데, 결론적으론 Javascript에서 함수형 패러다임을 실천할 때에는 함수형인 코드 베이스와 그렇지 않은 부분으로 나누는 게 좋다고 한다. 또한 Promise든 Async-Await이든 하나를 택해서 통일하는 게 좋다고 하니 참고 바란다.</p>
<p>전문: <a target="_blank" rel="noopener" href="https://medium.com/@aidobreen/js-promises-async-await-and-functional-programming-f2e5fa66b4ef">JS: Promises, async/await, and functional programming.</a></p>
<hr>
<p><strong>TODO:</strong></p>
<ul>
<li>Generator는 아직도 공부 중이다. Iterable 프로토콜에 대한 얘기도 있고, 비동기 처리 외에 Generator의 쓰임새나 Generator 자체 개념에 대해 더 공부해야 한다.</li>
<li>코루틴에 대해서도 공부해봐야 할 것 같다. 공부 중 접하게 된 키워드이다.</li>
<li>제너레이터에 대한 설명을 보강해야겠다.</li>
<li>이해가 완료되면 자체 제작한 예제 코드로 교체한다.</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">39</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-06T14:43:00.000Z">21-06-06</time></p><p class="title"><a href="/linux-ufw/">우분투의 SW 기반 방화벽 - UFW</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-30T14:35:00.000Z">21-05-30</time></p><p class="title"><a href="/linux-filesystem-ext/">리눅스 파일 시스템의 구조 - ext 계열</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-16T14:55:00.000Z">21-05-16</time></p><p class="title"><a href="/linux-namespaces-2/">Linux와 Docker의 기술적 관계 (2/3) - Network Namespace 기초</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-09T14:10:00.000Z">21-05-09</time></p><p class="title"><a href="/linux-tmux/">tmux 사용법 정리</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-11T14:55:00.000Z">21-04-11</time></p><p class="title"><a href="/linux-namespaces-1/">Linux와 Docker의 기술적 관계 (1/3) - Namespace</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>
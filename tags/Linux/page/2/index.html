<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>태그: Linux - JS QnA</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="JS QnA"><meta name="msapplication-TileImage" content="/images/jsqna2.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JS QnA"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="JS QnA"><meta property="og:url" content="https://jsqna.com/"><meta property="og:site_name" content="JS QnA"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jsqna.com/img/og_image.png"><meta property="article:author" content="Seongbin Kim"><meta property="article:tag" content="javascript"><meta property="article:tag" content="typescript"><meta property="article:tag" content="nodejs"><meta property="article:tag" content="reactjs"><meta property="article:tag" content="docker"><meta property="article:tag" content="kubernetes"><meta property="article:tag" content="ci"><meta property="article:tag" content="cd"><meta property="article:tag" content="jenkins"><meta property="article:tag" content="microservies"><meta property="article:tag" content="msa"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jsqna.com"},"headline":"JS QnA","image":["https://jsqna.com/img/og_image.png"],"author":{"@type":"Person","name":"Seongbin Kim"},"description":null}</script><link rel="icon" href="/images/jsqna2.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/seongbin9786/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">태그</a></li><li class="is-active"><a href="#" aria-current="page">Linux</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-04T14:55:00.000Z" title="2021-07-04T14:55:00.000Z">21-07-04</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-03T08:24:28.238Z" title="2021-07-03T08:24:28.238Z">21-07-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">4분안에 읽기 (약 571 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-virtualization-1/">리눅스에서의 가상화 솔루션의 종류와 특성 (1)</a></h1><div class="content"><blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64)</p>
</blockquote>
<p>이 글은 가상화에 대해 간략히 소개한다. 다음 글에서 리눅스에서의 가상화에 대해 조금 더 깊게 다룰 예정이다.</p>
<hr>
<h3 id="가상화란"><a href="#가상화란" class="headerlink" title="가상화란"></a><strong>가상화란</strong></h3><p>물리 자원을 추상화하는 방법 중 하나로, 하나의 물리 자원을 여러 개의 논리적 자원으로 나누거나, 여러 물리 자원을 하나의 논리적 자원으로 다루는 것을 말한다.</p>
<ul>
<li><p>각 자원이 서로에게 영향을 끼치지 못하므로, 장애 전파가 되지 않는다.</p>
</li>
<li><p>논리적인 자원을 유지하면서, 물리적인 자원을 교체할 수 있다.</p>
</li>
<li><p>물리적 자원간의 약간의 차이를 무시하기 위해 일반 사양으로 논리적 자원을 구성할 수 있다.</p>
</li>
</ul>
<hr>
<h3 id="가상화의-원리와-Linux에서의-가상화"><a href="#가상화의-원리와-Linux에서의-가상화" class="headerlink" title="가상화의 원리와 Linux에서의 가상화"></a><strong>가상화의 원리와 Linux에서의 가상화</strong></h3><p>기본적으로 가상화는 HW에서 지원해줘야 한다. 실제 CPU에 Guest OS를 실행했을 때, Guest OS가 제어권을 Host OS로 반환할 지 알 수 없기 때문이다. 따라서, HW는 Host OS가 관리할 수 있는 방식의 규칙과 제약을 제공한다. <a target="_blank" rel="noopener" href="https://superuser.com/questions/758018/how-does-virtualizing-differ-from-emulation-in-terms-of-structure">출처</a></p>
<p>가상화 방식은 크게 Type 1 (= Full Virtualization), Type 2(= Para Virtualization) 가 있는데, 리눅스에서는 KVM, XEN이 주요 가상화 솔루션이다. </p>
<ul>
<li><p>Type 1의 경우 OS 레벨 아래에 Virtual Machine Monitor(Hypervisor)가 HW Layer 사이에 낀 Layer로 하드웨어를 가상화한다. KVM이 Type 1이며, Windows Hyper-V도 Type 1이다.</p>
</li>
<li><p>Type 2의 경우 Host OS와 Guest OS 사이에 Hypervisor가 위치한다. VirtualBox, VMWare 등이 Type 2이다. Mac의 경우 Parallels가 Type 2이다.</p>
</li>
<li><p>Type 2의 경우 상대적으로 높은 성능을 제공한다고 알려져 있다. </p>
</li>
<li><p>다만 Type 2 방식은 기존 OS에 수정을 해서 Guest OS를 만들어야 한다는 단점이 있다. </p>
</li>
<li><p>리눅스는 Type 2 방식의 Guest OS를 잘 지원한다.</p>
</li>
<li><p>Docker의 경우 컨테이너 기술이 커널 위에서 지원되므로 Hypervisor가 필요 없으나, Windows 및 Mac에서는 Linux Kernel이 필요하므로 리눅스 OS를 가상화로 띄워야 하므로 Hypervisor가 필요하다.</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-27T14:55:00.000Z" title="2021-06-27T14:55:00.000Z">21-06-27</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-27T14:59:23.390Z" title="2021-06-27T14:59:23.390Z">21-06-27</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">4분안에 읽기 (약 606 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-sshd-security/">리눅스 - ssh/sshd의 보안에 대해 (2/2)</a></h1><div class="content"><p>이 글은 <a href="https://jsqna.com/linux-sshd-logs">1편</a>에 이어 SSHD의 보안 설정을 다룬다. SSHD의 설정 파일은 <code>/etc/ssh/sshd_config</code> 인데 아래의 내용은 해당 파일의 설정을 다룬다. 설정을 변경한 경우 <code>sudo systemctl restart sshd</code>로 SSHD를 재시작해줘야 한다. (WSL의 경우 systemctl이 지원되지 않는데, 단순히 <code>sudo service ssh --full-restart</code>를 실행하면 된다.)</p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64)<br>OpenSSH_8.2p1 Ubuntu-4ubuntu0.2, OpenSSL 1.1.1f  31 Mar 2020</p>
</blockquote>
<hr>
<h3 id="SSH-비밀번호-시도-횟수-제한"><a href="#SSH-비밀번호-시도-횟수-제한" class="headerlink" title="SSH 비밀번호 시도 횟수 제한"></a><strong>SSH 비밀번호 시도 횟수 제한</strong></h3><p>기본 설정은 사용자의 비밀번호 입력 오류가 아무리 많아도 접속을 끊지 않는데, 이 횟수를 제한하고 횟수를 넘으면 접속을 끊을 수 (<em>Too many authentication failures</em>) 있다. <code>#MaxAuthTries 6</code> 으로 적혀있는 주석(<code>#</code>)을 제거하면 된다. </p>
<hr>
<h3 id="SSH-포트-변경"><a href="#SSH-포트-변경" class="headerlink" title="SSH 포트 변경"></a><strong>SSH 포트 변경</strong></h3><p><code>#Port 22</code> 에서 <code>Port 2222</code> 등으로 변경해 포트를 변경할 수 있다. 변경된 포트로의 접속은 <code>ssh -p2222 sb@localhost</code> 로 포트를 옵션으로 제공해 접속할 수 있다.</p>
<hr>
<h3 id="프로토콜-버전-2-사용-1-사용-금지"><a href="#프로토콜-버전-2-사용-1-사용-금지" class="headerlink" title="프로토콜 버전 2 사용 (1 사용 금지)"></a><strong>프로토콜 버전 2 사용 (1 사용 금지)</strong></h3><p><code>Protocol 2</code> 라고 명시하므로써 SSH 프로토콜 1을 사용할 수 없게할 수 있다. (버전 2는 2006년에 나왔으므로, 버전 1이 얼마나 예전 버전인지 가늠할 수 있다… 1-&gt;2는 보안 위주의 개선이 있었다고 한다.)</p>
<blockquote>
<p>OpenSSH_8.2p1 Ubuntu-4ubuntu0.2, OpenSSL 1.1.1f  31 Mar 2020</p>
</blockquote>
<p>Ubuntu 20.04에서의 SSHD (8.2p1) 에서는 이미 해당 옵션이 기본이고, 설정 파일에 존재하지 않는다.</p>
<p>Protocol 2가 활성화된 경우, <code>ssh -1 sb@localhost</code>로 접속을 시도하는 경우 <code>SSH protocol v.1 is no longer supported</code>가 표시되며 접속이 거부된다.</p>
<hr>
<h3 id="비밀번호-기반-접속-방식-미사용"><a href="#비밀번호-기반-접속-방식-미사용" class="headerlink" title="비밀번호 기반 접속 방식 미사용"></a><strong>비밀번호 기반 접속 방식 미사용</strong></h3><p>비밀번호로 접속하는 방식은 브루트 포스 공격의 여지를 주게 되고, SSH Key 기반의 접속이 보편화된 요즘 필요성 또한 낮다.</p>
<p><code>PasswordAuthentication no</code> 옵션을 주면 비밀번호로는 접속할 수 없게 된다. (이 글에서의 openssh server는 기본 설정으로 no이다.)</p>
<hr>
<h3 id="루트-계정으로의-접속-금지"><a href="#루트-계정으로의-접속-금지" class="headerlink" title="루트 계정으로의 접속 금지"></a><strong>루트 계정으로의 접속 금지</strong></h3><p>루트 계정으로의 접속은 차단하는 것이 좋다. 애초에 루트 계정으로 접속할 수 있더라도, 접속하지 않는 것이 좋으므로 차단하도록 한다.</p>
<p><code>PermitRootLogin no</code> 옵션을 주면 된다. (신기하게도 기본 옵션이 아니다.)</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-20T14:00:00.000Z" title="2021-06-20T14:00:00.000Z">21-06-20</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-20T13:56:51.790Z" title="2021-06-20T13:56:51.790Z">21-06-20</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">6분안에 읽기 (약 973 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-system-log-1/">리눅스 - 시스템 로그와 로그인 로그</a></h1><div class="content"><p>이 글은 리눅스에서 기본으로 작성되는 로그 파일에 대해 간단하게 소개한다. 로그 파일의 내용, 작성되는 구조와 그 활용 방법까지 알아보려고 했으나, 범위가 너무 커지는 것 같아 이후 글의 주제로 남겨두려 한다.</p>
<hr>
<h2 id="rsyslogd와-var-log-디렉토리"><a href="#rsyslogd와-var-log-디렉토리" class="headerlink" title="rsyslogd와 /var/log 디렉토리"></a><strong>rsyslogd와 /var/log 디렉토리</strong></h2><p>rsyslog란 rocket-fast system for log processing의 약자로, 기존의 syslog 라는 로깅 데몬을 대체하는 시스템 로깅 데몬이다.</p>
<p><code>/var/log</code> 디렉토리에 생성된 로그 파일은 rsyslog에 의해 작성된 것들이다. 시스템 데몬이, 시스템 서비스의 로그를 수집한 것이기 때문에 애플리케이션 로그는 포함되지 않는다.</p>
<p>아래는 syslog 파일 내용 중 일부이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Jun 20 11:52:14 instance-01 kernel: [    0.000000] On node 0 totalpages: 523966</span><br><span class="line">Jun 20 11:52:14 instance-01 kernel: [    0.000000]   DMA zone: 64 pages used <span class="keyword">for</span> memmap</span><br><span class="line">Jun 20 11:52:14 instance-01 systemd[1]: Starting SSHGuard...</span><br><span class="line">Jun 20 11:52:15 instance-01 ntp[1577]:  * Starting NTP server ntpd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{ 출력 시간, 호스트명, 프로세스명, PID, 로그 내용 }</p>
</blockquote>
<p>위의 로그를 보면 특정 형식으로 작성되어있고, 여러 프로세스에서 출력이 됨을 알 수 있다. </p>
<p>굳이 호스트명이 포함된 이유는 로그를 중앙 집중식으로 저장하고 분석, 시각화하는 로그 서버로의 전송을 고려했다고 한다. (참고로 syslog의 설정을 통해 원격 서버로 파일을 전송할 수 있다. 그리고, 여러 서버의 로그를 중앙에서 저장하는 경우 ntpdate 등의 유틸을 사용한 시간 동기화가 필수라고 한다.)</p>
<p>로그 내용은 아는 만큼 보이기 때문에, 또 리눅스의 자체 기능의 로그만이 들어있기 때문에 특정 metric을 잡고 이게 이런 의미이다.와 같은 판단을 내리기가 어려운 듯하다. 이건 로그를 공부할 게 아니라, 리눅스 자체의 기능을 공부해야 이해할 수 있는 부분으로 보인다.</p>
<hr>
<h2 id="로그인과-관련된-로그-모음"><a href="#로그인과-관련된-로그-모음" class="headerlink" title="로그인과 관련된 로그 모음"></a><strong>로그인과 관련된 로그 모음</strong></h2><h4 id="auth-log"><a href="#auth-log" class="headerlink" title="auth.log"></a><strong>auth.log</strong></h4><p>인증 관련해선 (즉, SSH 위주) 로그 파일이 이 파일에 작성된다. 아마 단일 파일로는 auth.log가 제일 크지 않을까 싶은데, 대략 btmp(아래에서 소개)의 2배 정도의 파일 크기를 갖는 듯하다. (아무래도 SSH 접속 시도가 잦기 때문이다.)</p>
<hr>
<h4 id="로그인-성공-기록"><a href="#로그인-성공-기록" class="headerlink" title="로그인 성공 기록"></a><strong>로그인 성공 기록</strong></h4><p>last는 사용자 로그인 현황을 반환하는 명령어이다(성공한 로그인만 기록한다). wtmp 파일은 로그인, 로그아웃 기록이 저장되는 파일이다.</p>
<p><img src="/images/linux-system-log/last.png"></p>
<hr>
<h4 id="로그인-실패-기록"><a href="#로그인-실패-기록" class="headerlink" title="로그인 실패 기록"></a><strong>로그인 실패 기록</strong></h4><p>재밌는 점은 로그인 실패의 경우 <code>lastb</code>라는 별개의 명령어로 조회할 수 있다는 점이다. 또, 잘 보면 로그인 실패 기록이 매우 매우 많다. 얼마나 많냐면, wtmp 파일의 크기는 9.0K 인데, btmp는 576K 이다!</p>
<p><img src="/images/linux-system-log/lastb.png"></p>
<hr>
<h4 id="현재-로그인된-세션"><a href="#현재-로그인된-세션" class="headerlink" title="현재 로그인된 세션"></a><strong>현재 로그인된 세션</strong></h4><p>명령어 who를 입력하면 현재 로그인 세션 정보를 출력한다. 세션 정보는 utmp 파일에 저장된다. 다만 utmp파일은 /var/log 디렉토리에서 바로 보이진 않았다.</p>
<p><img src="/images/linux-system-log/who.png"></p>
<hr>
<h2 id="SEE-ALSO"><a href="#SEE-ALSO" class="headerlink" title="SEE ALSO"></a><strong>SEE ALSO</strong></h2><p>test/test 계정을 만들어 놓고 해커가 어떤 형태로 접속하고 무슨 일을 했는 지 분석한 글: <a target="_blank" rel="noopener" href="https://whackur.tistory.com/88">우분투 리눅스 침투 사후 로그보기</a>도 참고하면 재밌을 것 같다 :)</p>
<hr>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h2><ol>
<li><p>ELK 기반으로 로그를 중앙 집중식으로 받아와 질의와 시각화를 할 수 있을 것 같은데 나중에 다뤄보려고 한다.</p>
</li>
<li><p>sshd, common_auth 파일 무슨 PAM 개념이 나오던데, 잘 조사해서 SSH 보안 설정에 대해 다뤄보려고 한다.</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-13T14:55:00.000Z" title="2021-06-13T14:55:00.000Z">21-06-13</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-27T14:17:29.020Z" title="2021-06-27T14:17:29.020Z">21-06-27</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">4분안에 읽기 (약 609 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-sshd-logs/">리눅스 - ssh/sshd의 보안에 대해 (1/2)</a></h1><div class="content"><p>이 글은 리눅스의 RDP나 다름 없는 SSH에 대해 간략히 소개하고, 보안 측면에서의 기능을 일부 다룬다.</p>
<hr>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a><strong>SSH</strong></h3><p>SSH는 22번 포트를 사용하며 HTTPS와 같이 안전한 Layer를 감싼 Remote Shell이다. 접속 대상 Host는 SSH Daemon이 띄워져있어야 하며 OpenSSH(<code>openssh-server</code>)이 실질적 표준이다.</p>
<hr>
<h3 id="SSH-포트-변경"><a href="#SSH-포트-변경" class="headerlink" title="SSH 포트 변경"></a><strong>SSH 포트 변경</strong></h3><p>SSH를 인터넷 대상으로 Open(ALLOW 0.0.0.0)하는 경우 어떻게 알고 찾아왔는지, 아래와 같이 많은 곳에서 임의의 접근을 다수 받을 수 있다. 따라서 22번 포트에서 임의의 포트로 바꾸는 것이 기본이라고 할 수 있다. (물론 그래도 공격은 충분히 가능하다.)</p>
<hr>
<h3 id="SSH-로그-확인"><a href="#SSH-로그-확인" class="headerlink" title="SSH 로그 확인"></a><strong>SSH 로그 확인</strong></h3><p>SSH 로그는 sshd 접속 기록이 없는 경우 딱히 기록되지 않으니, 클라우드에서 SSH port를 Open해 놓고 하루 정도만 기다려도 로그가 많이 쌓이게 된다(ㅎㅎ..). 아래의 커맨드로 쉽게 확인할 수 있으며, <code>auth.log</code> 파일 자체는 다른 내용도 많이 담고 있으며, 파일이 커지면 <code>auth.log.1</code>과 같이 rolling 된다.</p>
<blockquote>
<p>$ cat /var/log/auth.log | grep sshd</p>
</blockquote>
<p><img src="/images/linux-sshd/sshd_log.png" alt="단순히 시도한 사용자명만 나열해도 이정도..."></p>
<hr>
<h3 id="Bation-Host-사용"><a href="#Bation-Host-사용" class="headerlink" title="Bation Host 사용"></a><strong>Bation Host 사용</strong></h3><p><img src="/images/linux-sshd/bastion_host.png" alt="로드밸런서, 배스쳔 호스트 예시"></p>
<hr>
<p>물론 접속 자체를 특정 네트워크 대역(고정 IP겠죠?)으로 제한하고, 특정 네트워크로 VPN을 사용해도 되겠지만, 그렇게 하기 어려운 경우라면 Bastion Host를 사용하는 것도 방법이다. 애플리케이션 서버 등은 보통 로드 밸런서 뒤에 숨기 때문에 굳이 외부로 노출되지 않는데 SSH 때문에 이를 Public Subnet으로 옮기는 것도 좋지 못하므로, 낮은 사양의 PC를 인터넷 대역에 오픈하고 해당 PC만이 내부망의 서버들과 통신할 수 있도록 하면 적절하다.</p>
<hr>
<p><img src="/images/linux-sshd/sshd_example_arch.png" alt="로드밸런서, 배스쳔 호스트 예시"></p>
<hr>
<p>SSH Proxy와 같은 여러 얘기가 있지만 간단하게 command를 실행시키는 형태로 쉽게 접속이 가능하다.</p>
<blockquote>
<p>$ ssh -t user@BASTION_HOST ssh user@INTERNAL_SERVER</p>
</blockquote>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>SSH의 많은 설정 중 보안에 관련된 설정을 더 알아보기</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-06T14:43:00.000Z" title="2021-06-06T14:43:00.000Z">21-06-06</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-06T14:43:18.680Z" title="2021-06-06T14:43:18.680Z">21-06-06</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">7분안에 읽기 (약 1118 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-ufw/">우분투의 SW 기반 방화벽 - UFW</a></h1><div class="content"><p>이 글은 데비안 계열(우분투 등)에서 사용되는 ufw에 대해 다룬다. ufw는 iptables라는 유틸을 활용하는 유틸이고, iptables는 리눅스 커널의 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netfilter">netfilter</a>라는 기능의 인터페이스(CLI)이다. 많은 사람들이 간단한 보안 수요에 대해서는 iptables의 복잡성 때문에 ufw를 사용하는 것을 권장한다.</p>
<blockquote>
<p>iptables is a command line interface of netfilter, which is the underlying mechanics in the kernel for all of the work related. It has been (mostly) replaced by nftables (netfilter-tables) which provides more (advanced) features and a unified interface for IPv4/IPv6/ARP/Ethernet Bridges. But both iptables and nftables requires manually writing rules since they are kind of low-level.</p>
<p>UFW wraps around nftables (used to be iptables&amp;ip6tables) and provides a much-easier-to-use command line interface for managing basic firewall functionalities, hence its name.</p>
<p>I personally recommend using UFW directly if all you want is a simple firewall. Otherwise you may use firewalld or write iptables/nftables rules directly.</p>
</blockquote>
<p>출처: <a target="_blank" rel="noopener" href="https://www.quora.com/What-is-the-difference-between-iptables-and-uncomplicated-firewall-UFW-in-Linux">Quora</a></p>
<hr>
<p>iptables는 아래 도표 중 hook API를 활용하는 인터페이스이다.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Netfilter-components.svg/2880px-Netfilter-components.svg.png" alt="img"></p>
<hr>
<p>아래는 Netfilter와 리눅스 내, 외부의 처리 흐름이라고 한다.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Netfilter-packet-flow.svg/2880px-Netfilter-packet-flow.svg.png" alt="img"></p>
<hr>
<p>Netfilter와 Iptables에 대해 더 자세히 알고 싶은 경우 <a target="_blank" rel="noopener" href="https://www.kangtaeho.com/66">iptables와 netfilter 정리 | 리눅스, 클라우드, IT 관련 기술 블로그</a>를 참고하기 바란다.</p>
<hr>
<h3 id="1-사용해야-할-때"><a href="#1-사용해야-할-때" class="headerlink" title="1. 사용해야 할 때"></a><strong>1. 사용해야 할 때</strong></h3><p>ufw를 언제 써야 할까? 해당 Host의 앞 단에 보안 장비가 없고, 포트 접근 제어가 필요할 때이다. 리눅스를 클라이언트로 사용하는 경우 열린 포트가 없어 비교적 안전하지만 서버 단의 경우 그렇지 않다.</p>
<hr>
<h3 id="2-간단한-사용법"><a href="#2-간단한-사용법" class="headerlink" title="2. 간단한 사용법"></a><strong>2. 간단한 사용법</strong></h3><p>ufw는 기본적으로 비활성화돼있는데, <code>sudo ufw enable</code> 로 활성화할 수 있다. 활성화 시 기본 설정만으로도 iptables의 NAT Table 설정이 자동 생성된다. 이는 ufw가 iptables의 wrapper이자 간단한 설정을 상세한 설정으로 변환시키는 역할을 담당함을 보여준다. (출처: <a target="_blank" rel="noopener" href="https://thebook.io/006718/part02/ch05/06/">초보 시스템 관리자의 일기 | 우분투 방화벽 ufw로 시스템 보호하기</a>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">administrator@test02:~$ sudo iptables -L</span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target prot opt <span class="built_in">source</span>                    destination</span><br><span class="line">ufw-before-logging-input all -- anywhere                anywhere</span><br><span class="line">ufw-before-input all -- anywhere                 anywhere</span><br><span class="line">ufw-after-input all -- anywhere                 anywhere</span><br><span class="line">ufw-after-logging-input all -- anywhere                anywhere</span><br><span class="line">ufw-reject-input all -- anywhere                 anywhere</span><br><span class="line">ufw-track-input all -- anywhere                 anywhere</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target prot opt <span class="built_in">source</span>                    destination</span><br><span class="line">ufw-before-logging-forward all -- anywhere                anywhere</span><br><span class="line">ufw-before-forward all -- anywhere                anywhere</span><br><span class="line">ufw-after-forward all -- anywhere                anywhere</span><br><span class="line">ufw-after-logging-forward all -- anywhere                anywhere</span><br><span class="line">ufw-reject-forward all -- anywhere                anywhere</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target prot opt <span class="built_in">source</span>                    destination</span><br><span class="line">ufw-before-logging-output all -- anywhere                anywhere</span><br><span class="line">ufw-before-output all -- anywhere                anywhere</span><br><span class="line">ufw-after-output all -- anywhere                anywhere</span><br><span class="line">ufw-after-logging-output all -- anywhere                anywhere</span><br><span class="line">ufw-reject-output all -- anywhere                anywhere</span><br><span class="line">ufw-track-output all -- anywhere                anywhere</span><br><span class="line"></span><br><span class="line">Chain ufw-after-forward (1 references)</span><br><span class="line">...</span><br><span class="line">Chain ufw-after-input (1 references)</span><br><span class="line">...</span><br><span class="line">Chain ufw-after-logging-forward (1 references)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<hr>
<p>ufw의 사용법은 매우 간단하다. <code>ufw &#123;action&#125; &#123;port | serviceName&#125;</code>를 입력하면 된다. 이 때 서비스의 목록은 <code>cat /etc/services</code>로 확인할 수 있고, <code>ufw deny ssh</code>와 같이 사용할 수 있다. 아래와 같이 ufw도 status 명령을 지원한다. (<code>iptables -L</code>에 비해 가독성이 훨씬 낫다.)</p>
<p><img src="/images/linux-ufw/ufw_deny_status.png" alt="ufw_deny_status"></p>
<hr>
<p>ufw는 기본적으로 whitelisting이지만, <code>ufw default allow</code>를 실행하면 blacklisting으로 전환할 수 있다.</p>
<hr>
<p>ufw의 규칙을 제거하려면 <code>ufw delete &#123;규칙 내용&#125;</code> 으로 가능하다.</p>
<p><img src="/images/linux-ufw/ufw_delete_deny.png" alt="ufw_delete_deny"></p>
<hr>
<h3 id="3-‘우선-규칙’-적용하기"><a href="#3-‘우선-규칙’-적용하기" class="headerlink" title="3. ‘우선 규칙’ 적용하기"></a><strong>3. ‘우선 규칙’ 적용하기</strong></h3><p>보안 설정의 경우 우선 정의한 규칙이 적용된다고 한다. 즉, 순차적으로 ALLOW를 check하고, ALLOW되는 경우 통과하는 것이다. 이 경우 넓은 범위의 규칙은 뒤에 놓고, 좁은 범위의 (IP 차단 등) 규칙은 앞에 놓는 게 맞다.</p>
<p>‘우선 규칙’은 <code>sudo nano /etc/ufw/before.rules</code>에서 작성할 수 있다. <code>End required lines</code> 주석 아래에 <code>-A ufw-before-input -s &#123;Target_IP_Address, ...&#125; -j DROP</code> 을 추가하면 해당 IP를 모든 포트에 대해 접근 제한할 수 있다. (<a target="_blank" rel="noopener" href="https://happist.com/561474/%EC%9A%B0%EB%B6%84%ED%88%AC-18-04%EB%A1%9C-%EC%84%9C%EB%B2%84-%EC%9A%B4%EC%98%81-ufw%EB%A1%9C-%EB%B0%A9%ED%99%94%EB%B2%BD-%EC%84%A4%EC%A0%95">출처</a>)</p>
<hr>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h3><p>Logging에 대해 더 알아보기. (리눅스 로깅은 분량이 많고 어려운 것 같다.)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://serverfault.com/questions/516838/where-are-the-logs-for-ufw-located-on-ubuntu-server">https://serverfault.com/questions/516838/where-are-the-logs-for-ufw-located-on-ubuntu-server</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rsyslog.com/">https://www.rsyslog.com/</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-30T14:35:00.000Z" title="2021-05-30T14:35:00.000Z">21-05-30</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-30T14:34:58.590Z" title="2021-05-30T14:34:58.590Z">21-05-30</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">5분안에 읽기 (약 751 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-filesystem-ext/">리눅스 파일 시스템의 구조 - ext 계열</a></h1><div class="content"><p>이 글은 리눅스에서의 파일 시스템 중 ext 계열에 대해 설명한다.</p>
<hr>
<h3 id="1-ext2"><a href="#1-ext2" class="headerlink" title="1. ext2"></a><strong>1. ext2</strong></h3><p>ext2는 (ext를 개선한) 리눅스의 초기 파일 시스템이다. 개선된 버전인 ext3, ext4도 있으나, 많은 자료에서 ext2를 비중 있게 다루므로 이 글에서도 동일한 형태로 ext2를 위주로 서술한다.</p>
<hr>
<p><img src="https://i.stack.imgur.com/cP4XD.png" alt="ext disk layout"></p>
<hr>
<p>ext2는 디스크를 부트 섹터와 <strong>블록 그룹</strong>으로 분할한다. 블록 그룹이란, 일정한 크기의 블록의 집합을 의미한다. (정확히는 마지막 블록은 크기 제한에서 자유롭다.)</p>
<ul>
<li><p>파일 저장 시 동일한 블록 그룹 내에 저장하도록 스케줄링한다.</p>
</li>
<li><p>블록 그룹은 아래의 필드를 갖는다. 아래의 필드 중 Super Block, Group Descriptor Table은 하나만 있어도 충분하나 백업 용도로 각 블록 그룹에 사본으로 저장된다(일관성 유지에 대한 내용은 잘 모르겠다.)</p>
<table>
<thead>
<tr>
<th>필드명</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Super Block</td>
<td>1KB의 크기의 자료구조로, 블록의 크기, 총 블록의 개수, 블록 그룹의 개수, i-node의 개수, 그룹 내 블록의 개수, 그룹 내 i-node의 개수 등의 정보를 저장한다.</td>
</tr>
<tr>
<td>Group Descriptor Table</td>
<td>Group Descriptor의 <strong>테이블</strong>이다. 각 Descriptor는 Block Bitmap(아래 필드)의 블록 번호, 그룹 내의 빈 블록 개수, 그룹 내의 i-node 개수, 그룹 안의 빈 디렉토리 개수를 저장한다.</td>
</tr>
<tr>
<td>Block Bitmap</td>
<td>각 블록의 할당 여부를 bit(0,1)로 표시한다.</td>
</tr>
<tr>
<td>i-node Bitmap</td>
<td>i-node의 할당 여부를 bit로 표시한다.</td>
</tr>
<tr>
<td>i-node Table</td>
<td>아래의 i-node를 테이블 형태로 저장한다.</td>
</tr>
<tr>
<td>(actual) i-nodes</td>
<td>(위의 테이블 형태로 저장된 것이다.) 128Byte의 크기를 가지며, 실제 파일/디렉토리의 위치를 저장한다. 파일의 메타 데이터를 보관한다. 각 파일/디렉토리는 i-node와 1:1로 대응되며 i-node를 알고 있다면 i-node에 저장된 블록 그룹을 확인할 수 있다. (자세한 필드는 아래 표에서 확인바란다.)</td>
</tr>
<tr>
<td>(actual) blocks</td>
<td>실제로 데이터가 저장되는 블록이다.</td>
</tr>
</tbody></table>
</li>
<li><p>i-node를 구성하는 필드는 아래와 같다.</p>
<table>
<thead>
<tr>
<th>필드명</th>
</tr>
</thead>
<tbody><tr>
<td>Inode Number</td>
</tr>
<tr>
<td>파일 모드</td>
</tr>
<tr>
<td>하드 링크 개수</td>
</tr>
<tr>
<td>소유자 정보</td>
</tr>
<tr>
<td>파일 크기</td>
</tr>
<tr>
<td>마지막 접근/수정 시각</td>
</tr>
<tr>
<td>데이터 블록의 개수</td>
</tr>
<tr>
<td>직접 블록 (대부분의 작은 파일은 직접 블록으로도 커버가 충분히 된다.)</td>
</tr>
<tr>
<td>간접 블록 / 이중 간접 블록 / 삼중 간접 블록 (linked list 개념)</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="2-ext-2-vs-3-4"><a href="#2-ext-2-vs-3-4" class="headerlink" title="2. ext 2 vs 3,4"></a><strong>2. ext 2 vs 3,4</strong></h3><p>구조적으로 큰 차이보단 성능 개선 등에 초점이 맞춰져 있다.</p>
<table>
<thead>
<tr>
<th>features</th>
<th>ext2</th>
<th>ext3</th>
<th>ext4</th>
</tr>
</thead>
<tbody><tr>
<td>전원 문제 시 데이터 저장 손실 (저널링 파일 시스템 지원 여부)</td>
<td>문제 발생</td>
<td>저널링 지원됨</td>
<td>저널링 지원됨</td>
</tr>
<tr>
<td>파일 최대 크기</td>
<td>2TiB</td>
<td>2TiB</td>
<td>16TiB</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-16T14:55:00.000Z" title="2021-05-16T14:55:00.000Z">21-05-16</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-16T14:53:19.710Z" title="2021-05-16T14:53:19.710Z">21-05-16</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">6분안에 읽기 (약 841 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-namespaces-2/">Linux와 Docker의 기술적 관계 (2/3) - Network Namespace 기초</a></h1><div class="content"><p>출처: <a target="_blank" rel="noopener" href="https://www.44bits.io/ko/post/container-network-2-ip-command-and-network-namespace">ip로 직접 만들어보는 네트워크 네임스페이스와 브리지 네트워크</a></p>
<p>도커의 기반이 되는 네트워크 네임스페이스 기술에 대해 다룬다.</p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64) (Docker Desktop)</p>
<p>일부 기능은 Native Docker에서만 정상 작동하여 아래 환경도 활용하였다.<br>Ubuntu 20.04.1 LTS (GCP Compute Engine) (Native Docker)</p>
</blockquote>
<hr>
<h4 id="Network-Namepsace의-역할"><a href="#Network-Namepsace의-역할" class="headerlink" title="Network Namepsace의 역할"></a><strong>Network Namepsace의 역할</strong></h4><p>Network Namespace는 프로세스의 네트워크 환경을 분리한다. 기본적으로 프로세스의 네트워크 네임스페이스는 default 네임스페이스에 속한다.</p>
<hr>
<h4 id="Network-Namepsace-사용-방법"><a href="#Network-Namepsace-사용-방법" class="headerlink" title="Network Namepsace 사용 방법"></a><strong>Network Namepsace 사용 방법</strong></h4><p>아래에서 계속 사용하게 될 프로그램인 <strong>ip</strong>는 리눅스에서 네트워크를 관리하는 표준 유틸이며, 네트워크 네임스페이스 기능 또한 내장돼있다.</p>
<hr>
<p><code>ip link</code> : 네트워크 디바이스 목록 조회</p>
<p><img src="/images/linux-network-namespace/ip_link.png"></p>
<p>이 결과는 위에서 말했듯, default 네트워크 네임스페이스에 속한 네트워크 디바이스의 목록이 출력된 것이다.</p>
<hr>
<ol>
<li><p><code>ip netns add &#123;NAMESPACE_TITLE&#125;</code> : 새로운 네트워크 네임스페이스 생성</p>
</li>
<li><p><code>ip netns exec &#123;NAMESPACE_TITLE&#125; &#123;COMMAND&#125;</code> : 특정 네트워크 네임스페이스에서 특정 명렁 수행</p>
</li>
<li><p><code>ip link set dev ip netns exec &#123;DEVICE_TITLE&#125; &#123;up|down&#125;</code> : 특정 네트워크 디바이스를 Enable/Disable 하도록 설정</p>
</li>
</ol>
<hr>
<h4 id="Network-Namepsace의-독립성"><a href="#Network-Namepsace의-독립성" class="headerlink" title="Network Namepsace의 독립성"></a><strong>Network Namepsace의 독립성</strong></h4><p>위에서 소개한 명령으로 네트워크 네임스페이스(<code>direct_netns</code>라고 아래에선 사용했다.)를 하나 생성한 후, default 네임스페이스에서 접속을 시도하는 경우 잘 되지 않는다. 이는 네임스페이스 간의 연결이 격리돼있기 때문이다.</p>
<p>약간의 셋업 과정으로 네트워크 네임스페이스의 격리 기능을 체험할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns add direct_netns</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns ip link <span class="built_in">set</span> dev lo up</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns nginx -g <span class="string">&#x27;daemon off;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>위 커맨드를 통해 direct_netns 네임스페이스를 만들고, loopback 어댑터를 up 상태로 만들어주고, nginx를 실행하면 아래의 내용을 확인할 수 있다.</p>
<p>default 네트워크 네임스페이스에서는 curl 수행 시 접근할 수 없지만,</p>
<p><img src="/images/linux-network-namespace/ip_just_curl.png"></p>
<p>direct_netns 네트워크 네임스페이스에서는 curl 수행 시 정상 접근이 된다.</p>
<p><img src="/images/linux-network-namespace/ip_netns_curl.png"></p>
<p>당연히, <code>netstat -nat | grep LISTEN</code> 의 수행 결과도 다르다.</p>
<hr>
<h4 id="Network-Namepsace간의-연결"><a href="#Network-Namepsace간의-연결" class="headerlink" title="Network Namepsace간의 연결"></a><strong>Network Namepsace간의 연결</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># veth 생성 및 한 쪽(veth1)을 direct_netns로 이전</span></span><br><span class="line">ip link add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line">ip link <span class="built_in">set</span> veth1 netns direct_netns</span><br><span class="line"></span><br><span class="line"><span class="comment"># IP 할당</span></span><br><span class="line">ip a add 10.200.0.2/24 dev veth0</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns ip a add 10.200.0.3/24 dev veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Up 상태로 지정</span></span><br><span class="line">ip link <span class="built_in">set</span> dev veth0 up</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns ip link <span class="built_in">set</span> dev veth1 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping 수행 (정상 작동 확인)</span></span><br><span class="line">ping 10.200.0.3</span><br><span class="line">ip netns <span class="built_in">exec</span> direct_netns ping 10.200.0.2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>veth(Virtual Ethernet Device)란 리눅스에서 사용하는 가상 네트워크 인터페이스를 의미하며, ip 명령어로 생성하는 것이 가능하다. 항상 쌍으로 만들어진다고 한다.</p>
</blockquote>
<p>위와 같은 형태로 두 네트워크를 이어 통신할 수 있게도 할 수 있다.</p>
<hr>
<p>TODO:</p>
<ul>
<li>브릿지 네트워크, NAT 등 소개</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-09T14:10:00.000Z" title="2021-05-09T14:10:00.000Z">21-05-09</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-09T14:02:32.368Z" title="2021-05-09T14:02:32.368Z">21-05-09</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">3분안에 읽기 (약 475 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-tmux/">tmux 사용법 정리</a></h1><div class="content"><p>tmux의 사용법을 알아본다. 그동안 너무 귀찮아서.. 여러 터미널이 필요할 때 그냥 여러 터미널을 사용했었는데, Ubuntu에 기본으로 내장돼있기도 하고 고수 분들이 기본으로 사용하시는 것들을 어깨 너머로 봤기 때문에 약간의 시간을 들여 학습했다. </p>
<hr>
<h4 id="1-네트워크-연결-보호-기능"><a href="#1-네트워크-연결-보호-기능" class="headerlink" title="1. 네트워크 연결 보호 기능"></a><strong>1. 네트워크 연결 보호 기능</strong></h4><p>ssh 연결과 터미널 화면의 생명주기가 별개이다.</p>
<p>터미널을 실수로 꺼도, ssh 연결은 백그라운드로 살아 있다.</p>
<ul>
<li>새 터미널을 열어서 <code>tmux at(tach)</code> 로 다시 세션에 붙을 수 있다.</li>
<li><code>tmux at -t 세션넘버</code>로 특정 세션을 종료할 수 있다.</li>
</ul>
<hr>
<h4 id="2-다중-화면-기능"><a href="#2-다중-화면-기능" class="headerlink" title="2. 다중 화면 기능"></a><strong>2. 다중 화면 기능</strong></h4><ul>
<li><p>Ctrl + b 를 통해 명령어 모드 활성</p>
</li>
<li><p>Ctrl + b 후 <code>&quot;</code>를 누르면 새 <strong>가로</strong> 패널 생성 (<code>%</code>를 누르면 <strong>세로</strong> 패널 생성)</p>
</li>
<li><p>Ctrl + b + <code>방향키</code>를 누르면 각 패널 전환</p>
</li>
<li><p>Ctrl + b + <code>z</code>를 누르면 현재 활성 패널을 전체화면으로 전환 (toggle)</p>
</li>
<li><p>Ctrl + b + <code>Alt + 방향키</code>를 누르면 현재 패널의 크기를 조절</p>
</li>
<li><p>Ctrl + b + <code>space</code>를 누르면 preset 패널 구성으로 배열함</p>
</li>
<li><p>Ctrl + b + <code>d</code>를 누르면 tmux에서 원래 터미널로 돌아옴. (<code>tmux ls</code>로 각 세션 넘버 확인을, <code>tmux</code>로 새 세션을 생성할 수도 있다.)</p>
</li>
<li><p>새 세션인지는 tmux의 상태바에서 <code>[0]</code>의 숫자를 확인하면 된다. (이 경우 0).</p>
</li>
<li><p>Ctrl + b + <code>x</code>로 현재 패널을 제거할 수 있다. (마지막 패널 제거 시 현재 tmux 세션이 종료된다.)</p>
</li>
</ul>
<hr>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a><strong>TODO</strong></h4><ol>
<li>셸 프로그래밍 기초 학습하기</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/zx">google/zx</a> 써보고 가이드 작성하기<ul>
<li>너무 좋은 것 같다. async/await에 딱 맞는 자체 선언형 API에 nodejs를 그대로 사용할 수 있다는 점이 너무 좋다.</li>
</ul>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-11T14:55:00.000Z" title="2021-04-11T14:55:00.000Z">21-04-11</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-16T12:05:12.880Z" title="2021-05-16T12:05:12.880Z">21-05-16</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">8분안에 읽기 (약 1220 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-namespaces-1/">Linux와 Docker의 기술적 관계 (1/3) - Namespace</a></h1><div class="content"><p>이 글은 리눅스의 Namespace 기능의 일부를 다룬다. 도커의 내용도 포함되겠으나 리눅스 자체의 기능에 주안점을 둔다. 우선 PID, UTS를 다루고, chroot에 대해서도 소개한다.</p>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64) (Docker Desktop)</p>
<p>일부 기능은 Native Docker에서만 정상 작동하여 아래 환경도 활용하였다.<br>Ubuntu 20.04.1 LTS (GCP Compute Engine) (Native Docker)</p>
</blockquote>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.44bits.io/ko/keyword/linux-container">리눅스 컨테이너</a>는 리눅스 <strong>네임스페이스</strong>와 루트 파일 시스템 격리 등의 기능을 사용해 격리시킨 프로세스를 의미한다.</p>
</blockquote>
<h3 id="namespace라는-기술에-대해"><a href="#namespace라는-기술에-대해" class="headerlink" title="namespace라는 기술에 대해"></a><strong>namespace라는 기술에 대해</strong></h3><p><a target="_blank" rel="noopener" href="https://www.44bits.io/ko/keyword/linux-namespace">리눅스 네임스페이스(Linux Namespace)란?</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_namespaces">Namespace</a>는 한 개의 특정 프로세스에 대해 시스템 리소스를 논리적으로 격리하는 기능이다. 아래와 같이 여러 가지의 Namespace가 존재한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 cgroup -&gt; <span class="string">&#x27;cgroup:[4026531835]&#x27;</span> <span class="comment"># cgroup = control group = CPU,RAM,NET 할당</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 ipc -&gt; <span class="string">&#x27;ipc:[4026532188]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 06:41 mnt -&gt; <span class="string">&#x27;mnt:[4026532186]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 net -&gt; <span class="string">&#x27;net:[4026531992]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 pid -&gt; <span class="string">&#x27;pid:[4026532189]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 08:35 pid_for_children -&gt; <span class="string">&#x27;pid:[4026532189]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 user -&gt; <span class="string">&#x27;user:[4026531837]&#x27;</span> </span><br><span class="line">lrwxrwxrwx 1 root root 0 Apr  9 07:53 uts -&gt; <span class="string">&#x27;uts:[4026532187]&#x27;</span> <span class="comment"># uts=Unix Time-Sharing / Host, Domain name 할당</span></span><br></pre></td></tr></table></figure>
<p>Docker에서 사용하는 Namespace의 목록은 아래와 같다.</p>
<ul>
<li><code>ipc, mnt, net, pid, pid_for_children, uts</code></li>
</ul>
<h4 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a><strong>PID Namespace</strong></h4><ol>
<li><p>분리된 새로운 네임스페이스에서는 PID=1부터 시작하나, 기존 네임스페이스에서도 (다른 PID로) 해당 프로세스를 볼 수 있으며, 이는 PID=1부터 시작하지 않는다.</p>
</li>
<li><p><code>ls -alh /proc/&#123;PID&#125;/ns</code> - PID에 대응되는 프로세스가 속한 네임스페이스를 출력한다. (sym link 형태의 구성)</p>
</li>
</ol>
<ul>
<li><p>위의 결과는 같은 1번 프로세스에서 생성된 경우 모두 같은 값을 갖는다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ diff &lt;(ls -Al /proc/1/ns | awk <span class="string">&#x27;&#123; print $11 &#125;&#x27;</span>) \ </span><br><span class="line">&lt;(ls -Al /proc/&#123;임의의_프로세스ID&#125;/ns | awk <span class="string">&#x27;&#123; print $11 &#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>User namespace는 UID 0을 줘서 root  <strong>같아 보이는</strong> - 어느 정도 제한된 - 권한을 제공할 수 있다. User namespace는 initial이 있고, 매 생성마다 Parent-Child 구조를 갖는다.</p>
</li>
<li><p>PID namespace 격리를 위해선 격리된 디렉토리에서의 모든 의존성이 준비 돼야 한다. - 의존성? docker Image가 하는 일이 바로 그것이니, docker Image를 활용해 mount한 폴더를 활용할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ~</span><br><span class="line">$ docker <span class="built_in">export</span> ~ &gt; ~.tar</span><br><span class="line">$ tar xf ~</span><br><span class="line">$ sudo unshare -p -f --mount-proc chroot . ./image_extracted_dir /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo $$</span></span><br><span class="line">&gt; 1</span><br></pre></td></tr></table></figure></li>
<li><p><code>unshare</code> 명령어를 써서 PID를 격리해 1번 프로세스가 되는 예시:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ unshare -p -f --mount-proc chroot . /bin/sh</span><br><span class="line">&gt; <span class="built_in">echo</span> $$ : 1</span><br><span class="line"></span><br><span class="line">$ unshare -p /bin/sh</span><br><span class="line">&gt; <span class="built_in">echo</span> $$: 3481</span><br></pre></td></tr></table></figure></li>
<li><p>각종 옵션들 정리</p>
<ol>
<li><code>p</code>: <em>PID 네임스페이스는 분리가 되었을텐데</em> 로 짐작해보건데 PID 네임스페이스를 의미하는 듯하다.</li>
<li><code>f</code>: <code>--fork</code>의 의미로, <code>unshare</code>의 child process로 실행한다고 한다.</li>
<li><code>--mount-proc</code>: <code>/proc</code> 이 기본값이어서, 기존 proc과 격리될 수 없다. 위 명령어에선 현재 폴더(.)를 넘겼다. </li>
</ol>
<ul>
<li>man page에선 <em>The new proc filesystem is explicitly as private</em>라고 하는데, 여기서 <em>private</em>이 무슨 뜻인지 모르겠다. 그리고, <em>mount proc filesystem</em>한다는 표현도 무슨 뜻인지 잘 모르겠다.</li>
<li>shell이 지원하는 명령어가 아니라 바이너리를 실행하려고 하면 <code>2: Cannot fork</code>라고 뜬다. Why?</li>
</ul>
<ol start="4">
<li>Host Shell에서 <code>ps -ef</code>하면 unshare도 하나의 프로세스로 뜨고, <code>sudo kill -9 3481</code> 하면 unshare도 종료된다.</li>
<li>프로세스 3481 == 프로세스 1 (unshare도 단지 하나의 프로세스)</li>
<li><code>/proc</code> 이 기본 PID namepsace이고, <code>init</code> 프로세스(pid 1)에 의해 pid namespace가 다 동일하다.</li>
<li><code>unshare</code>로 다른 디렉토리에 PID namespace를 mount하면 그 때부터 pid namepsace 값이 다른 값으로 할당됨</li>
</ol>
</li>
</ol>
<h4 id="UTS-Namepsace"><a href="#UTS-Namepsace" class="headerlink" title="UTS Namepsace"></a><strong>UTS Namepsace</strong></h4><p>출처: <a target="_blank" rel="noopener" href="https://www.44bits.io/ko/post/container-network-1-uts-namespace">UTS 네임스페이스를 사용한 호스트네임 격리 - 컨테이너 네트워크 기초 1편</a></p>
<p>UTS Namespace는 호스트 네임을 분리한다. 딱 이것만 한다. 별로 기능은 없다.</p>
<p>docker는 컨테이너마다 컨테이너ID로 호스트네임을 부여한다. 이 기능을 구현하는 방법은 무엇일까? <code>nsenter</code>로 가능하다. <code>nsenter</code>는 unshare로 지정한 네임스페이스 정보를 기반으로 프로세스를 실행하는 프로그램이다.</p>
<ol>
<li><code>unshare --uts=/tmp/utsns1 hostname utsns1</code> 명령으로 utsns1로 새로운 namespace를 정의하고 실행할 수 있다.</li>
<li><code>/tmp/utsns1</code> 파일에 unshare 설정을 저장한 후, </li>
<li><code>nsenter --uts=/tmp/utsns1 hostname</code> 수행 시 utsns1를 출력할 수 있다.</li>
</ol>
<h4 id="Network-Namepsace"><a href="#Network-Namepsace" class="headerlink" title="Network Namepsace"></a><strong>Network Namepsace</strong></h4><p>Network Namespace는 프로세스의 네트워크 환경을 분리한다. 실제로 docker 컨테이너마다 네트워크 인터페이스와 IP가 부여된다.</p>
<ul>
<li>(2편에서 확인할 예정)</li>
</ul>
<hr>
<p>TODO:</p>
<ul>
<li>네트워크 부분 더 공부하기</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-04T12:35:00.000Z" title="2021-04-04T12:35:00.000Z">21-04-04</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-04-11T15:01:06.260Z" title="2021-04-11T15:01:06.260Z">21-04-12</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">8분안에 읽기 (약 1135 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/linux-user-and-sudo/">리눅스에서의 sudo와 권한 관리 (1)</a></h1><div class="content"><p>이 글은 리눅스에서 sudo를 소개하고, 권한 관리에 대해 생각해본다. 예시 중에서 사용자를 생성하는 방법 또한 다룬다.</p>
<p>참고 자료</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/Sudo">sudo | Wikipedia (KR)</a></li>
</ul>
<blockquote>
<p>기준 환경:</p>
<p>Ubuntu 20.04.1 LTS (WSL2 by Windows 10 x64)</p>
</blockquote>
<hr>
<blockquote>
<p>su와 sudo는 약자이다. su는 “substitute user”, sudo는 “substitute user do”이다.</p>
</blockquote>
<h3 id="리눅스에서의-su-사용법과-사용자-생성"><a href="#리눅스에서의-su-사용법과-사용자-생성" class="headerlink" title="리눅스에서의 su 사용법과 사용자 생성"></a><strong>리눅스에서의 su 사용법과 사용자 생성</strong></h3><p>su는 현재 로그인된 사용자에서 다른 사용자로 로그인하는 것이다.</p>
<p>사용자 목록은 <code>cat /etc/passwd</code>로 볼 수 있다. (이름과 다르게 비밀번호가 나오진 않는다.) </p>
<p>각 사용자의 암호화된 비밀번호를 확인하려면 <code>cat /etc/shadow</code>를 확인하라.</p>
<p>어떤 암호화가 쓰였는지는 <code>cat /etc/pam.d/common-password</code>로 확인할 수 있다 - 기준 환경에서는 <code>sha-512</code>를 사용한다. (출처: <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/8229/what-methods-are-used-to-encrypt-passwords-in-etc-passwd-and-etc-shadow">What methods are used to encrypt passwords in /etc/passwd and /etc/shadow?</a>)</p>
<hr>
<p>재밌는 점은, 사용자가 직접 만든 계정이 아닌 경우 로그인할 수 없게 되있다는 점이다. (출처: <a target="_blank" rel="noopener" href="https://askubuntu.com/questions/426990/what-are-the-default-passwords-of-these-users-nobody-daemon-uucp-etc">What are the default passwords of these users: nobody, daemon, uucp, etc.?</a>)</p>
<p><img src="/images/linux-sudo/sudoer2.png" alt="모든 그룹의 이름만 출력한 경우"></p>
<p>만약 ‘사람이 사용하는 용도의’ 사용자 목록을 확인하려면, <code>cat /bin/bash /etc/passwd</code>로 확인할 수 있다.</p>
<p><img src="/images/linux-sudo/sudoer3.png" alt="시스템 계정 제외하고 출력"></p>
<hr>
<p>사용자를 추가해서, 해당 사용자로 로그인해보자.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd tmp <span class="comment"># tmp는 유저명이다. 나머지는 자동으로 생성해준다. (단, 비밀번호가 없는 상태이다.)</span></span><br><span class="line">sudo passwd tmp <span class="comment"># 로그인을 하려면 비밀번호를 설정해야 한다. passwd 명령어로 비밀번호를 지정할 수 있다.</span></span><br><span class="line">su tmp</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> <span class="comment"># bash가 사라져서, 현재 셸을 출력해봤다. 기본 셸은 dash인걸로 아는데, /bin/sh를 사용하고 있다.</span></span><br><span class="line">bash <span class="comment"># bash shell로 전환한다.</span></span><br></pre></td></tr></table></figure>
<p>이렇게 로그인하면 bash가 사라지고, sh가 셸로 사용된다. (<code>chsh</code>로 바꿀 수 있다.)</p>
<hr>
<h3 id="사용자가-sudo를-사용할-수-있게-만들기-sudo의-권한에-대하여"><a href="#사용자가-sudo를-사용할-수-있게-만들기-sudo의-권한에-대하여" class="headerlink" title="사용자가 sudo를 사용할 수 있게 만들기, sudo의 권한에 대하여"></a><strong>사용자가 sudo를 사용할 수 있게 만들기, sudo의 권한에 대하여</strong></h3><p>sudo는 특정 작업을 root 권한으로 수행할 수 있게 하는 명령어이다. 특정 사용자를 sudo 그룹에 추가하기만 하면 된다: <code>sudo usermod -aG sudo &#123;사용자명&#125;</code>. 이후 사용자는 sudo 명령어를 사용할 수 있게 된다.</p>
<hr>
<p><img src="/images/linux-sudo/sudoer1.png" alt="sudo 파일의 내용"></p>
<p>각 유저에 대한 권한은 <code>/etc/sudoers</code>에 있는데, 권한의 포멧이 있다: <code>%sudo ALL=(ALL:ALL) ALL</code> 이것인데, (출처: <a target="_blank" rel="noopener" href="https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file">How To Edit the Sudoers File</a>) </p>
<table>
<thead>
<tr>
<th>%sudo</th>
<th>ALL=</th>
<th>(ALL:</th>
<th>ALL)</th>
<th>ALL</th>
</tr>
</thead>
<tbody><tr>
<td>username 규칙</td>
<td>hostname 규칙</td>
<td>sudo로 로그인할 수 있는 사용자 목록</td>
<td>sudo로 로그인할 수 있는 그룹 목록</td>
<td>root 권한으로 사용할 수 있는 명령어</td>
</tr>
</tbody></table>
<p>지금 알고 있는 지식으로는 sudo 파일의 Best Practice를 소개는 어렵기 때문에 추후로 미루지만, 권한 제어를 폭 넓게 할 수 있도록 필드가 5개나 된다는 점은 확인할 수 있었다. (아직 한 번도 sudoer 설정을 만져본 적이 없다는 점은 좀 부끄럽기도 하다.)</p>
<hr>
<h3 id="sudo의-장점"><a href="#sudo의-장점" class="headerlink" title="sudo의 장점"></a><strong>sudo의 장점</strong></h3><p>출처: <a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/135352/best-practices-for-hardening-sudo">Best practices for hardening sudo?</a></p>
<ol>
<li><p>sudo는 Root Password 공유를 막는다.</p>
</li>
<li><p><code>syslog</code> 등의 명령을 통해, sudo를 사용하는 경우 원격 서버로 로그를 전송하게 해서 더 빠르게 침입을 알아낼 수 있다.</p>
</li>
<li><p>제대로 권한 설정만 한다면 Root 권한보다 많이 축소되므로 침입자가 모든 기록을 말소하지 못하게 할 수 있다. (온전한 root 권한을 탈취 당한 경우 아무 소용이 없게 된다.)</p>
</li>
</ol>
<blockquote>
<p>위 출처의 아래 답변에서 얻은 사실인데, <code>ssh_user</code> 그룹을 만들어 remote login만 가능하게 하면 공격자가 ssh credential을 탈취하더라도 sudo 명령을 활용할 수 없기 때문에 보안 상 더 안전하다고 한다. (굉장히 유용한 방법인 듯하다.)</p>
</blockquote>
<hr>
<p>TODO:</p>
<ul>
<li>프로덕션 배포용 서버에 적절한 sudoer 설정에 대해 찾아보기</li>
<li>sudo 등의 예시 외에도 리눅스 상에서 보안 관련한 기능과 설정들을 찾아보기</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/Linux/">이전</a></div><div class="pagination-next"><a href="/tags/Linux/page/3/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/Linux/">1</a></li><li><a class="pagination-link is-current" href="/tags/Linux/page/2/">2</a></li><li><a class="pagination-link" href="/tags/Linux/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars0.githubusercontent.com/u/28754907?s=460&amp;v=4" alt="Seongbin Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Seongbin Kim</p><p class="is-size-6 is-block">Previous SW Engineer @ ROKCC</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/seongbin9786" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/seongbin9786"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/sphilee/functional-programming-jargon" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">FP Jargon (Javascript, KR)</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ExpressJs/"><span class="level-start"><span class="level-item">ExpressJs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Frontend/React-js/"><span class="level-start"><span class="level-item">React.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/NCloud/"><span class="level-start"><span class="level-item">NCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/RabbitMQ/"><span class="level-start"><span class="level-item">RabbitMQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/NestJs/"><span class="level-start"><span class="level-item">NestJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="level-start"><span class="level-item">Node.js 디자인 패턴</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="level-start"><span class="level-item">함수형 자바스크립트</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T14:43:00.000Z">21-10-10</time></p><p class="title"><a href="/linux-ipc-unix-domain-socket/">리눅스에서의 IPC Socket vs Network Socket</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-03T14:50:00.000Z">21-10-03</time></p><p class="title"><a href="/linux-install-zsh/">ZSH를 WSL2에 설치하는 방법</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-26T14:50:00.000Z">21-09-26</time></p><p class="title"><a href="/linux-shell-2-screen/">screen: 리눅스에서 셸을 유지하면서 나갔다 들어오는 방법</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-19T14:30:00.000Z">21-09-19</time></p><p class="title"><a href="/linux-profile-not-loaded/">왜 .profile 파일이 적용되지 않을까</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-12T13:33:00.000Z">21-09-12</time></p><p class="title"><a href="/linux-debian-dpkg-apt/">데비안 리눅스 패키지 매니저 dpkg와 apt</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">10월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">9월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">2월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">1월 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">12월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">9월 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/1-Month-Docker/"><span class="tag">1 Month Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI/"><span class="tag">CI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CI-CD/"><span class="tag">CI/CD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ExpressJs/"><span class="tag">ExpressJs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NCloud/"><span class="tag">NCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NestJs/"><span class="tag">NestJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><span class="tag">Node.js 디자인 패턴</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RabbitMQ/"><span class="tag">RabbitMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"><span class="tag">함수형 자바스크립트</span><span class="tag">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/jsqna.png" alt="JS QnA" height="28"></a><p class="is-size-7"><span>&copy; 2021 Seongbin Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script>
      var sc_project=12454169;
      var sc_invisible=1;
      var sc_security="6948ab3c";
      var sc_https=1;
      var sc_remove_link=1;</script><script src="https://www.statcounter.com/counter/counter.js" async></script><noscript><div class="statcounter"><img class="statcounter" src="https://c.statcounter.com/12454169/0/6948ab3c/1/" alt="real time web analytics"></div></noscript><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"O4LVCS99Q2","apiKey":"e9e721a0e73113a0679bdea020ff6d1a","indexName":"JSQnA"}, {"hint":"입력 하세요...","no_result":"에 대한 결과 없음","untitled":"(제목 없음)","empty_preview":"(미리보기 없음)"});
        });</script></body></html>